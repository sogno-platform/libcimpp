#include "assignments.hpp"
#include <sstream>
#include <utility>
#include <unordered_map>
#include <regex>
#include <fstream>

#include "Folders.hpp"

typedef bool (*assign_function)(std::stringstream&, BaseClass*);
static std::unordered_map<std::string, assign_function> dynamic_switch_factory();
static std::unordered_map<std::string, assign_function> dynamic_switch = dynamic_switch_factory();

bool assign(BaseClass* CIMObj, const std::string& CIMAttrName, const std::string& Value)
{
	std::unordered_map<std::string, assign_function>::iterator it = dynamic_switch.find(CIMAttrName);
	if(it == dynamic_switch.end())
		return false;
	std::stringstream str;
	str << Value;
	return (*it->second)(str, CIMObj);
}


std::istream& operator>>(std::istream& lop, IEC61970::Base::Domain::UnitMultiplier& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "UnitMultiplier")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "y")
	{
		rop = IEC61970::Base::Domain::UnitMultiplier::y;
		return lop;
	}
	
	if(EnumSymbol == "z")
	{
		rop = IEC61970::Base::Domain::UnitMultiplier::z;
		return lop;
	}
	
	if(EnumSymbol == "a")
	{
		rop = IEC61970::Base::Domain::UnitMultiplier::a;
		return lop;
	}
	
	if(EnumSymbol == "f")
	{
		rop = IEC61970::Base::Domain::UnitMultiplier::f;
		return lop;
	}
	
	if(EnumSymbol == "p")
	{
		rop = IEC61970::Base::Domain::UnitMultiplier::p;
		return lop;
	}
	
	if(EnumSymbol == "n")
	{
		rop = IEC61970::Base::Domain::UnitMultiplier::n;
		return lop;
	}
	
	if(EnumSymbol == "micro")
	{
		rop = IEC61970::Base::Domain::UnitMultiplier::micro;
		return lop;
	}
	
	if(EnumSymbol == "m")
	{
		rop = IEC61970::Base::Domain::UnitMultiplier::m;
		return lop;
	}
	
	if(EnumSymbol == "c")
	{
		rop = IEC61970::Base::Domain::UnitMultiplier::c;
		return lop;
	}
	
	if(EnumSymbol == "d")
	{
		rop = IEC61970::Base::Domain::UnitMultiplier::d;
		return lop;
	}
	
	if(EnumSymbol == "none")
	{
		rop = IEC61970::Base::Domain::UnitMultiplier::none;
		return lop;
	}
	
	if(EnumSymbol == "da")
	{
		rop = IEC61970::Base::Domain::UnitMultiplier::da;
		return lop;
	}
	
	if(EnumSymbol == "h")
	{
		rop = IEC61970::Base::Domain::UnitMultiplier::h;
		return lop;
	}
	
	if(EnumSymbol == "k")
	{
		rop = IEC61970::Base::Domain::UnitMultiplier::k;
		return lop;
	}
	
	if(EnumSymbol == "M")
	{
		rop = IEC61970::Base::Domain::UnitMultiplier::M;
		return lop;
	}
	
	if(EnumSymbol == "G")
	{
		rop = IEC61970::Base::Domain::UnitMultiplier::G;
		return lop;
	}
	
	if(EnumSymbol == "T")
	{
		rop = IEC61970::Base::Domain::UnitMultiplier::T;
		return lop;
	}
	
	if(EnumSymbol == "P")
	{
		rop = IEC61970::Base::Domain::UnitMultiplier::P;
		return lop;
	}
	
	if(EnumSymbol == "E")
	{
		rop = IEC61970::Base::Domain::UnitMultiplier::E;
		return lop;
	}
	
	if(EnumSymbol == "Z")
	{
		rop = IEC61970::Base::Domain::UnitMultiplier::Z;
		return lop;
	}
	
	if(EnumSymbol == "Y")
	{
		rop = IEC61970::Base::Domain::UnitMultiplier::Y;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}

std::istream& operator>>(std::istream& lop, IEC61970::Base::Domain::UnitSymbol& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "UnitSymbol")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "none")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::none;
		return lop;
	}
	
	if(EnumSymbol == "m")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::m;
		return lop;
	}
	
	if(EnumSymbol == "kg")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::kg;
		return lop;
	}
	
	if(EnumSymbol == "s")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::s;
		return lop;
	}
	
	if(EnumSymbol == "A")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::A;
		return lop;
	}
	
	if(EnumSymbol == "K")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::K;
		return lop;
	}
	
	if(EnumSymbol == "mol")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::mol;
		return lop;
	}
	
	if(EnumSymbol == "cd")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::cd;
		return lop;
	}
	
	if(EnumSymbol == "deg")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::deg;
		return lop;
	}
	
	if(EnumSymbol == "rad")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::rad;
		return lop;
	}
	
	if(EnumSymbol == "sr")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::sr;
		return lop;
	}
	
	if(EnumSymbol == "Gy")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::Gy;
		return lop;
	}
	
	if(EnumSymbol == "Bq")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::Bq;
		return lop;
	}
	
	if(EnumSymbol == "degC")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::degC;
		return lop;
	}
	
	if(EnumSymbol == "Sv")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::Sv;
		return lop;
	}
	
	if(EnumSymbol == "F")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::F;
		return lop;
	}
	
	if(EnumSymbol == "C")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::C;
		return lop;
	}
	
	if(EnumSymbol == "S")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::S;
		return lop;
	}
	
	if(EnumSymbol == "H")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::H;
		return lop;
	}
	
	if(EnumSymbol == "V")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::V;
		return lop;
	}
	
	if(EnumSymbol == "ohm")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::ohm;
		return lop;
	}
	
	if(EnumSymbol == "J")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::J;
		return lop;
	}
	
	if(EnumSymbol == "N")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::N;
		return lop;
	}
	
	if(EnumSymbol == "Hz")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::Hz;
		return lop;
	}
	
	if(EnumSymbol == "lx")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::lx;
		return lop;
	}
	
	if(EnumSymbol == "lm")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::lm;
		return lop;
	}
	
	if(EnumSymbol == "Wb")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::Wb;
		return lop;
	}
	
	if(EnumSymbol == "T")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::T;
		return lop;
	}
	
	if(EnumSymbol == "W")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::W;
		return lop;
	}
	
	if(EnumSymbol == "Pa")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::Pa;
		return lop;
	}
	
	if(EnumSymbol == "m2")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::m2;
		return lop;
	}
	
	if(EnumSymbol == "m3")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::m3;
		return lop;
	}
	
	if(EnumSymbol == "mPers")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::mPers;
		return lop;
	}
	
	if(EnumSymbol == "mPers2")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::mPers2;
		return lop;
	}
	
	if(EnumSymbol == "m3Pers")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::m3Pers;
		return lop;
	}
	
	if(EnumSymbol == "mPerm3")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::mPerm3;
		return lop;
	}
	
	if(EnumSymbol == "kgm")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::kgm;
		return lop;
	}
	
	if(EnumSymbol == "kgPerm3")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::kgPerm3;
		return lop;
	}
	
	if(EnumSymbol == "WPermK")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::WPermK;
		return lop;
	}
	
	if(EnumSymbol == "JPerK")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::JPerK;
		return lop;
	}
	
	if(EnumSymbol == "ppm")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::ppm;
		return lop;
	}
	
	if(EnumSymbol == "rotPers")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::rotPers;
		return lop;
	}
	
	if(EnumSymbol == "radPers")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::radPers;
		return lop;
	}
	
	if(EnumSymbol == "VA")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::VA;
		return lop;
	}
	
	if(EnumSymbol == "VAr")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::VAr;
		return lop;
	}
	
	if(EnumSymbol == "cosPhi")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::cosPhi;
		return lop;
	}
	
	if(EnumSymbol == "Vs")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::Vs;
		return lop;
	}
	
	if(EnumSymbol == "V2")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::V2;
		return lop;
	}
	
	if(EnumSymbol == "As")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::As;
		return lop;
	}
	
	if(EnumSymbol == "A2")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::A2;
		return lop;
	}
	
	if(EnumSymbol == "A2s")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::A2s;
		return lop;
	}
	
	if(EnumSymbol == "VAh")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::VAh;
		return lop;
	}
	
	if(EnumSymbol == "Wh")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::Wh;
		return lop;
	}
	
	if(EnumSymbol == "VArh")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::VArh;
		return lop;
	}
	
	if(EnumSymbol == "VPerHz")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::VPerHz;
		return lop;
	}
	
	if(EnumSymbol == "HzPers")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::HzPers;
		return lop;
	}
	
	if(EnumSymbol == "character")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::character;
		return lop;
	}
	
	if(EnumSymbol == "charPers")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::charPers;
		return lop;
	}
	
	if(EnumSymbol == "kgm2")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::kgm2;
		return lop;
	}
	
	if(EnumSymbol == "dB")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::dB;
		return lop;
	}
	
	if(EnumSymbol == "WPers")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::WPers;
		return lop;
	}
	
	if(EnumSymbol == "lPers")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::lPers;
		return lop;
	}
	
	if(EnumSymbol == "dBm")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::dBm;
		return lop;
	}
	
	if(EnumSymbol == "h")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::h;
		return lop;
	}
	
	if(EnumSymbol == "min")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::min;
		return lop;
	}
	
	if(EnumSymbol == "Q")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::Q;
		return lop;
	}
	
	if(EnumSymbol == "Qh")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::Qh;
		return lop;
	}
	
	if(EnumSymbol == "ohmm")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::ohmm;
		return lop;
	}
	
	if(EnumSymbol == "APerm")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::APerm;
		return lop;
	}
	
	if(EnumSymbol == "V2h")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::V2h;
		return lop;
	}
	
	if(EnumSymbol == "A2h")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::A2h;
		return lop;
	}
	
	if(EnumSymbol == "Ah")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::Ah;
		return lop;
	}
	
	if(EnumSymbol == "count")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::count;
		return lop;
	}
	
	if(EnumSymbol == "ft3")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::ft3;
		return lop;
	}
	
	if(EnumSymbol == "m3Perh")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::m3Perh;
		return lop;
	}
	
	if(EnumSymbol == "gal")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::gal;
		return lop;
	}
	
	if(EnumSymbol == "Btu")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::Btu;
		return lop;
	}
	
	if(EnumSymbol == "l")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::l;
		return lop;
	}
	
	if(EnumSymbol == "lPerh")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::lPerh;
		return lop;
	}
	
	if(EnumSymbol == "lPerl")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::lPerl;
		return lop;
	}
	
	if(EnumSymbol == "gPerg")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::gPerg;
		return lop;
	}
	
	if(EnumSymbol == "molPerm3")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::molPerm3;
		return lop;
	}
	
	if(EnumSymbol == "molPermol")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::molPermol;
		return lop;
	}
	
	if(EnumSymbol == "molPerkg")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::molPerkg;
		return lop;
	}
	
	if(EnumSymbol == "sPers")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::sPers;
		return lop;
	}
	
	if(EnumSymbol == "HzPerHz")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::HzPerHz;
		return lop;
	}
	
	if(EnumSymbol == "VPerV")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::VPerV;
		return lop;
	}
	
	if(EnumSymbol == "APerA")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::APerA;
		return lop;
	}
	
	if(EnumSymbol == "VPerVA")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::VPerVA;
		return lop;
	}
	
	if(EnumSymbol == "rev")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::rev;
		return lop;
	}
	
	if(EnumSymbol == "kat")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::kat;
		return lop;
	}
	
	if(EnumSymbol == "JPerkg")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::JPerkg;
		return lop;
	}
	
	if(EnumSymbol == "m3Uncompensated")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::m3Uncompensated;
		return lop;
	}
	
	if(EnumSymbol == "m3Compensated")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::m3Compensated;
		return lop;
	}
	
	if(EnumSymbol == "WPerW")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::WPerW;
		return lop;
	}
	
	if(EnumSymbol == "therm")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::therm;
		return lop;
	}
	
	if(EnumSymbol == "onePerm")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::onePerm;
		return lop;
	}
	
	if(EnumSymbol == "m3Perkg")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::m3Perkg;
		return lop;
	}
	
	if(EnumSymbol == "Pas")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::Pas;
		return lop;
	}
	
	if(EnumSymbol == "Nm")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::Nm;
		return lop;
	}
	
	if(EnumSymbol == "NPerm")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::NPerm;
		return lop;
	}
	
	if(EnumSymbol == "radPers2")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::radPers2;
		return lop;
	}
	
	if(EnumSymbol == "WPerm2")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::WPerm2;
		return lop;
	}
	
	if(EnumSymbol == "JPerkgK")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::JPerkgK;
		return lop;
	}
	
	if(EnumSymbol == "JPerm3")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::JPerm3;
		return lop;
	}
	
	if(EnumSymbol == "VPerm")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::VPerm;
		return lop;
	}
	
	if(EnumSymbol == "CPerm3")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::CPerm3;
		return lop;
	}
	
	if(EnumSymbol == "CPerm2")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::CPerm2;
		return lop;
	}
	
	if(EnumSymbol == "FPerm")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::FPerm;
		return lop;
	}
	
	if(EnumSymbol == "HPerm")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::HPerm;
		return lop;
	}
	
	if(EnumSymbol == "JPermol")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::JPermol;
		return lop;
	}
	
	if(EnumSymbol == "JPermolK")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::JPermolK;
		return lop;
	}
	
	if(EnumSymbol == "CPerkg")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::CPerkg;
		return lop;
	}
	
	if(EnumSymbol == "GyPers")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::GyPers;
		return lop;
	}
	
	if(EnumSymbol == "WPersr")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::WPersr;
		return lop;
	}
	
	if(EnumSymbol == "WPerm2sr")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::WPerm2sr;
		return lop;
	}
	
	if(EnumSymbol == "katPerm3")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::katPerm3;
		return lop;
	}
	
	if(EnumSymbol == "d")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::d;
		return lop;
	}
	
	if(EnumSymbol == "anglemin")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::anglemin;
		return lop;
	}
	
	if(EnumSymbol == "anglesec")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::anglesec;
		return lop;
	}
	
	if(EnumSymbol == "ha")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::ha;
		return lop;
	}
	
	if(EnumSymbol == "tonne")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::tonne;
		return lop;
	}
	
	if(EnumSymbol == "bar")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::bar;
		return lop;
	}
	
	if(EnumSymbol == "mmHg")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::mmHg;
		return lop;
	}
	
	if(EnumSymbol == "M")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::M;
		return lop;
	}
	
	if(EnumSymbol == "kn")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::kn;
		return lop;
	}
	
	if(EnumSymbol == "Vh")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::Vh;
		return lop;
	}
	
	if(EnumSymbol == "Mx")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::Mx;
		return lop;
	}
	
	if(EnumSymbol == "G")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::G;
		return lop;
	}
	
	if(EnumSymbol == "Oe")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::Oe;
		return lop;
	}
	
	if(EnumSymbol == "WPerA")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::WPerA;
		return lop;
	}
	
	if(EnumSymbol == "SPerm")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::SPerm;
		return lop;
	}
	
	if(EnumSymbol == "onePerHz")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::onePerHz;
		return lop;
	}
	
	if(EnumSymbol == "VPerVAr")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::VPerVAr;
		return lop;
	}
	
	if(EnumSymbol == "ohmPerm")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::ohmPerm;
		return lop;
	}
	
	if(EnumSymbol == "kgPerJ")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::kgPerJ;
		return lop;
	}
	
	if(EnumSymbol == "JPers")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::JPers;
		return lop;
	}
	
	if(EnumSymbol == "m2Pers")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::m2Pers;
		return lop;
	}
	
	if(EnumSymbol == "JPerm2")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::JPerm2;
		return lop;
	}
	
	if(EnumSymbol == "KPers")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::KPers;
		return lop;
	}
	
	if(EnumSymbol == "PaPers")
	{
		rop = IEC61970::Base::Domain::UnitSymbol::PaPers;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}

std::istream& operator>>(std::istream& lop, IEC61970::Base::Core::PhaseCode& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "PhaseCode")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "ABCN")
	{
		rop = IEC61970::Base::Core::PhaseCode::ABCN;
		return lop;
	}
	
	if(EnumSymbol == "ABC")
	{
		rop = IEC61970::Base::Core::PhaseCode::ABC;
		return lop;
	}
	
	if(EnumSymbol == "ABN")
	{
		rop = IEC61970::Base::Core::PhaseCode::ABN;
		return lop;
	}
	
	if(EnumSymbol == "ACN")
	{
		rop = IEC61970::Base::Core::PhaseCode::ACN;
		return lop;
	}
	
	if(EnumSymbol == "BCN")
	{
		rop = IEC61970::Base::Core::PhaseCode::BCN;
		return lop;
	}
	
	if(EnumSymbol == "AB")
	{
		rop = IEC61970::Base::Core::PhaseCode::AB;
		return lop;
	}
	
	if(EnumSymbol == "AC")
	{
		rop = IEC61970::Base::Core::PhaseCode::AC;
		return lop;
	}
	
	if(EnumSymbol == "BC")
	{
		rop = IEC61970::Base::Core::PhaseCode::BC;
		return lop;
	}
	
	if(EnumSymbol == "AN")
	{
		rop = IEC61970::Base::Core::PhaseCode::AN;
		return lop;
	}
	
	if(EnumSymbol == "BN")
	{
		rop = IEC61970::Base::Core::PhaseCode::BN;
		return lop;
	}
	
	if(EnumSymbol == "CN")
	{
		rop = IEC61970::Base::Core::PhaseCode::CN;
		return lop;
	}
	
	if(EnumSymbol == "A")
	{
		rop = IEC61970::Base::Core::PhaseCode::A;
		return lop;
	}
	
	if(EnumSymbol == "B")
	{
		rop = IEC61970::Base::Core::PhaseCode::B;
		return lop;
	}
	
	if(EnumSymbol == "C")
	{
		rop = IEC61970::Base::Core::PhaseCode::C;
		return lop;
	}
	
	if(EnumSymbol == "N")
	{
		rop = IEC61970::Base::Core::PhaseCode::N;
		return lop;
	}
	
	if(EnumSymbol == "s1N")
	{
		rop = IEC61970::Base::Core::PhaseCode::s1N;
		return lop;
	}
	
	if(EnumSymbol == "s2N")
	{
		rop = IEC61970::Base::Core::PhaseCode::s2N;
		return lop;
	}
	
	if(EnumSymbol == "s12N")
	{
		rop = IEC61970::Base::Core::PhaseCode::s12N;
		return lop;
	}
	
	if(EnumSymbol == "s1")
	{
		rop = IEC61970::Base::Core::PhaseCode::s1;
		return lop;
	}
	
	if(EnumSymbol == "s2")
	{
		rop = IEC61970::Base::Core::PhaseCode::s2;
		return lop;
	}
	
	if(EnumSymbol == "s12")
	{
		rop = IEC61970::Base::Core::PhaseCode::s12;
		return lop;
	}
	
	if(EnumSymbol == "none")
	{
		rop = IEC61970::Base::Core::PhaseCode::none;
		return lop;
	}
	
	if(EnumSymbol == "X")
	{
		rop = IEC61970::Base::Core::PhaseCode::X;
		return lop;
	}
	
	if(EnumSymbol == "XY")
	{
		rop = IEC61970::Base::Core::PhaseCode::XY;
		return lop;
	}
	
	if(EnumSymbol == "XN")
	{
		rop = IEC61970::Base::Core::PhaseCode::XN;
		return lop;
	}
	
	if(EnumSymbol == "XYN")
	{
		rop = IEC61970::Base::Core::PhaseCode::XYN;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}

std::istream& operator>>(std::istream& lop, IEC61970::Base::Wires::RegulatingControlModeKind& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "RegulatingControlModeKind")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "voltage")
	{
		rop = IEC61970::Base::Wires::RegulatingControlModeKind::voltage;
		return lop;
	}
	
	if(EnumSymbol == "activePower")
	{
		rop = IEC61970::Base::Wires::RegulatingControlModeKind::activePower;
		return lop;
	}
	
	if(EnumSymbol == "reactivePower")
	{
		rop = IEC61970::Base::Wires::RegulatingControlModeKind::reactivePower;
		return lop;
	}
	
	if(EnumSymbol == "currentFlow")
	{
		rop = IEC61970::Base::Wires::RegulatingControlModeKind::currentFlow;
		return lop;
	}
	
	if(EnumSymbol == "admittance")
	{
		rop = IEC61970::Base::Wires::RegulatingControlModeKind::admittance;
		return lop;
	}
	
	if(EnumSymbol == "timeScheduled")
	{
		rop = IEC61970::Base::Wires::RegulatingControlModeKind::timeScheduled;
		return lop;
	}
	
	if(EnumSymbol == "temperature")
	{
		rop = IEC61970::Base::Wires::RegulatingControlModeKind::temperature;
		return lop;
	}
	
	if(EnumSymbol == "powerFactor")
	{
		rop = IEC61970::Base::Wires::RegulatingControlModeKind::powerFactor;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}

std::istream& operator>>(std::istream& lop, IEC61970::Base::AuxiliaryEquipment::PotentialTransformerKind& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "PotentialTransformerKind")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "inductive")
	{
		rop = IEC61970::Base::AuxiliaryEquipment::PotentialTransformerKind::inductive;
		return lop;
	}
	
	if(EnumSymbol == "capacitiveCoupling")
	{
		rop = IEC61970::Base::AuxiliaryEquipment::PotentialTransformerKind::capacitiveCoupling;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}

std::istream& operator>>(std::istream& lop, IEC61970::Base::Contingency::ContingencyEquipmentStatusKind& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "ContingencyEquipmentStatusKind")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "inService")
	{
		rop = IEC61970::Base::Contingency::ContingencyEquipmentStatusKind::inService;
		return lop;
	}
	
	if(EnumSymbol == "outOfService")
	{
		rop = IEC61970::Base::Contingency::ContingencyEquipmentStatusKind::outOfService;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}

std::istream& operator>>(std::istream& lop, IEC61970::Base::SCADA::Source& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "Source")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "PROCESS")
	{
		rop = IEC61970::Base::SCADA::Source::PROCESS;
		return lop;
	}
	
	if(EnumSymbol == "DEFAULTED")
	{
		rop = IEC61970::Base::SCADA::Source::DEFAULTED;
		return lop;
	}
	
	if(EnumSymbol == "SUBSTITUTED")
	{
		rop = IEC61970::Base::SCADA::Source::SUBSTITUTED;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}

std::istream& operator>>(std::istream& lop, IEC61970::Base::Meas::Validity& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "Validity")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "GOOD")
	{
		rop = IEC61970::Base::Meas::Validity::GOOD;
		return lop;
	}
	
	if(EnumSymbol == "QUESTIONABLE")
	{
		rop = IEC61970::Base::Meas::Validity::QUESTIONABLE;
		return lop;
	}
	
	if(EnumSymbol == "INVALID")
	{
		rop = IEC61970::Base::Meas::Validity::INVALID;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}

std::istream& operator>>(std::istream& lop, IEC61970::Base::ControlArea::ControlAreaTypeKind& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "ControlAreaTypeKind")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "AGC")
	{
		rop = IEC61970::Base::ControlArea::ControlAreaTypeKind::AGC;
		return lop;
	}
	
	if(EnumSymbol == "Forecast")
	{
		rop = IEC61970::Base::ControlArea::ControlAreaTypeKind::Forecast;
		return lop;
	}
	
	if(EnumSymbol == "Interchange")
	{
		rop = IEC61970::Base::ControlArea::ControlAreaTypeKind::Interchange;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}

std::istream& operator>>(std::istream& lop, IEC61970::Base::Generation::Production::GeneratorControlMode& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "GeneratorControlMode")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "setpoint")
	{
		rop = IEC61970::Base::Generation::Production::GeneratorControlMode::setpoint;
		return lop;
	}
	
	if(EnumSymbol == "pulse")
	{
		rop = IEC61970::Base::Generation::Production::GeneratorControlMode::pulse;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}

std::istream& operator>>(std::istream& lop, IEC61970::Base::Generation::Production::GeneratorControlSource& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "GeneratorControlSource")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "unavailable")
	{
		rop = IEC61970::Base::Generation::Production::GeneratorControlSource::unavailable;
		return lop;
	}
	
	if(EnumSymbol == "offAGC")
	{
		rop = IEC61970::Base::Generation::Production::GeneratorControlSource::offAGC;
		return lop;
	}
	
	if(EnumSymbol == "onAGC")
	{
		rop = IEC61970::Base::Generation::Production::GeneratorControlSource::onAGC;
		return lop;
	}
	
	if(EnumSymbol == "plantControl")
	{
		rop = IEC61970::Base::Generation::Production::GeneratorControlSource::plantControl;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}

std::istream& operator>>(std::istream& lop, IEC61970::Base::Domain::Currency& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "Currency")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "AED")
	{
		rop = IEC61970::Base::Domain::Currency::AED;
		return lop;
	}
	
	if(EnumSymbol == "AFN")
	{
		rop = IEC61970::Base::Domain::Currency::AFN;
		return lop;
	}
	
	if(EnumSymbol == "ALL")
	{
		rop = IEC61970::Base::Domain::Currency::ALL;
		return lop;
	}
	
	if(EnumSymbol == "AMD")
	{
		rop = IEC61970::Base::Domain::Currency::AMD;
		return lop;
	}
	
	if(EnumSymbol == "ANG")
	{
		rop = IEC61970::Base::Domain::Currency::ANG;
		return lop;
	}
	
	if(EnumSymbol == "AOA")
	{
		rop = IEC61970::Base::Domain::Currency::AOA;
		return lop;
	}
	
	if(EnumSymbol == "ARS")
	{
		rop = IEC61970::Base::Domain::Currency::ARS;
		return lop;
	}
	
	if(EnumSymbol == "AUD")
	{
		rop = IEC61970::Base::Domain::Currency::AUD;
		return lop;
	}
	
	if(EnumSymbol == "AWG")
	{
		rop = IEC61970::Base::Domain::Currency::AWG;
		return lop;
	}
	
	if(EnumSymbol == "AZN")
	{
		rop = IEC61970::Base::Domain::Currency::AZN;
		return lop;
	}
	
	if(EnumSymbol == "BAM")
	{
		rop = IEC61970::Base::Domain::Currency::BAM;
		return lop;
	}
	
	if(EnumSymbol == "BBD")
	{
		rop = IEC61970::Base::Domain::Currency::BBD;
		return lop;
	}
	
	if(EnumSymbol == "BDT")
	{
		rop = IEC61970::Base::Domain::Currency::BDT;
		return lop;
	}
	
	if(EnumSymbol == "BGN")
	{
		rop = IEC61970::Base::Domain::Currency::BGN;
		return lop;
	}
	
	if(EnumSymbol == "BHD")
	{
		rop = IEC61970::Base::Domain::Currency::BHD;
		return lop;
	}
	
	if(EnumSymbol == "BIF")
	{
		rop = IEC61970::Base::Domain::Currency::BIF;
		return lop;
	}
	
	if(EnumSymbol == "BMD")
	{
		rop = IEC61970::Base::Domain::Currency::BMD;
		return lop;
	}
	
	if(EnumSymbol == "BND")
	{
		rop = IEC61970::Base::Domain::Currency::BND;
		return lop;
	}
	
	if(EnumSymbol == "BOB")
	{
		rop = IEC61970::Base::Domain::Currency::BOB;
		return lop;
	}
	
	if(EnumSymbol == "BOV")
	{
		rop = IEC61970::Base::Domain::Currency::BOV;
		return lop;
	}
	
	if(EnumSymbol == "BRL")
	{
		rop = IEC61970::Base::Domain::Currency::BRL;
		return lop;
	}
	
	if(EnumSymbol == "BSD")
	{
		rop = IEC61970::Base::Domain::Currency::BSD;
		return lop;
	}
	
	if(EnumSymbol == "BTN")
	{
		rop = IEC61970::Base::Domain::Currency::BTN;
		return lop;
	}
	
	if(EnumSymbol == "BWP")
	{
		rop = IEC61970::Base::Domain::Currency::BWP;
		return lop;
	}
	
	if(EnumSymbol == "BYR")
	{
		rop = IEC61970::Base::Domain::Currency::BYR;
		return lop;
	}
	
	if(EnumSymbol == "BZD")
	{
		rop = IEC61970::Base::Domain::Currency::BZD;
		return lop;
	}
	
	if(EnumSymbol == "CAD")
	{
		rop = IEC61970::Base::Domain::Currency::CAD;
		return lop;
	}
	
	if(EnumSymbol == "CDF")
	{
		rop = IEC61970::Base::Domain::Currency::CDF;
		return lop;
	}
	
	if(EnumSymbol == "CHF")
	{
		rop = IEC61970::Base::Domain::Currency::CHF;
		return lop;
	}
	
	if(EnumSymbol == "CLF")
	{
		rop = IEC61970::Base::Domain::Currency::CLF;
		return lop;
	}
	
	if(EnumSymbol == "CLP")
	{
		rop = IEC61970::Base::Domain::Currency::CLP;
		return lop;
	}
	
	if(EnumSymbol == "CNY")
	{
		rop = IEC61970::Base::Domain::Currency::CNY;
		return lop;
	}
	
	if(EnumSymbol == "COP")
	{
		rop = IEC61970::Base::Domain::Currency::COP;
		return lop;
	}
	
	if(EnumSymbol == "COU")
	{
		rop = IEC61970::Base::Domain::Currency::COU;
		return lop;
	}
	
	if(EnumSymbol == "CRC")
	{
		rop = IEC61970::Base::Domain::Currency::CRC;
		return lop;
	}
	
	if(EnumSymbol == "CUC")
	{
		rop = IEC61970::Base::Domain::Currency::CUC;
		return lop;
	}
	
	if(EnumSymbol == "CUP")
	{
		rop = IEC61970::Base::Domain::Currency::CUP;
		return lop;
	}
	
	if(EnumSymbol == "CVE")
	{
		rop = IEC61970::Base::Domain::Currency::CVE;
		return lop;
	}
	
	if(EnumSymbol == "CZK")
	{
		rop = IEC61970::Base::Domain::Currency::CZK;
		return lop;
	}
	
	if(EnumSymbol == "DJF")
	{
		rop = IEC61970::Base::Domain::Currency::DJF;
		return lop;
	}
	
	if(EnumSymbol == "DKK")
	{
		rop = IEC61970::Base::Domain::Currency::DKK;
		return lop;
	}
	
	if(EnumSymbol == "DOP")
	{
		rop = IEC61970::Base::Domain::Currency::DOP;
		return lop;
	}
	
	if(EnumSymbol == "DZD")
	{
		rop = IEC61970::Base::Domain::Currency::DZD;
		return lop;
	}
	
	if(EnumSymbol == "EEK")
	{
		rop = IEC61970::Base::Domain::Currency::EEK;
		return lop;
	}
	
	if(EnumSymbol == "EGP")
	{
		rop = IEC61970::Base::Domain::Currency::EGP;
		return lop;
	}
	
	if(EnumSymbol == "ERN")
	{
		rop = IEC61970::Base::Domain::Currency::ERN;
		return lop;
	}
	
	if(EnumSymbol == "ETB")
	{
		rop = IEC61970::Base::Domain::Currency::ETB;
		return lop;
	}
	
	if(EnumSymbol == "EUR")
	{
		rop = IEC61970::Base::Domain::Currency::EUR;
		return lop;
	}
	
	if(EnumSymbol == "FJD")
	{
		rop = IEC61970::Base::Domain::Currency::FJD;
		return lop;
	}
	
	if(EnumSymbol == "FKP")
	{
		rop = IEC61970::Base::Domain::Currency::FKP;
		return lop;
	}
	
	if(EnumSymbol == "GBP")
	{
		rop = IEC61970::Base::Domain::Currency::GBP;
		return lop;
	}
	
	if(EnumSymbol == "GEL")
	{
		rop = IEC61970::Base::Domain::Currency::GEL;
		return lop;
	}
	
	if(EnumSymbol == "GHS")
	{
		rop = IEC61970::Base::Domain::Currency::GHS;
		return lop;
	}
	
	if(EnumSymbol == "GIP")
	{
		rop = IEC61970::Base::Domain::Currency::GIP;
		return lop;
	}
	
	if(EnumSymbol == "GMD")
	{
		rop = IEC61970::Base::Domain::Currency::GMD;
		return lop;
	}
	
	if(EnumSymbol == "GNF")
	{
		rop = IEC61970::Base::Domain::Currency::GNF;
		return lop;
	}
	
	if(EnumSymbol == "GTQ")
	{
		rop = IEC61970::Base::Domain::Currency::GTQ;
		return lop;
	}
	
	if(EnumSymbol == "GYD")
	{
		rop = IEC61970::Base::Domain::Currency::GYD;
		return lop;
	}
	
	if(EnumSymbol == "HKD")
	{
		rop = IEC61970::Base::Domain::Currency::HKD;
		return lop;
	}
	
	if(EnumSymbol == "HNL")
	{
		rop = IEC61970::Base::Domain::Currency::HNL;
		return lop;
	}
	
	if(EnumSymbol == "HRK")
	{
		rop = IEC61970::Base::Domain::Currency::HRK;
		return lop;
	}
	
	if(EnumSymbol == "HTG")
	{
		rop = IEC61970::Base::Domain::Currency::HTG;
		return lop;
	}
	
	if(EnumSymbol == "HUF")
	{
		rop = IEC61970::Base::Domain::Currency::HUF;
		return lop;
	}
	
	if(EnumSymbol == "IDR")
	{
		rop = IEC61970::Base::Domain::Currency::IDR;
		return lop;
	}
	
	if(EnumSymbol == "ILS")
	{
		rop = IEC61970::Base::Domain::Currency::ILS;
		return lop;
	}
	
	if(EnumSymbol == "INR")
	{
		rop = IEC61970::Base::Domain::Currency::INR;
		return lop;
	}
	
	if(EnumSymbol == "IQD")
	{
		rop = IEC61970::Base::Domain::Currency::IQD;
		return lop;
	}
	
	if(EnumSymbol == "IRR")
	{
		rop = IEC61970::Base::Domain::Currency::IRR;
		return lop;
	}
	
	if(EnumSymbol == "ISK")
	{
		rop = IEC61970::Base::Domain::Currency::ISK;
		return lop;
	}
	
	if(EnumSymbol == "JMD")
	{
		rop = IEC61970::Base::Domain::Currency::JMD;
		return lop;
	}
	
	if(EnumSymbol == "JOD")
	{
		rop = IEC61970::Base::Domain::Currency::JOD;
		return lop;
	}
	
	if(EnumSymbol == "JPY")
	{
		rop = IEC61970::Base::Domain::Currency::JPY;
		return lop;
	}
	
	if(EnumSymbol == "KES")
	{
		rop = IEC61970::Base::Domain::Currency::KES;
		return lop;
	}
	
	if(EnumSymbol == "KGS")
	{
		rop = IEC61970::Base::Domain::Currency::KGS;
		return lop;
	}
	
	if(EnumSymbol == "KHR")
	{
		rop = IEC61970::Base::Domain::Currency::KHR;
		return lop;
	}
	
	if(EnumSymbol == "KMF")
	{
		rop = IEC61970::Base::Domain::Currency::KMF;
		return lop;
	}
	
	if(EnumSymbol == "KPW")
	{
		rop = IEC61970::Base::Domain::Currency::KPW;
		return lop;
	}
	
	if(EnumSymbol == "KRW")
	{
		rop = IEC61970::Base::Domain::Currency::KRW;
		return lop;
	}
	
	if(EnumSymbol == "KWD")
	{
		rop = IEC61970::Base::Domain::Currency::KWD;
		return lop;
	}
	
	if(EnumSymbol == "KYD")
	{
		rop = IEC61970::Base::Domain::Currency::KYD;
		return lop;
	}
	
	if(EnumSymbol == "KZT")
	{
		rop = IEC61970::Base::Domain::Currency::KZT;
		return lop;
	}
	
	if(EnumSymbol == "LAK")
	{
		rop = IEC61970::Base::Domain::Currency::LAK;
		return lop;
	}
	
	if(EnumSymbol == "LBP")
	{
		rop = IEC61970::Base::Domain::Currency::LBP;
		return lop;
	}
	
	if(EnumSymbol == "LKR")
	{
		rop = IEC61970::Base::Domain::Currency::LKR;
		return lop;
	}
	
	if(EnumSymbol == "LRD")
	{
		rop = IEC61970::Base::Domain::Currency::LRD;
		return lop;
	}
	
	if(EnumSymbol == "LSL")
	{
		rop = IEC61970::Base::Domain::Currency::LSL;
		return lop;
	}
	
	if(EnumSymbol == "LTL")
	{
		rop = IEC61970::Base::Domain::Currency::LTL;
		return lop;
	}
	
	if(EnumSymbol == "LVL")
	{
		rop = IEC61970::Base::Domain::Currency::LVL;
		return lop;
	}
	
	if(EnumSymbol == "LYD")
	{
		rop = IEC61970::Base::Domain::Currency::LYD;
		return lop;
	}
	
	if(EnumSymbol == "MAD")
	{
		rop = IEC61970::Base::Domain::Currency::MAD;
		return lop;
	}
	
	if(EnumSymbol == "MDL")
	{
		rop = IEC61970::Base::Domain::Currency::MDL;
		return lop;
	}
	
	if(EnumSymbol == "MGA")
	{
		rop = IEC61970::Base::Domain::Currency::MGA;
		return lop;
	}
	
	if(EnumSymbol == "MKD")
	{
		rop = IEC61970::Base::Domain::Currency::MKD;
		return lop;
	}
	
	if(EnumSymbol == "MMK")
	{
		rop = IEC61970::Base::Domain::Currency::MMK;
		return lop;
	}
	
	if(EnumSymbol == "MNT")
	{
		rop = IEC61970::Base::Domain::Currency::MNT;
		return lop;
	}
	
	if(EnumSymbol == "MOP")
	{
		rop = IEC61970::Base::Domain::Currency::MOP;
		return lop;
	}
	
	if(EnumSymbol == "MRO")
	{
		rop = IEC61970::Base::Domain::Currency::MRO;
		return lop;
	}
	
	if(EnumSymbol == "MUR")
	{
		rop = IEC61970::Base::Domain::Currency::MUR;
		return lop;
	}
	
	if(EnumSymbol == "MVR")
	{
		rop = IEC61970::Base::Domain::Currency::MVR;
		return lop;
	}
	
	if(EnumSymbol == "MWK")
	{
		rop = IEC61970::Base::Domain::Currency::MWK;
		return lop;
	}
	
	if(EnumSymbol == "MXN")
	{
		rop = IEC61970::Base::Domain::Currency::MXN;
		return lop;
	}
	
	if(EnumSymbol == "MYR")
	{
		rop = IEC61970::Base::Domain::Currency::MYR;
		return lop;
	}
	
	if(EnumSymbol == "MZN")
	{
		rop = IEC61970::Base::Domain::Currency::MZN;
		return lop;
	}
	
	if(EnumSymbol == "NAD")
	{
		rop = IEC61970::Base::Domain::Currency::NAD;
		return lop;
	}
	
	if(EnumSymbol == "NGN")
	{
		rop = IEC61970::Base::Domain::Currency::NGN;
		return lop;
	}
	
	if(EnumSymbol == "NIO")
	{
		rop = IEC61970::Base::Domain::Currency::NIO;
		return lop;
	}
	
	if(EnumSymbol == "NOK")
	{
		rop = IEC61970::Base::Domain::Currency::NOK;
		return lop;
	}
	
	if(EnumSymbol == "NPR")
	{
		rop = IEC61970::Base::Domain::Currency::NPR;
		return lop;
	}
	
	if(EnumSymbol == "NZD")
	{
		rop = IEC61970::Base::Domain::Currency::NZD;
		return lop;
	}
	
	if(EnumSymbol == "OMR")
	{
		rop = IEC61970::Base::Domain::Currency::OMR;
		return lop;
	}
	
	if(EnumSymbol == "PAB")
	{
		rop = IEC61970::Base::Domain::Currency::PAB;
		return lop;
	}
	
	if(EnumSymbol == "PEN")
	{
		rop = IEC61970::Base::Domain::Currency::PEN;
		return lop;
	}
	
	if(EnumSymbol == "PGK")
	{
		rop = IEC61970::Base::Domain::Currency::PGK;
		return lop;
	}
	
	if(EnumSymbol == "PHP")
	{
		rop = IEC61970::Base::Domain::Currency::PHP;
		return lop;
	}
	
	if(EnumSymbol == "PKR")
	{
		rop = IEC61970::Base::Domain::Currency::PKR;
		return lop;
	}
	
	if(EnumSymbol == "PLN")
	{
		rop = IEC61970::Base::Domain::Currency::PLN;
		return lop;
	}
	
	if(EnumSymbol == "PYG")
	{
		rop = IEC61970::Base::Domain::Currency::PYG;
		return lop;
	}
	
	if(EnumSymbol == "QAR")
	{
		rop = IEC61970::Base::Domain::Currency::QAR;
		return lop;
	}
	
	if(EnumSymbol == "RON")
	{
		rop = IEC61970::Base::Domain::Currency::RON;
		return lop;
	}
	
	if(EnumSymbol == "RSD")
	{
		rop = IEC61970::Base::Domain::Currency::RSD;
		return lop;
	}
	
	if(EnumSymbol == "RUB")
	{
		rop = IEC61970::Base::Domain::Currency::RUB;
		return lop;
	}
	
	if(EnumSymbol == "RWF")
	{
		rop = IEC61970::Base::Domain::Currency::RWF;
		return lop;
	}
	
	if(EnumSymbol == "SAR")
	{
		rop = IEC61970::Base::Domain::Currency::SAR;
		return lop;
	}
	
	if(EnumSymbol == "SBD")
	{
		rop = IEC61970::Base::Domain::Currency::SBD;
		return lop;
	}
	
	if(EnumSymbol == "SCR")
	{
		rop = IEC61970::Base::Domain::Currency::SCR;
		return lop;
	}
	
	if(EnumSymbol == "SDG")
	{
		rop = IEC61970::Base::Domain::Currency::SDG;
		return lop;
	}
	
	if(EnumSymbol == "SEK")
	{
		rop = IEC61970::Base::Domain::Currency::SEK;
		return lop;
	}
	
	if(EnumSymbol == "SGD")
	{
		rop = IEC61970::Base::Domain::Currency::SGD;
		return lop;
	}
	
	if(EnumSymbol == "SHP")
	{
		rop = IEC61970::Base::Domain::Currency::SHP;
		return lop;
	}
	
	if(EnumSymbol == "SLL")
	{
		rop = IEC61970::Base::Domain::Currency::SLL;
		return lop;
	}
	
	if(EnumSymbol == "SOS")
	{
		rop = IEC61970::Base::Domain::Currency::SOS;
		return lop;
	}
	
	if(EnumSymbol == "SRD")
	{
		rop = IEC61970::Base::Domain::Currency::SRD;
		return lop;
	}
	
	if(EnumSymbol == "STD")
	{
		rop = IEC61970::Base::Domain::Currency::STD;
		return lop;
	}
	
	if(EnumSymbol == "SYP")
	{
		rop = IEC61970::Base::Domain::Currency::SYP;
		return lop;
	}
	
	if(EnumSymbol == "SZL")
	{
		rop = IEC61970::Base::Domain::Currency::SZL;
		return lop;
	}
	
	if(EnumSymbol == "THB")
	{
		rop = IEC61970::Base::Domain::Currency::THB;
		return lop;
	}
	
	if(EnumSymbol == "TJS")
	{
		rop = IEC61970::Base::Domain::Currency::TJS;
		return lop;
	}
	
	if(EnumSymbol == "TMT")
	{
		rop = IEC61970::Base::Domain::Currency::TMT;
		return lop;
	}
	
	if(EnumSymbol == "TND")
	{
		rop = IEC61970::Base::Domain::Currency::TND;
		return lop;
	}
	
	if(EnumSymbol == "TOP")
	{
		rop = IEC61970::Base::Domain::Currency::TOP;
		return lop;
	}
	
	if(EnumSymbol == "TRY")
	{
		rop = IEC61970::Base::Domain::Currency::TRY;
		return lop;
	}
	
	if(EnumSymbol == "TTD")
	{
		rop = IEC61970::Base::Domain::Currency::TTD;
		return lop;
	}
	
	if(EnumSymbol == "TWD")
	{
		rop = IEC61970::Base::Domain::Currency::TWD;
		return lop;
	}
	
	if(EnumSymbol == "TZS")
	{
		rop = IEC61970::Base::Domain::Currency::TZS;
		return lop;
	}
	
	if(EnumSymbol == "UAH")
	{
		rop = IEC61970::Base::Domain::Currency::UAH;
		return lop;
	}
	
	if(EnumSymbol == "UGX")
	{
		rop = IEC61970::Base::Domain::Currency::UGX;
		return lop;
	}
	
	if(EnumSymbol == "USD")
	{
		rop = IEC61970::Base::Domain::Currency::USD;
		return lop;
	}
	
	if(EnumSymbol == "UYU")
	{
		rop = IEC61970::Base::Domain::Currency::UYU;
		return lop;
	}
	
	if(EnumSymbol == "UZS")
	{
		rop = IEC61970::Base::Domain::Currency::UZS;
		return lop;
	}
	
	if(EnumSymbol == "VEF")
	{
		rop = IEC61970::Base::Domain::Currency::VEF;
		return lop;
	}
	
	if(EnumSymbol == "VND")
	{
		rop = IEC61970::Base::Domain::Currency::VND;
		return lop;
	}
	
	if(EnumSymbol == "VUV")
	{
		rop = IEC61970::Base::Domain::Currency::VUV;
		return lop;
	}
	
	if(EnumSymbol == "WST")
	{
		rop = IEC61970::Base::Domain::Currency::WST;
		return lop;
	}
	
	if(EnumSymbol == "XAF")
	{
		rop = IEC61970::Base::Domain::Currency::XAF;
		return lop;
	}
	
	if(EnumSymbol == "XCD")
	{
		rop = IEC61970::Base::Domain::Currency::XCD;
		return lop;
	}
	
	if(EnumSymbol == "XOF")
	{
		rop = IEC61970::Base::Domain::Currency::XOF;
		return lop;
	}
	
	if(EnumSymbol == "XPF")
	{
		rop = IEC61970::Base::Domain::Currency::XPF;
		return lop;
	}
	
	if(EnumSymbol == "YER")
	{
		rop = IEC61970::Base::Domain::Currency::YER;
		return lop;
	}
	
	if(EnumSymbol == "ZAR")
	{
		rop = IEC61970::Base::Domain::Currency::ZAR;
		return lop;
	}
	
	if(EnumSymbol == "ZMK")
	{
		rop = IEC61970::Base::Domain::Currency::ZMK;
		return lop;
	}
	
	if(EnumSymbol == "ZWL")
	{
		rop = IEC61970::Base::Domain::Currency::ZWL;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}

std::istream& operator>>(std::istream& lop, IEC61970::Base::Core::CurveStyle& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "CurveStyle")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "constantYValue")
	{
		rop = IEC61970::Base::Core::CurveStyle::constantYValue;
		return lop;
	}
	
	if(EnumSymbol == "straightLineYValues")
	{
		rop = IEC61970::Base::Core::CurveStyle::straightLineYValues;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}

std::istream& operator>>(std::istream& lop, IEC61970::Base::Core::BreakerConfiguration& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "BreakerConfiguration")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "singleBreaker")
	{
		rop = IEC61970::Base::Core::BreakerConfiguration::singleBreaker;
		return lop;
	}
	
	if(EnumSymbol == "breakerAndAHalf")
	{
		rop = IEC61970::Base::Core::BreakerConfiguration::breakerAndAHalf;
		return lop;
	}
	
	if(EnumSymbol == "doubleBreaker")
	{
		rop = IEC61970::Base::Core::BreakerConfiguration::doubleBreaker;
		return lop;
	}
	
	if(EnumSymbol == "noBreaker")
	{
		rop = IEC61970::Base::Core::BreakerConfiguration::noBreaker;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}

std::istream& operator>>(std::istream& lop, IEC61970::Base::Core::BusbarConfiguration& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "BusbarConfiguration")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "singleBus")
	{
		rop = IEC61970::Base::Core::BusbarConfiguration::singleBus;
		return lop;
	}
	
	if(EnumSymbol == "doubleBus")
	{
		rop = IEC61970::Base::Core::BusbarConfiguration::doubleBus;
		return lop;
	}
	
	if(EnumSymbol == "mainWithTransfer")
	{
		rop = IEC61970::Base::Core::BusbarConfiguration::mainWithTransfer;
		return lop;
	}
	
	if(EnumSymbol == "ringBus")
	{
		rop = IEC61970::Base::Core::BusbarConfiguration::ringBus;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}

std::istream& operator>>(std::istream& lop, IEC61970::Base::DC::DCConverterOperatingModeKind& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "DCConverterOperatingModeKind")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "bipolar")
	{
		rop = IEC61970::Base::DC::DCConverterOperatingModeKind::bipolar;
		return lop;
	}
	
	if(EnumSymbol == "monopolarMetallicReturn")
	{
		rop = IEC61970::Base::DC::DCConverterOperatingModeKind::monopolarMetallicReturn;
		return lop;
	}
	
	if(EnumSymbol == "monopolarGroundReturn")
	{
		rop = IEC61970::Base::DC::DCConverterOperatingModeKind::monopolarGroundReturn;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}

std::istream& operator>>(std::istream& lop, IEC61970::Base::DC::DCPolarityKind& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "DCPolarityKind")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "positive")
	{
		rop = IEC61970::Base::DC::DCPolarityKind::positive;
		return lop;
	}
	
	if(EnumSymbol == "middle")
	{
		rop = IEC61970::Base::DC::DCPolarityKind::middle;
		return lop;
	}
	
	if(EnumSymbol == "negative")
	{
		rop = IEC61970::Base::DC::DCPolarityKind::negative;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}

std::istream& operator>>(std::istream& lop, IEC61970::Base::DC::CsOperatingModeKind& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "CsOperatingModeKind")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "inverter")
	{
		rop = IEC61970::Base::DC::CsOperatingModeKind::inverter;
		return lop;
	}
	
	if(EnumSymbol == "rectifier")
	{
		rop = IEC61970::Base::DC::CsOperatingModeKind::rectifier;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}

std::istream& operator>>(std::istream& lop, IEC61970::Base::DC::CsPpccControlKind& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "CsPpccControlKind")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "activePower")
	{
		rop = IEC61970::Base::DC::CsPpccControlKind::activePower;
		return lop;
	}
	
	if(EnumSymbol == "dcVoltage")
	{
		rop = IEC61970::Base::DC::CsPpccControlKind::dcVoltage;
		return lop;
	}
	
	if(EnumSymbol == "dcCurrent")
	{
		rop = IEC61970::Base::DC::CsPpccControlKind::dcCurrent;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}

std::istream& operator>>(std::istream& lop, IEC61970::Base::DC::VsPpccControlKind& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "VsPpccControlKind")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "pPcc")
	{
		rop = IEC61970::Base::DC::VsPpccControlKind::pPcc;
		return lop;
	}
	
	if(EnumSymbol == "udc")
	{
		rop = IEC61970::Base::DC::VsPpccControlKind::udc;
		return lop;
	}
	
	if(EnumSymbol == "pPccAndUdcDroop")
	{
		rop = IEC61970::Base::DC::VsPpccControlKind::pPccAndUdcDroop;
		return lop;
	}
	
	if(EnumSymbol == "pPccAndUdcDroopWithCompensation")
	{
		rop = IEC61970::Base::DC::VsPpccControlKind::pPccAndUdcDroopWithCompensation;
		return lop;
	}
	
	if(EnumSymbol == "pPccAndUdcDroopPilot")
	{
		rop = IEC61970::Base::DC::VsPpccControlKind::pPccAndUdcDroopPilot;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}

std::istream& operator>>(std::istream& lop, IEC61970::Base::DC::VsQpccControlKind& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "VsQpccControlKind")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "reactivePcc")
	{
		rop = IEC61970::Base::DC::VsQpccControlKind::reactivePcc;
		return lop;
	}
	
	if(EnumSymbol == "voltagePcc")
	{
		rop = IEC61970::Base::DC::VsQpccControlKind::voltagePcc;
		return lop;
	}
	
	if(EnumSymbol == "powerFactorPcc")
	{
		rop = IEC61970::Base::DC::VsQpccControlKind::powerFactorPcc;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}

std::istream& operator>>(std::istream& lop, IEC61970::Base::DiagramLayout::OrientationKind& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "OrientationKind")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "positive")
	{
		rop = IEC61970::Base::DiagramLayout::OrientationKind::positive;
		return lop;
	}
	
	if(EnumSymbol == "negative")
	{
		rop = IEC61970::Base::DiagramLayout::OrientationKind::negative;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}

std::istream& operator>>(std::istream& lop, IEC61970::Base::Faults::PhaseConnectedFaultKind& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "PhaseConnectedFaultKind")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "lineToGround")
	{
		rop = IEC61970::Base::Faults::PhaseConnectedFaultKind::lineToGround;
		return lop;
	}
	
	if(EnumSymbol == "lineToLine")
	{
		rop = IEC61970::Base::Faults::PhaseConnectedFaultKind::lineToLine;
		return lop;
	}
	
	if(EnumSymbol == "lineToLineToGround")
	{
		rop = IEC61970::Base::Faults::PhaseConnectedFaultKind::lineToLineToGround;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}

std::istream& operator>>(std::istream& lop, IEC61970::Base::Generation::GenerationTrainingSimulation::BoilerControlMode& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "BoilerControlMode")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "following")
	{
		rop = IEC61970::Base::Generation::GenerationTrainingSimulation::BoilerControlMode::following;
		return lop;
	}
	
	if(EnumSymbol == "coordinated")
	{
		rop = IEC61970::Base::Generation::GenerationTrainingSimulation::BoilerControlMode::coordinated;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}

std::istream& operator>>(std::istream& lop, IEC61970::Base::Wires::CoolantType& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "CoolantType")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "air")
	{
		rop = IEC61970::Base::Wires::CoolantType::air;
		return lop;
	}
	
	if(EnumSymbol == "hydrogenGas")
	{
		rop = IEC61970::Base::Wires::CoolantType::hydrogenGas;
		return lop;
	}
	
	if(EnumSymbol == "water")
	{
		rop = IEC61970::Base::Wires::CoolantType::water;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}

std::istream& operator>>(std::istream& lop, IEC61970::Base::Wires::SynchronousMachineOperatingMode& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "SynchronousMachineOperatingMode")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "generator")
	{
		rop = IEC61970::Base::Wires::SynchronousMachineOperatingMode::generator;
		return lop;
	}
	
	if(EnumSymbol == "condenser")
	{
		rop = IEC61970::Base::Wires::SynchronousMachineOperatingMode::condenser;
		return lop;
	}
	
	if(EnumSymbol == "motor")
	{
		rop = IEC61970::Base::Wires::SynchronousMachineOperatingMode::motor;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}

std::istream& operator>>(std::istream& lop, IEC61970::Base::Wires::ShortCircuitRotorKind& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "ShortCircuitRotorKind")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "salientPole1")
	{
		rop = IEC61970::Base::Wires::ShortCircuitRotorKind::salientPole1;
		return lop;
	}
	
	if(EnumSymbol == "salientPole2")
	{
		rop = IEC61970::Base::Wires::ShortCircuitRotorKind::salientPole2;
		return lop;
	}
	
	if(EnumSymbol == "turboSeries1")
	{
		rop = IEC61970::Base::Wires::ShortCircuitRotorKind::turboSeries1;
		return lop;
	}
	
	if(EnumSymbol == "turboSeries2")
	{
		rop = IEC61970::Base::Wires::ShortCircuitRotorKind::turboSeries2;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}

std::istream& operator>>(std::istream& lop, IEC61970::Base::Wires::SynchronousMachineKind& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "SynchronousMachineKind")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "generator")
	{
		rop = IEC61970::Base::Wires::SynchronousMachineKind::generator;
		return lop;
	}
	
	if(EnumSymbol == "condenser")
	{
		rop = IEC61970::Base::Wires::SynchronousMachineKind::condenser;
		return lop;
	}
	
	if(EnumSymbol == "generatorOrCondenser")
	{
		rop = IEC61970::Base::Wires::SynchronousMachineKind::generatorOrCondenser;
		return lop;
	}
	
	if(EnumSymbol == "motor")
	{
		rop = IEC61970::Base::Wires::SynchronousMachineKind::motor;
		return lop;
	}
	
	if(EnumSymbol == "generatorOrMotor")
	{
		rop = IEC61970::Base::Wires::SynchronousMachineKind::generatorOrMotor;
		return lop;
	}
	
	if(EnumSymbol == "motorOrCondenser")
	{
		rop = IEC61970::Base::Wires::SynchronousMachineKind::motorOrCondenser;
		return lop;
	}
	
	if(EnumSymbol == "generatorOrCondenserOrMotor")
	{
		rop = IEC61970::Base::Wires::SynchronousMachineKind::generatorOrCondenserOrMotor;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}

std::istream& operator>>(std::istream& lop, IEC61970::Base::Generation::GenerationTrainingSimulation::TurbineType& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "TurbineType")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "francis")
	{
		rop = IEC61970::Base::Generation::GenerationTrainingSimulation::TurbineType::francis;
		return lop;
	}
	
	if(EnumSymbol == "pelton")
	{
		rop = IEC61970::Base::Generation::GenerationTrainingSimulation::TurbineType::pelton;
		return lop;
	}
	
	if(EnumSymbol == "kaplan")
	{
		rop = IEC61970::Base::Generation::GenerationTrainingSimulation::TurbineType::kaplan;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}

std::istream& operator>>(std::istream& lop, IEC61970::Base::Generation::Production::FuelType& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "FuelType")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "coal")
	{
		rop = IEC61970::Base::Generation::Production::FuelType::coal;
		return lop;
	}
	
	if(EnumSymbol == "oil")
	{
		rop = IEC61970::Base::Generation::Production::FuelType::oil;
		return lop;
	}
	
	if(EnumSymbol == "gas")
	{
		rop = IEC61970::Base::Generation::Production::FuelType::gas;
		return lop;
	}
	
	if(EnumSymbol == "lignite")
	{
		rop = IEC61970::Base::Generation::Production::FuelType::lignite;
		return lop;
	}
	
	if(EnumSymbol == "hardCoal")
	{
		rop = IEC61970::Base::Generation::Production::FuelType::hardCoal;
		return lop;
	}
	
	if(EnumSymbol == "oilShale")
	{
		rop = IEC61970::Base::Generation::Production::FuelType::oilShale;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}

std::istream& operator>>(std::istream& lop, IEC61970::Base::Generation::Production::EmissionType& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "EmissionType")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "sulfurDioxide")
	{
		rop = IEC61970::Base::Generation::Production::EmissionType::sulfurDioxide;
		return lop;
	}
	
	if(EnumSymbol == "carbonDioxide")
	{
		rop = IEC61970::Base::Generation::Production::EmissionType::carbonDioxide;
		return lop;
	}
	
	if(EnumSymbol == "nitrogenOxide")
	{
		rop = IEC61970::Base::Generation::Production::EmissionType::nitrogenOxide;
		return lop;
	}
	
	if(EnumSymbol == "hydrogenSulfide")
	{
		rop = IEC61970::Base::Generation::Production::EmissionType::hydrogenSulfide;
		return lop;
	}
	
	if(EnumSymbol == "chlorine")
	{
		rop = IEC61970::Base::Generation::Production::EmissionType::chlorine;
		return lop;
	}
	
	if(EnumSymbol == "carbonDisulfide")
	{
		rop = IEC61970::Base::Generation::Production::EmissionType::carbonDisulfide;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}

std::istream& operator>>(std::istream& lop, IEC61970::Base::Generation::Production::EmissionValueSource& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "EmissionValueSource")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "measured")
	{
		rop = IEC61970::Base::Generation::Production::EmissionValueSource::measured;
		return lop;
	}
	
	if(EnumSymbol == "calculated")
	{
		rop = IEC61970::Base::Generation::Production::EmissionValueSource::calculated;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}

std::istream& operator>>(std::istream& lop, IEC61970::Base::Generation::Production::HydroEnergyConversionKind& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "HydroEnergyConversionKind")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "generator")
	{
		rop = IEC61970::Base::Generation::Production::HydroEnergyConversionKind::generator;
		return lop;
	}
	
	if(EnumSymbol == "pumpAndGenerator")
	{
		rop = IEC61970::Base::Generation::Production::HydroEnergyConversionKind::pumpAndGenerator;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}

std::istream& operator>>(std::istream& lop, IEC61970::Base::Generation::Production::HydroPlantStorageKind& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "HydroPlantStorageKind")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "runOfRiver")
	{
		rop = IEC61970::Base::Generation::Production::HydroPlantStorageKind::runOfRiver;
		return lop;
	}
	
	if(EnumSymbol == "pumpedStorage")
	{
		rop = IEC61970::Base::Generation::Production::HydroPlantStorageKind::pumpedStorage;
		return lop;
	}
	
	if(EnumSymbol == "storage")
	{
		rop = IEC61970::Base::Generation::Production::HydroPlantStorageKind::storage;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}

std::istream& operator>>(std::istream& lop, IEC61970::Base::Generation::Production::WindGenUnitKind& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "WindGenUnitKind")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "offshore")
	{
		rop = IEC61970::Base::Generation::Production::WindGenUnitKind::offshore;
		return lop;
	}
	
	if(EnumSymbol == "onshore")
	{
		rop = IEC61970::Base::Generation::Production::WindGenUnitKind::onshore;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}

std::istream& operator>>(std::istream& lop, IEC61970::Base::Wires::PhaseShuntConnectionKind& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "PhaseShuntConnectionKind")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "D")
	{
		rop = IEC61970::Base::Wires::PhaseShuntConnectionKind::D;
		return lop;
	}
	
	if(EnumSymbol == "Y")
	{
		rop = IEC61970::Base::Wires::PhaseShuntConnectionKind::Y;
		return lop;
	}
	
	if(EnumSymbol == "Yn")
	{
		rop = IEC61970::Base::Wires::PhaseShuntConnectionKind::Yn;
		return lop;
	}
	
	if(EnumSymbol == "I")
	{
		rop = IEC61970::Base::Wires::PhaseShuntConnectionKind::I;
		return lop;
	}
	
	if(EnumSymbol == "G")
	{
		rop = IEC61970::Base::Wires::PhaseShuntConnectionKind::G;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}

std::istream& operator>>(std::istream& lop, IEC61970::Base::Wires::SinglePhaseKind& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "SinglePhaseKind")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "A")
	{
		rop = IEC61970::Base::Wires::SinglePhaseKind::A;
		return lop;
	}
	
	if(EnumSymbol == "B")
	{
		rop = IEC61970::Base::Wires::SinglePhaseKind::B;
		return lop;
	}
	
	if(EnumSymbol == "C")
	{
		rop = IEC61970::Base::Wires::SinglePhaseKind::C;
		return lop;
	}
	
	if(EnumSymbol == "N")
	{
		rop = IEC61970::Base::Wires::SinglePhaseKind::N;
		return lop;
	}
	
	if(EnumSymbol == "s1")
	{
		rop = IEC61970::Base::Wires::SinglePhaseKind::s1;
		return lop;
	}
	
	if(EnumSymbol == "s2")
	{
		rop = IEC61970::Base::Wires::SinglePhaseKind::s2;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}

std::istream& operator>>(std::istream& lop, IEC61970::Base::OperationalLimits::OperationalLimitDirectionKind& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "OperationalLimitDirectionKind")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "high")
	{
		rop = IEC61970::Base::OperationalLimits::OperationalLimitDirectionKind::high;
		return lop;
	}
	
	if(EnumSymbol == "low")
	{
		rop = IEC61970::Base::OperationalLimits::OperationalLimitDirectionKind::low;
		return lop;
	}
	
	if(EnumSymbol == "absoluteValue")
	{
		rop = IEC61970::Base::OperationalLimits::OperationalLimitDirectionKind::absoluteValue;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}

std::istream& operator>>(std::istream& lop, IEC61970::Base::SCADA::RemoteUnitType& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "RemoteUnitType")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "RTU")
	{
		rop = IEC61970::Base::SCADA::RemoteUnitType::RTU;
		return lop;
	}
	
	if(EnumSymbol == "SubstationControlSystem")
	{
		rop = IEC61970::Base::SCADA::RemoteUnitType::SubstationControlSystem;
		return lop;
	}
	
	if(EnumSymbol == "ControlCenter")
	{
		rop = IEC61970::Base::SCADA::RemoteUnitType::ControlCenter;
		return lop;
	}
	
	if(EnumSymbol == "IED")
	{
		rop = IEC61970::Base::SCADA::RemoteUnitType::IED;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}

std::istream& operator>>(std::istream& lop, IEC61970::Base::Wires::AsynchronousMachineKind& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "AsynchronousMachineKind")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "generator")
	{
		rop = IEC61970::Base::Wires::AsynchronousMachineKind::generator;
		return lop;
	}
	
	if(EnumSymbol == "motor")
	{
		rop = IEC61970::Base::Wires::AsynchronousMachineKind::motor;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}

std::istream& operator>>(std::istream& lop, IEC61970::Base::Wires::PetersenCoilModeKind& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "PetersenCoilModeKind")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "fixed")
	{
		rop = IEC61970::Base::Wires::PetersenCoilModeKind::fixed;
		return lop;
	}
	
	if(EnumSymbol == "manual")
	{
		rop = IEC61970::Base::Wires::PetersenCoilModeKind::manual;
		return lop;
	}
	
	if(EnumSymbol == "automaticPositioning")
	{
		rop = IEC61970::Base::Wires::PetersenCoilModeKind::automaticPositioning;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}

std::istream& operator>>(std::istream& lop, IEC61970::Base::Wires::WindingConnection& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "WindingConnection")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "D")
	{
		rop = IEC61970::Base::Wires::WindingConnection::D;
		return lop;
	}
	
	if(EnumSymbol == "Y")
	{
		rop = IEC61970::Base::Wires::WindingConnection::Y;
		return lop;
	}
	
	if(EnumSymbol == "Z")
	{
		rop = IEC61970::Base::Wires::WindingConnection::Z;
		return lop;
	}
	
	if(EnumSymbol == "Yn")
	{
		rop = IEC61970::Base::Wires::WindingConnection::Yn;
		return lop;
	}
	
	if(EnumSymbol == "Zn")
	{
		rop = IEC61970::Base::Wires::WindingConnection::Zn;
		return lop;
	}
	
	if(EnumSymbol == "A")
	{
		rop = IEC61970::Base::Wires::WindingConnection::A;
		return lop;
	}
	
	if(EnumSymbol == "I")
	{
		rop = IEC61970::Base::Wires::WindingConnection::I;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}

std::istream& operator>>(std::istream& lop, IEC61970::Base::Wires::TransformerControlMode& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "TransformerControlMode")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "volt")
	{
		rop = IEC61970::Base::Wires::TransformerControlMode::volt;
		return lop;
	}
	
	if(EnumSymbol == "reactive")
	{
		rop = IEC61970::Base::Wires::TransformerControlMode::reactive;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}

std::istream& operator>>(std::istream& lop, IEC61970::Base::Wires::SVCControlMode& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "SVCControlMode")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "reactivePower")
	{
		rop = IEC61970::Base::Wires::SVCControlMode::reactivePower;
		return lop;
	}
	
	if(EnumSymbol == "voltage")
	{
		rop = IEC61970::Base::Wires::SVCControlMode::voltage;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}

std::istream& operator>>(std::istream& lop, IEC61970::Dynamics::StandardInterconnections::RemoteSignalKind& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "RemoteSignalKind")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "remoteBusVoltageFrequency")
	{
		rop = IEC61970::Dynamics::StandardInterconnections::RemoteSignalKind::remoteBusVoltageFrequency;
		return lop;
	}
	
	if(EnumSymbol == "remoteBusVoltageFrequencyDeviation")
	{
		rop = IEC61970::Dynamics::StandardInterconnections::RemoteSignalKind::remoteBusVoltageFrequencyDeviation;
		return lop;
	}
	
	if(EnumSymbol == "remoteBusFrequency")
	{
		rop = IEC61970::Dynamics::StandardInterconnections::RemoteSignalKind::remoteBusFrequency;
		return lop;
	}
	
	if(EnumSymbol == "remoteBusFrequencyDeviation")
	{
		rop = IEC61970::Dynamics::StandardInterconnections::RemoteSignalKind::remoteBusFrequencyDeviation;
		return lop;
	}
	
	if(EnumSymbol == "remoteBusVoltageAmplitude")
	{
		rop = IEC61970::Dynamics::StandardInterconnections::RemoteSignalKind::remoteBusVoltageAmplitude;
		return lop;
	}
	
	if(EnumSymbol == "remoteBusVoltage")
	{
		rop = IEC61970::Dynamics::StandardInterconnections::RemoteSignalKind::remoteBusVoltage;
		return lop;
	}
	
	if(EnumSymbol == "remoteBranchCurrentAmplitude")
	{
		rop = IEC61970::Dynamics::StandardInterconnections::RemoteSignalKind::remoteBranchCurrentAmplitude;
		return lop;
	}
	
	if(EnumSymbol == "remoteBusVoltageAmplitudeDerivative")
	{
		rop = IEC61970::Dynamics::StandardInterconnections::RemoteSignalKind::remoteBusVoltageAmplitudeDerivative;
		return lop;
	}
	
	if(EnumSymbol == "remotePuBusVoltageDerivative")
	{
		rop = IEC61970::Dynamics::StandardInterconnections::RemoteSignalKind::remotePuBusVoltageDerivative;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}

std::istream& operator>>(std::istream& lop, IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST1AUELselectorKind& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "ExcIEEEST1AUELselectorKind")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "ignoreUELsignal")
	{
		rop = IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST1AUELselectorKind::ignoreUELsignal;
		return lop;
	}
	
	if(EnumSymbol == "inputHVgateVoltageOutput")
	{
		rop = IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST1AUELselectorKind::inputHVgateVoltageOutput;
		return lop;
	}
	
	if(EnumSymbol == "inputHVgateErrorSignal")
	{
		rop = IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST1AUELselectorKind::inputHVgateErrorSignal;
		return lop;
	}
	
	if(EnumSymbol == "inputAddedToErrorSignal")
	{
		rop = IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST1AUELselectorKind::inputAddedToErrorSignal;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}

std::istream& operator>>(std::istream& lop, IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST6BOELselectorKind& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "ExcST6BOELselectorKind")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "noOELinput")
	{
		rop = IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST6BOELselectorKind::noOELinput;
		return lop;
	}
	
	if(EnumSymbol == "beforeUEL")
	{
		rop = IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST6BOELselectorKind::beforeUEL;
		return lop;
	}
	
	if(EnumSymbol == "afterUEL")
	{
		rop = IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST6BOELselectorKind::afterUEL;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}

std::istream& operator>>(std::istream& lop, IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST7BOELselectorKind& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "ExcST7BOELselectorKind")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "noOELinput")
	{
		rop = IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST7BOELselectorKind::noOELinput;
		return lop;
	}
	
	if(EnumSymbol == "addVref")
	{
		rop = IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST7BOELselectorKind::addVref;
		return lop;
	}
	
	if(EnumSymbol == "inputLVgate")
	{
		rop = IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST7BOELselectorKind::inputLVgate;
		return lop;
	}
	
	if(EnumSymbol == "outputLVgate")
	{
		rop = IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST7BOELselectorKind::outputLVgate;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}

std::istream& operator>>(std::istream& lop, IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST7BUELselectorKind& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "ExcST7BUELselectorKind")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "noUELinput")
	{
		rop = IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST7BUELselectorKind::noUELinput;
		return lop;
	}
	
	if(EnumSymbol == "addVref")
	{
		rop = IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST7BUELselectorKind::addVref;
		return lop;
	}
	
	if(EnumSymbol == "inputHVgate")
	{
		rop = IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST7BUELselectorKind::inputHVgate;
		return lop;
	}
	
	if(EnumSymbol == "outputHVgate")
	{
		rop = IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST7BUELselectorKind::outputHVgate;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}

std::istream& operator>>(std::istream& lop, IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXSFeedbackSignalKind& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "ExcREXSFeedbackSignalKind")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "fieldVoltage")
	{
		rop = IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXSFeedbackSignalKind::fieldVoltage;
		return lop;
	}
	
	if(EnumSymbol == "fieldCurrent")
	{
		rop = IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXSFeedbackSignalKind::fieldCurrent;
		return lop;
	}
	
	if(EnumSymbol == "outputVoltage")
	{
		rop = IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXSFeedbackSignalKind::outputVoltage;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}

std::istream& operator>>(std::istream& lop, IEC61970::Dynamics::StandardModels::LoadDynamics::GenericNonLinearLoadModelKind& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "GenericNonLinearLoadModelKind")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "exponentialRecovery")
	{
		rop = IEC61970::Dynamics::StandardModels::LoadDynamics::GenericNonLinearLoadModelKind::exponentialRecovery;
		return lop;
	}
	
	if(EnumSymbol == "loadAdaptive")
	{
		rop = IEC61970::Dynamics::StandardModels::LoadDynamics::GenericNonLinearLoadModelKind::loadAdaptive;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}

std::istream& operator>>(std::istream& lop, IEC61970::Dynamics::StandardModels::LoadDynamics::StaticLoadModelKind& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "StaticLoadModelKind")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "exponential")
	{
		rop = IEC61970::Dynamics::StandardModels::LoadDynamics::StaticLoadModelKind::exponential;
		return lop;
	}
	
	if(EnumSymbol == "zIP1")
	{
		rop = IEC61970::Dynamics::StandardModels::LoadDynamics::StaticLoadModelKind::zIP1;
		return lop;
	}
	
	if(EnumSymbol == "zIP2")
	{
		rop = IEC61970::Dynamics::StandardModels::LoadDynamics::StaticLoadModelKind::zIP2;
		return lop;
	}
	
	if(EnumSymbol == "constantZ")
	{
		rop = IEC61970::Dynamics::StandardModels::LoadDynamics::StaticLoadModelKind::constantZ;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}

std::istream& operator>>(std::istream& lop, IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::InputSignalKind& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "InputSignalKind")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "rotorSpeed")
	{
		rop = IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::InputSignalKind::rotorSpeed;
		return lop;
	}
	
	if(EnumSymbol == "rotorAngularFrequencyDeviation")
	{
		rop = IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::InputSignalKind::rotorAngularFrequencyDeviation;
		return lop;
	}
	
	if(EnumSymbol == "busFrequency")
	{
		rop = IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::InputSignalKind::busFrequency;
		return lop;
	}
	
	if(EnumSymbol == "busFrequencyDeviation")
	{
		rop = IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::InputSignalKind::busFrequencyDeviation;
		return lop;
	}
	
	if(EnumSymbol == "generatorElectricalPower")
	{
		rop = IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::InputSignalKind::generatorElectricalPower;
		return lop;
	}
	
	if(EnumSymbol == "generatorAcceleratingPower")
	{
		rop = IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::InputSignalKind::generatorAcceleratingPower;
		return lop;
	}
	
	if(EnumSymbol == "busVoltage")
	{
		rop = IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::InputSignalKind::busVoltage;
		return lop;
	}
	
	if(EnumSymbol == "busVoltageDerivative")
	{
		rop = IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::InputSignalKind::busVoltageDerivative;
		return lop;
	}
	
	if(EnumSymbol == "branchCurrent")
	{
		rop = IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::InputSignalKind::branchCurrent;
		return lop;
	}
	
	if(EnumSymbol == "fieldCurrent")
	{
		rop = IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::InputSignalKind::fieldCurrent;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}

std::istream& operator>>(std::istream& lop, IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::IfdBaseKind& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "IfdBaseKind")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "ifag")
	{
		rop = IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::IfdBaseKind::ifag;
		return lop;
	}
	
	if(EnumSymbol == "ifnl")
	{
		rop = IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::IfdBaseKind::ifnl;
		return lop;
	}
	
	if(EnumSymbol == "iffl")
	{
		rop = IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::IfdBaseKind::iffl;
		return lop;
	}
	
	if(EnumSymbol == "other")
	{
		rop = IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::IfdBaseKind::other;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}

std::istream& operator>>(std::istream& lop, IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::RotorKind& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "RotorKind")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "roundRotor")
	{
		rop = IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::RotorKind::roundRotor;
		return lop;
	}
	
	if(EnumSymbol == "salientPole")
	{
		rop = IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::RotorKind::salientPole;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}

std::istream& operator>>(std::istream& lop, IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineModelKind& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "SynchronousMachineModelKind")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "subtransient")
	{
		rop = IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineModelKind::subtransient;
		return lop;
	}
	
	if(EnumSymbol == "subtransientTypeF")
	{
		rop = IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineModelKind::subtransientTypeF;
		return lop;
	}
	
	if(EnumSymbol == "subtransientTypeJ")
	{
		rop = IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineModelKind::subtransientTypeJ;
		return lop;
	}
	
	if(EnumSymbol == "subtransientSimplified")
	{
		rop = IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineModelKind::subtransientSimplified;
		return lop;
	}
	
	if(EnumSymbol == "subtransientSimplifiedDirectAxis")
	{
		rop = IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineModelKind::subtransientSimplifiedDirectAxis;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}

std::istream& operator>>(std::istream& lop, IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::DroopSignalFeedbackKind& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "DroopSignalFeedbackKind")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "electricalPower")
	{
		rop = IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::DroopSignalFeedbackKind::electricalPower;
		return lop;
	}
	
	if(EnumSymbol == "none")
	{
		rop = IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::DroopSignalFeedbackKind::none;
		return lop;
	}
	
	if(EnumSymbol == "fuelValveStroke")
	{
		rop = IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::DroopSignalFeedbackKind::fuelValveStroke;
		return lop;
	}
	
	if(EnumSymbol == "governorOutput")
	{
		rop = IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::DroopSignalFeedbackKind::governorOutput;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}

std::istream& operator>>(std::istream& lop, IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::FrancisGovernorControlKind& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "FrancisGovernorControlKind")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "mechanicHydrolicTachoAccelerator")
	{
		rop = IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::FrancisGovernorControlKind::mechanicHydrolicTachoAccelerator;
		return lop;
	}
	
	if(EnumSymbol == "mechanicHydraulicTransientFeedback")
	{
		rop = IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::FrancisGovernorControlKind::mechanicHydraulicTransientFeedback;
		return lop;
	}
	
	if(EnumSymbol == "electromechanicalElectrohydraulic")
	{
		rop = IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::FrancisGovernorControlKind::electromechanicalElectrohydraulic;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}

std::istream& operator>>(std::istream& lop, IEC61970::Dynamics::StandardModels::WindDynamics::WindLVRTQcontrolModesKind& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "WindLVRTQcontrolModesKind")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "mode1")
	{
		rop = IEC61970::Dynamics::StandardModels::WindDynamics::WindLVRTQcontrolModesKind::mode1;
		return lop;
	}
	
	if(EnumSymbol == "mode2")
	{
		rop = IEC61970::Dynamics::StandardModels::WindDynamics::WindLVRTQcontrolModesKind::mode2;
		return lop;
	}
	
	if(EnumSymbol == "mode3")
	{
		rop = IEC61970::Dynamics::StandardModels::WindDynamics::WindLVRTQcontrolModesKind::mode3;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}

std::istream& operator>>(std::istream& lop, IEC61970::Dynamics::StandardModels::WindDynamics::WindQcontrolModesKind& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "WindQcontrolModesKind")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "voltage")
	{
		rop = IEC61970::Dynamics::StandardModels::WindDynamics::WindQcontrolModesKind::voltage;
		return lop;
	}
	
	if(EnumSymbol == "reactivePower")
	{
		rop = IEC61970::Dynamics::StandardModels::WindDynamics::WindQcontrolModesKind::reactivePower;
		return lop;
	}
	
	if(EnumSymbol == "openLoopReactivePower")
	{
		rop = IEC61970::Dynamics::StandardModels::WindDynamics::WindQcontrolModesKind::openLoopReactivePower;
		return lop;
	}
	
	if(EnumSymbol == "powerFactor")
	{
		rop = IEC61970::Dynamics::StandardModels::WindDynamics::WindQcontrolModesKind::powerFactor;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}

std::istream& operator>>(std::istream& lop, IEC61970::Dynamics::StandardModels::WindDynamics::WindLookupTableFunctionKind& rop)
{
	std::string EnumSymbol;
	lop >> EnumSymbol;
	size_t pos = EnumSymbol.find_first_of('.');
	if(EnumSymbol.substr(0, pos) != "WindLookupTableFunctionKind")
	{
		lop.setstate(std::ios::failbit);
		return lop;
	}

	EnumSymbol = EnumSymbol.substr(pos + 1);
	
	if(EnumSymbol == "fpslip")
	{
		rop = IEC61970::Dynamics::StandardModels::WindDynamics::WindLookupTableFunctionKind::fpslip;
		return lop;
	}
	
	if(EnumSymbol == "fpomega")
	{
		rop = IEC61970::Dynamics::StandardModels::WindDynamics::WindLookupTableFunctionKind::fpomega;
		return lop;
	}
	
	if(EnumSymbol == "ipvdl")
	{
		rop = IEC61970::Dynamics::StandardModels::WindDynamics::WindLookupTableFunctionKind::ipvdl;
		return lop;
	}
	
	if(EnumSymbol == "iqvdl")
	{
		rop = IEC61970::Dynamics::StandardModels::WindDynamics::WindLookupTableFunctionKind::iqvdl;
		return lop;
	}
	
	if(EnumSymbol == "fdpf")
	{
		rop = IEC61970::Dynamics::StandardModels::WindDynamics::WindLookupTableFunctionKind::fdpf;
		return lop;
	}
	
	lop.setstate(std::ios::failbit);
	return lop;
}



// cim:IdentifiedObject.aliasName
bool assign_IdentifiedObject_aliasName(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Core::IdentifiedObject* element = dynamic_cast<IEC61970::Base::Core::IdentifiedObject*>(base_class_ptr))
	{
		element->aliasName = buffer.str();
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:IdentifiedObject.description
bool assign_IdentifiedObject_description(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Core::IdentifiedObject* element = dynamic_cast<IEC61970::Base::Core::IdentifiedObject*>(base_class_ptr))
	{
		element->description = buffer.str();
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:IdentifiedObject.mRID
bool assign_IdentifiedObject_mRID(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Core::IdentifiedObject* element = dynamic_cast<IEC61970::Base::Core::IdentifiedObject*>(base_class_ptr))
	{
		element->mRID = buffer.str();
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:IdentifiedObject.name
bool assign_IdentifiedObject_name(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Core::IdentifiedObject* element = dynamic_cast<IEC61970::Base::Core::IdentifiedObject*>(base_class_ptr))
	{
		element->name = buffer.str();
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Control.controlType
bool assign_Control_controlType(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Meas::Control* element = dynamic_cast<IEC61970::Base::Meas::Control*>(base_class_ptr))
	{
		element->controlType = buffer.str();
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Control.operationInProgress
bool assign_Control_operationInProgress(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Meas::Control* element = dynamic_cast<IEC61970::Base::Meas::Control*>(base_class_ptr))
	{
		buffer >> element->operationInProgress;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Control.timeStamp
bool assign_Control_timeStamp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Meas::Control* element = dynamic_cast<IEC61970::Base::Meas::Control*>(base_class_ptr))
	{
		element->timeStamp.value = buffer.str();
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Control.unitMultiplier
bool assign_Control_unitMultiplier(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Meas::Control* element = dynamic_cast<IEC61970::Base::Meas::Control*>(base_class_ptr))
	{
		buffer >> element->unitMultiplier;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Control.unitSymbol
bool assign_Control_unitSymbol(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Meas::Control* element = dynamic_cast<IEC61970::Base::Meas::Control*>(base_class_ptr))
	{
		buffer >> element->unitSymbol;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ACDCTerminal.connected
bool assign_ACDCTerminal_connected(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Core::ACDCTerminal* element = dynamic_cast<IEC61970::Base::Core::ACDCTerminal*>(base_class_ptr))
	{
		buffer >> element->connected;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ACDCTerminal.sequenceNumber
bool assign_ACDCTerminal_sequenceNumber(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Core::ACDCTerminal* element = dynamic_cast<IEC61970::Base::Core::ACDCTerminal*>(base_class_ptr))
	{
		buffer >> element->sequenceNumber;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Measurement.measurementType
bool assign_Measurement_measurementType(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Meas::Measurement* element = dynamic_cast<IEC61970::Base::Meas::Measurement*>(base_class_ptr))
	{
		element->measurementType = buffer.str();
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Measurement.phases
bool assign_Measurement_phases(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Meas::Measurement* element = dynamic_cast<IEC61970::Base::Meas::Measurement*>(base_class_ptr))
	{
		buffer >> element->phases;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Measurement.unitMultiplier
bool assign_Measurement_unitMultiplier(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Meas::Measurement* element = dynamic_cast<IEC61970::Base::Meas::Measurement*>(base_class_ptr))
	{
		buffer >> element->unitMultiplier;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Measurement.unitSymbol
bool assign_Measurement_unitSymbol(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Meas::Measurement* element = dynamic_cast<IEC61970::Base::Meas::Measurement*>(base_class_ptr))
	{
		buffer >> element->unitSymbol;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Equipment.aggregate
bool assign_Equipment_aggregate(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Core::Equipment* element = dynamic_cast<IEC61970::Base::Core::Equipment*>(base_class_ptr))
	{
		buffer >> element->aggregate;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Equipment.inService
bool assign_Equipment_inService(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Core::Equipment* element = dynamic_cast<IEC61970::Base::Core::Equipment*>(base_class_ptr))
	{
		buffer >> element->inService;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Equipment.normallyInService
bool assign_Equipment_normallyInService(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Core::Equipment* element = dynamic_cast<IEC61970::Base::Core::Equipment*>(base_class_ptr))
	{
		buffer >> element->normallyInService;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:RegulatingControl.discrete
bool assign_RegulatingControl_discrete(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::RegulatingControl* element = dynamic_cast<IEC61970::Base::Wires::RegulatingControl*>(base_class_ptr))
	{
		buffer >> element->discrete;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:RegulatingControl.enabled
bool assign_RegulatingControl_enabled(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::RegulatingControl* element = dynamic_cast<IEC61970::Base::Wires::RegulatingControl*>(base_class_ptr))
	{
		buffer >> element->enabled;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:RegulatingControl.mode
bool assign_RegulatingControl_mode(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::RegulatingControl* element = dynamic_cast<IEC61970::Base::Wires::RegulatingControl*>(base_class_ptr))
	{
		buffer >> element->mode;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:RegulatingControl.monitoredPhase
bool assign_RegulatingControl_monitoredPhase(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::RegulatingControl* element = dynamic_cast<IEC61970::Base::Wires::RegulatingControl*>(base_class_ptr))
	{
		buffer >> element->monitoredPhase;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:RegulatingControl.targetDeadband
bool assign_RegulatingControl_targetDeadband(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::RegulatingControl* element = dynamic_cast<IEC61970::Base::Wires::RegulatingControl*>(base_class_ptr))
	{
		buffer >> element->targetDeadband;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:RegulatingControl.targetValue
bool assign_RegulatingControl_targetValue(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::RegulatingControl* element = dynamic_cast<IEC61970::Base::Wires::RegulatingControl*>(base_class_ptr))
	{
		buffer >> element->targetValue;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:RegulatingControl.targetValueUnitMultiplier
bool assign_RegulatingControl_targetValueUnitMultiplier(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::RegulatingControl* element = dynamic_cast<IEC61970::Base::Wires::RegulatingControl*>(base_class_ptr))
	{
		buffer >> element->targetValueUnitMultiplier;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Terminal.phases
bool assign_Terminal_phases(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Core::Terminal* element = dynamic_cast<IEC61970::Base::Core::Terminal*>(base_class_ptr))
	{
		buffer >> element->phases;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ActivePower.multiplier
bool assign_ActivePower_multiplier(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Domain::ActivePower* element = dynamic_cast<IEC61970::Base::Domain::ActivePower*>(base_class_ptr))
	{
		buffer >> element->multiplier;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:CurrentTransformer.accuracyClass
bool assign_CurrentTransformer_accuracyClass(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::AuxiliaryEquipment::CurrentTransformer* element = dynamic_cast<IEC61970::Base::AuxiliaryEquipment::CurrentTransformer*>(base_class_ptr))
	{
		element->accuracyClass = buffer.str();
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:CurrentTransformer.accuracyLimit
bool assign_CurrentTransformer_accuracyLimit(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::AuxiliaryEquipment::CurrentTransformer* element = dynamic_cast<IEC61970::Base::AuxiliaryEquipment::CurrentTransformer*>(base_class_ptr))
	{
		buffer >> element->accuracyLimit.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:CurrentTransformer.coreBurden
bool assign_CurrentTransformer_coreBurden(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::AuxiliaryEquipment::CurrentTransformer* element = dynamic_cast<IEC61970::Base::AuxiliaryEquipment::CurrentTransformer*>(base_class_ptr))
	{
		buffer >> element->coreBurden.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:CurrentTransformer.ctClass
bool assign_CurrentTransformer_ctClass(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::AuxiliaryEquipment::CurrentTransformer* element = dynamic_cast<IEC61970::Base::AuxiliaryEquipment::CurrentTransformer*>(base_class_ptr))
	{
		element->ctClass = buffer.str();
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:CurrentTransformer.usage
bool assign_CurrentTransformer_usage(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::AuxiliaryEquipment::CurrentTransformer* element = dynamic_cast<IEC61970::Base::AuxiliaryEquipment::CurrentTransformer*>(base_class_ptr))
	{
		element->usage = buffer.str();
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PotentialTransformer.accuracyClass
bool assign_PotentialTransformer_accuracyClass(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::AuxiliaryEquipment::PotentialTransformer* element = dynamic_cast<IEC61970::Base::AuxiliaryEquipment::PotentialTransformer*>(base_class_ptr))
	{
		element->accuracyClass = buffer.str();
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PotentialTransformer.nominalRatio
bool assign_PotentialTransformer_nominalRatio(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::AuxiliaryEquipment::PotentialTransformer* element = dynamic_cast<IEC61970::Base::AuxiliaryEquipment::PotentialTransformer*>(base_class_ptr))
	{
		buffer >> element->nominalRatio;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PotentialTransformer.ptClass
bool assign_PotentialTransformer_ptClass(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::AuxiliaryEquipment::PotentialTransformer* element = dynamic_cast<IEC61970::Base::AuxiliaryEquipment::PotentialTransformer*>(base_class_ptr))
	{
		element->ptClass = buffer.str();
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PotentialTransformer.type
bool assign_PotentialTransformer_type(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::AuxiliaryEquipment::PotentialTransformer* element = dynamic_cast<IEC61970::Base::AuxiliaryEquipment::PotentialTransformer*>(base_class_ptr))
	{
		buffer >> element->type;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Contingency.mustStudy
bool assign_Contingency_mustStudy(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Contingency::Contingency* element = dynamic_cast<IEC61970::Base::Contingency::Contingency*>(base_class_ptr))
	{
		buffer >> element->mustStudy;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ContingencyEquipment.contingentStatus
bool assign_ContingencyEquipment_contingentStatus(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Contingency::ContingencyEquipment* element = dynamic_cast<IEC61970::Base::Contingency::ContingencyEquipment*>(base_class_ptr))
	{
		buffer >> element->contingentStatus;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:RemoteSource.deadband
bool assign_RemoteSource_deadband(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::SCADA::RemoteSource* element = dynamic_cast<IEC61970::Base::SCADA::RemoteSource*>(base_class_ptr))
	{
		buffer >> element->deadband;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:RemoteSource.scanInterval
bool assign_RemoteSource_scanInterval(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::SCADA::RemoteSource* element = dynamic_cast<IEC61970::Base::SCADA::RemoteSource*>(base_class_ptr))
	{
		buffer >> element->scanInterval.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:RemoteSource.sensorMaximum
bool assign_RemoteSource_sensorMaximum(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::SCADA::RemoteSource* element = dynamic_cast<IEC61970::Base::SCADA::RemoteSource*>(base_class_ptr))
	{
		buffer >> element->sensorMaximum;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:RemoteSource.sensorMinimum
bool assign_RemoteSource_sensorMinimum(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::SCADA::RemoteSource* element = dynamic_cast<IEC61970::Base::SCADA::RemoteSource*>(base_class_ptr))
	{
		buffer >> element->sensorMinimum;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Quality61850.badReference
bool assign_Quality61850_badReference(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Meas::Quality61850* element = dynamic_cast<IEC61970::Base::Meas::Quality61850*>(base_class_ptr))
	{
		buffer >> element->badReference;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Quality61850.estimatorReplaced
bool assign_Quality61850_estimatorReplaced(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Meas::Quality61850* element = dynamic_cast<IEC61970::Base::Meas::Quality61850*>(base_class_ptr))
	{
		buffer >> element->estimatorReplaced;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Quality61850.failure
bool assign_Quality61850_failure(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Meas::Quality61850* element = dynamic_cast<IEC61970::Base::Meas::Quality61850*>(base_class_ptr))
	{
		buffer >> element->failure;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Quality61850.oldData
bool assign_Quality61850_oldData(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Meas::Quality61850* element = dynamic_cast<IEC61970::Base::Meas::Quality61850*>(base_class_ptr))
	{
		buffer >> element->oldData;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Quality61850.operatorBlocked
bool assign_Quality61850_operatorBlocked(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Meas::Quality61850* element = dynamic_cast<IEC61970::Base::Meas::Quality61850*>(base_class_ptr))
	{
		buffer >> element->operatorBlocked;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Quality61850.oscillatory
bool assign_Quality61850_oscillatory(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Meas::Quality61850* element = dynamic_cast<IEC61970::Base::Meas::Quality61850*>(base_class_ptr))
	{
		buffer >> element->oscillatory;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Quality61850.outOfRange
bool assign_Quality61850_outOfRange(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Meas::Quality61850* element = dynamic_cast<IEC61970::Base::Meas::Quality61850*>(base_class_ptr))
	{
		buffer >> element->outOfRange;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Quality61850.overFlow
bool assign_Quality61850_overFlow(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Meas::Quality61850* element = dynamic_cast<IEC61970::Base::Meas::Quality61850*>(base_class_ptr))
	{
		buffer >> element->overFlow;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Quality61850.source
bool assign_Quality61850_source(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Meas::Quality61850* element = dynamic_cast<IEC61970::Base::Meas::Quality61850*>(base_class_ptr))
	{
		buffer >> element->source;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Quality61850.suspect
bool assign_Quality61850_suspect(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Meas::Quality61850* element = dynamic_cast<IEC61970::Base::Meas::Quality61850*>(base_class_ptr))
	{
		buffer >> element->suspect;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Quality61850.test
bool assign_Quality61850_test(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Meas::Quality61850* element = dynamic_cast<IEC61970::Base::Meas::Quality61850*>(base_class_ptr))
	{
		buffer >> element->test;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Quality61850.validity
bool assign_Quality61850_validity(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Meas::Quality61850* element = dynamic_cast<IEC61970::Base::Meas::Quality61850*>(base_class_ptr))
	{
		buffer >> element->validity;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:MeasurementValue.sensorAccuracy
bool assign_MeasurementValue_sensorAccuracy(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Meas::MeasurementValue* element = dynamic_cast<IEC61970::Base::Meas::MeasurementValue*>(base_class_ptr))
	{
		buffer >> element->sensorAccuracy.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:MeasurementValue.timeStamp
bool assign_MeasurementValue_timeStamp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Meas::MeasurementValue* element = dynamic_cast<IEC61970::Base::Meas::MeasurementValue*>(base_class_ptr))
	{
		element->timeStamp.value = buffer.str();
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:AnalogControl.maxValue
bool assign_AnalogControl_maxValue(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Meas::AnalogControl* element = dynamic_cast<IEC61970::Base::Meas::AnalogControl*>(base_class_ptr))
	{
		buffer >> element->maxValue;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:AnalogControl.minValue
bool assign_AnalogControl_minValue(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Meas::AnalogControl* element = dynamic_cast<IEC61970::Base::Meas::AnalogControl*>(base_class_ptr))
	{
		buffer >> element->minValue;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:AnalogValue.value
bool assign_AnalogValue_value(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Meas::AnalogValue* element = dynamic_cast<IEC61970::Base::Meas::AnalogValue*>(base_class_ptr))
	{
		buffer >> element->value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:AltGeneratingUnitMeas.priority
bool assign_AltGeneratingUnitMeas_priority(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::ControlArea::AltGeneratingUnitMeas* element = dynamic_cast<IEC61970::Base::ControlArea::AltGeneratingUnitMeas*>(base_class_ptr))
	{
		buffer >> element->priority;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:AltTieMeas.priority
bool assign_AltTieMeas_priority(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::ControlArea::AltTieMeas* element = dynamic_cast<IEC61970::Base::ControlArea::AltTieMeas*>(base_class_ptr))
	{
		buffer >> element->priority;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ActivePowerChangeRate.multiplier
bool assign_ActivePowerChangeRate_multiplier(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Domain::ActivePowerChangeRate* element = dynamic_cast<IEC61970::Base::Domain::ActivePowerChangeRate*>(base_class_ptr))
	{
		buffer >> element->multiplier;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Money.multiplier
bool assign_Money_multiplier(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Domain::Money* element = dynamic_cast<IEC61970::Base::Domain::Money*>(base_class_ptr))
	{
		buffer >> element->multiplier;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Money.unit
bool assign_Money_unit(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Domain::Money* element = dynamic_cast<IEC61970::Base::Domain::Money*>(base_class_ptr))
	{
		buffer >> element->unit;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:RegularTimePoint.sequenceNumber
bool assign_RegularTimePoint_sequenceNumber(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Core::RegularTimePoint* element = dynamic_cast<IEC61970::Base::Core::RegularTimePoint*>(base_class_ptr))
	{
		buffer >> element->sequenceNumber;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:RegularTimePoint.value1
bool assign_RegularTimePoint_value1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Core::RegularTimePoint* element = dynamic_cast<IEC61970::Base::Core::RegularTimePoint*>(base_class_ptr))
	{
		buffer >> element->value1;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:RegularTimePoint.value2
bool assign_RegularTimePoint_value2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Core::RegularTimePoint* element = dynamic_cast<IEC61970::Base::Core::RegularTimePoint*>(base_class_ptr))
	{
		buffer >> element->value2;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:BasicIntervalSchedule.startTime
bool assign_BasicIntervalSchedule_startTime(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Core::BasicIntervalSchedule* element = dynamic_cast<IEC61970::Base::Core::BasicIntervalSchedule*>(base_class_ptr))
	{
		element->startTime.value = buffer.str();
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:BasicIntervalSchedule.value1Multiplier
bool assign_BasicIntervalSchedule_value1Multiplier(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Core::BasicIntervalSchedule* element = dynamic_cast<IEC61970::Base::Core::BasicIntervalSchedule*>(base_class_ptr))
	{
		buffer >> element->value1Multiplier;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:BasicIntervalSchedule.value1Unit
bool assign_BasicIntervalSchedule_value1Unit(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Core::BasicIntervalSchedule* element = dynamic_cast<IEC61970::Base::Core::BasicIntervalSchedule*>(base_class_ptr))
	{
		buffer >> element->value1Unit;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:BasicIntervalSchedule.value2Multiplier
bool assign_BasicIntervalSchedule_value2Multiplier(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Core::BasicIntervalSchedule* element = dynamic_cast<IEC61970::Base::Core::BasicIntervalSchedule*>(base_class_ptr))
	{
		buffer >> element->value2Multiplier;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:BasicIntervalSchedule.value2Unit
bool assign_BasicIntervalSchedule_value2Unit(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Core::BasicIntervalSchedule* element = dynamic_cast<IEC61970::Base::Core::BasicIntervalSchedule*>(base_class_ptr))
	{
		buffer >> element->value2Unit;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:RegularIntervalSchedule.endTime
bool assign_RegularIntervalSchedule_endTime(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Core::RegularIntervalSchedule* element = dynamic_cast<IEC61970::Base::Core::RegularIntervalSchedule*>(base_class_ptr))
	{
		element->endTime.value = buffer.str();
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:RegularIntervalSchedule.timeStep
bool assign_RegularIntervalSchedule_timeStep(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Core::RegularIntervalSchedule* element = dynamic_cast<IEC61970::Base::Core::RegularIntervalSchedule*>(base_class_ptr))
	{
		buffer >> element->timeStep.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:CurveData.xvalue
bool assign_CurveData_xvalue(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Core::CurveData* element = dynamic_cast<IEC61970::Base::Core::CurveData*>(base_class_ptr))
	{
		buffer >> element->xvalue;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:CurveData.y1value
bool assign_CurveData_y1value(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Core::CurveData* element = dynamic_cast<IEC61970::Base::Core::CurveData*>(base_class_ptr))
	{
		buffer >> element->y1value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:CurveData.y2value
bool assign_CurveData_y2value(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Core::CurveData* element = dynamic_cast<IEC61970::Base::Core::CurveData*>(base_class_ptr))
	{
		buffer >> element->y2value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:CurveData.y3value
bool assign_CurveData_y3value(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Core::CurveData* element = dynamic_cast<IEC61970::Base::Core::CurveData*>(base_class_ptr))
	{
		buffer >> element->y3value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Curve.curveStyle
bool assign_Curve_curveStyle(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Core::Curve* element = dynamic_cast<IEC61970::Base::Core::Curve*>(base_class_ptr))
	{
		buffer >> element->curveStyle;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Curve.xMultiplier
bool assign_Curve_xMultiplier(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Core::Curve* element = dynamic_cast<IEC61970::Base::Core::Curve*>(base_class_ptr))
	{
		buffer >> element->xMultiplier;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Curve.xUnit
bool assign_Curve_xUnit(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Core::Curve* element = dynamic_cast<IEC61970::Base::Core::Curve*>(base_class_ptr))
	{
		buffer >> element->xUnit;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Curve.y1Multiplier
bool assign_Curve_y1Multiplier(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Core::Curve* element = dynamic_cast<IEC61970::Base::Core::Curve*>(base_class_ptr))
	{
		buffer >> element->y1Multiplier;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Curve.y1Unit
bool assign_Curve_y1Unit(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Core::Curve* element = dynamic_cast<IEC61970::Base::Core::Curve*>(base_class_ptr))
	{
		buffer >> element->y1Unit;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Curve.y2Multiplier
bool assign_Curve_y2Multiplier(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Core::Curve* element = dynamic_cast<IEC61970::Base::Core::Curve*>(base_class_ptr))
	{
		buffer >> element->y2Multiplier;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Curve.y2Unit
bool assign_Curve_y2Unit(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Core::Curve* element = dynamic_cast<IEC61970::Base::Core::Curve*>(base_class_ptr))
	{
		buffer >> element->y2Unit;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Curve.y3Multiplier
bool assign_Curve_y3Multiplier(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Core::Curve* element = dynamic_cast<IEC61970::Base::Core::Curve*>(base_class_ptr))
	{
		buffer >> element->y3Multiplier;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Curve.y3Unit
bool assign_Curve_y3Unit(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Core::Curve* element = dynamic_cast<IEC61970::Base::Core::Curve*>(base_class_ptr))
	{
		buffer >> element->y3Unit;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GenUnitOpCostCurve.isNetGrossP
bool assign_GenUnitOpCostCurve_isNetGrossP(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::GenUnitOpCostCurve* element = dynamic_cast<IEC61970::Base::Generation::Production::GenUnitOpCostCurve*>(base_class_ptr))
	{
		buffer >> element->isNetGrossP;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ReactivePower.multiplier
bool assign_ReactivePower_multiplier(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Domain::ReactivePower* element = dynamic_cast<IEC61970::Base::Domain::ReactivePower*>(base_class_ptr))
	{
		buffer >> element->multiplier;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ApparentPower.multiplier
bool assign_ApparentPower_multiplier(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Domain::ApparentPower* element = dynamic_cast<IEC61970::Base::Domain::ApparentPower*>(base_class_ptr))
	{
		buffer >> element->multiplier;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Voltage.multiplier
bool assign_Voltage_multiplier(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Domain::Voltage* element = dynamic_cast<IEC61970::Base::Domain::Voltage*>(base_class_ptr))
	{
		buffer >> element->multiplier;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:HydroPump.pumpDischAtMaxHead
bool assign_HydroPump_pumpDischAtMaxHead(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::HydroPump* element = dynamic_cast<IEC61970::Base::Generation::Production::HydroPump*>(base_class_ptr))
	{
		buffer >> element->pumpDischAtMaxHead.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:HydroPump.pumpDischAtMinHead
bool assign_HydroPump_pumpDischAtMinHead(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::HydroPump* element = dynamic_cast<IEC61970::Base::Generation::Production::HydroPump*>(base_class_ptr))
	{
		buffer >> element->pumpDischAtMinHead.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:HydroPump.pumpPowerAtMaxHead
bool assign_HydroPump_pumpPowerAtMaxHead(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::HydroPump* element = dynamic_cast<IEC61970::Base::Generation::Production::HydroPump*>(base_class_ptr))
	{
		buffer >> element->pumpPowerAtMaxHead.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:HydroPump.pumpPowerAtMinHead
bool assign_HydroPump_pumpPowerAtMinHead(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::HydroPump* element = dynamic_cast<IEC61970::Base::Generation::Production::HydroPump*>(base_class_ptr))
	{
		buffer >> element->pumpPowerAtMinHead.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:RegulatingCondEq.controlEnabled
bool assign_RegulatingCondEq_controlEnabled(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::RegulatingCondEq* element = dynamic_cast<IEC61970::Base::Wires::RegulatingCondEq*>(base_class_ptr))
	{
		buffer >> element->controlEnabled;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:RotatingMachine.p
bool assign_RotatingMachine_p(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::RotatingMachine* element = dynamic_cast<IEC61970::Base::Wires::RotatingMachine*>(base_class_ptr))
	{
		buffer >> element->p.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:RotatingMachine.q
bool assign_RotatingMachine_q(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::RotatingMachine* element = dynamic_cast<IEC61970::Base::Wires::RotatingMachine*>(base_class_ptr))
	{
		buffer >> element->q.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:RotatingMachine.ratedPowerFactor
bool assign_RotatingMachine_ratedPowerFactor(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::RotatingMachine* element = dynamic_cast<IEC61970::Base::Wires::RotatingMachine*>(base_class_ptr))
	{
		buffer >> element->ratedPowerFactor;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:RotatingMachine.ratedS
bool assign_RotatingMachine_ratedS(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::RotatingMachine* element = dynamic_cast<IEC61970::Base::Wires::RotatingMachine*>(base_class_ptr))
	{
		buffer >> element->ratedS.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:RotatingMachine.ratedU
bool assign_RotatingMachine_ratedU(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::RotatingMachine* element = dynamic_cast<IEC61970::Base::Wires::RotatingMachine*>(base_class_ptr))
	{
		buffer >> element->ratedU.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GeneratingUnit.allocSpinResP
bool assign_GeneratingUnit_allocSpinResP(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::GeneratingUnit* element = dynamic_cast<IEC61970::Base::Generation::Production::GeneratingUnit*>(base_class_ptr))
	{
		buffer >> element->allocSpinResP.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GeneratingUnit.autoCntrlMarginP
bool assign_GeneratingUnit_autoCntrlMarginP(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::GeneratingUnit* element = dynamic_cast<IEC61970::Base::Generation::Production::GeneratingUnit*>(base_class_ptr))
	{
		buffer >> element->autoCntrlMarginP.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GeneratingUnit.baseP
bool assign_GeneratingUnit_baseP(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::GeneratingUnit* element = dynamic_cast<IEC61970::Base::Generation::Production::GeneratingUnit*>(base_class_ptr))
	{
		buffer >> element->baseP.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GeneratingUnit.controlDeadband
bool assign_GeneratingUnit_controlDeadband(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::GeneratingUnit* element = dynamic_cast<IEC61970::Base::Generation::Production::GeneratingUnit*>(base_class_ptr))
	{
		buffer >> element->controlDeadband.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GeneratingUnit.controlPulseHigh
bool assign_GeneratingUnit_controlPulseHigh(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::GeneratingUnit* element = dynamic_cast<IEC61970::Base::Generation::Production::GeneratingUnit*>(base_class_ptr))
	{
		buffer >> element->controlPulseHigh.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GeneratingUnit.controlPulseLow
bool assign_GeneratingUnit_controlPulseLow(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::GeneratingUnit* element = dynamic_cast<IEC61970::Base::Generation::Production::GeneratingUnit*>(base_class_ptr))
	{
		buffer >> element->controlPulseLow.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GeneratingUnit.controlResponseRate
bool assign_GeneratingUnit_controlResponseRate(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::GeneratingUnit* element = dynamic_cast<IEC61970::Base::Generation::Production::GeneratingUnit*>(base_class_ptr))
	{
		buffer >> element->controlResponseRate.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GeneratingUnit.efficiency
bool assign_GeneratingUnit_efficiency(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::GeneratingUnit* element = dynamic_cast<IEC61970::Base::Generation::Production::GeneratingUnit*>(base_class_ptr))
	{
		buffer >> element->efficiency.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GeneratingUnit.genControlMode
bool assign_GeneratingUnit_genControlMode(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::GeneratingUnit* element = dynamic_cast<IEC61970::Base::Generation::Production::GeneratingUnit*>(base_class_ptr))
	{
		buffer >> element->genControlMode;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GeneratingUnit.genControlSource
bool assign_GeneratingUnit_genControlSource(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::GeneratingUnit* element = dynamic_cast<IEC61970::Base::Generation::Production::GeneratingUnit*>(base_class_ptr))
	{
		buffer >> element->genControlSource;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GeneratingUnit.governorMPL
bool assign_GeneratingUnit_governorMPL(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::GeneratingUnit* element = dynamic_cast<IEC61970::Base::Generation::Production::GeneratingUnit*>(base_class_ptr))
	{
		buffer >> element->governorMPL.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GeneratingUnit.governorSCD
bool assign_GeneratingUnit_governorSCD(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::GeneratingUnit* element = dynamic_cast<IEC61970::Base::Generation::Production::GeneratingUnit*>(base_class_ptr))
	{
		buffer >> element->governorSCD.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GeneratingUnit.highControlLimit
bool assign_GeneratingUnit_highControlLimit(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::GeneratingUnit* element = dynamic_cast<IEC61970::Base::Generation::Production::GeneratingUnit*>(base_class_ptr))
	{
		buffer >> element->highControlLimit.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GeneratingUnit.initialP
bool assign_GeneratingUnit_initialP(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::GeneratingUnit* element = dynamic_cast<IEC61970::Base::Generation::Production::GeneratingUnit*>(base_class_ptr))
	{
		buffer >> element->initialP.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GeneratingUnit.longPF
bool assign_GeneratingUnit_longPF(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::GeneratingUnit* element = dynamic_cast<IEC61970::Base::Generation::Production::GeneratingUnit*>(base_class_ptr))
	{
		buffer >> element->longPF;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GeneratingUnit.lowControlLimit
bool assign_GeneratingUnit_lowControlLimit(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::GeneratingUnit* element = dynamic_cast<IEC61970::Base::Generation::Production::GeneratingUnit*>(base_class_ptr))
	{
		buffer >> element->lowControlLimit.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GeneratingUnit.lowerRampRate
bool assign_GeneratingUnit_lowerRampRate(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::GeneratingUnit* element = dynamic_cast<IEC61970::Base::Generation::Production::GeneratingUnit*>(base_class_ptr))
	{
		buffer >> element->lowerRampRate.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GeneratingUnit.maxEconomicP
bool assign_GeneratingUnit_maxEconomicP(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::GeneratingUnit* element = dynamic_cast<IEC61970::Base::Generation::Production::GeneratingUnit*>(base_class_ptr))
	{
		buffer >> element->maxEconomicP.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GeneratingUnit.maximumAllowableSpinningReserve
bool assign_GeneratingUnit_maximumAllowableSpinningReserve(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::GeneratingUnit* element = dynamic_cast<IEC61970::Base::Generation::Production::GeneratingUnit*>(base_class_ptr))
	{
		buffer >> element->maximumAllowableSpinningReserve.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GeneratingUnit.maxOperatingP
bool assign_GeneratingUnit_maxOperatingP(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::GeneratingUnit* element = dynamic_cast<IEC61970::Base::Generation::Production::GeneratingUnit*>(base_class_ptr))
	{
		buffer >> element->maxOperatingP.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GeneratingUnit.minEconomicP
bool assign_GeneratingUnit_minEconomicP(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::GeneratingUnit* element = dynamic_cast<IEC61970::Base::Generation::Production::GeneratingUnit*>(base_class_ptr))
	{
		buffer >> element->minEconomicP.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GeneratingUnit.minimumOffTime
bool assign_GeneratingUnit_minimumOffTime(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::GeneratingUnit* element = dynamic_cast<IEC61970::Base::Generation::Production::GeneratingUnit*>(base_class_ptr))
	{
		buffer >> element->minimumOffTime.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GeneratingUnit.minOperatingP
bool assign_GeneratingUnit_minOperatingP(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::GeneratingUnit* element = dynamic_cast<IEC61970::Base::Generation::Production::GeneratingUnit*>(base_class_ptr))
	{
		buffer >> element->minOperatingP.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GeneratingUnit.modelDetail
bool assign_GeneratingUnit_modelDetail(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::GeneratingUnit* element = dynamic_cast<IEC61970::Base::Generation::Production::GeneratingUnit*>(base_class_ptr))
	{
		buffer >> element->modelDetail.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GeneratingUnit.nominalP
bool assign_GeneratingUnit_nominalP(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::GeneratingUnit* element = dynamic_cast<IEC61970::Base::Generation::Production::GeneratingUnit*>(base_class_ptr))
	{
		buffer >> element->nominalP.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GeneratingUnit.normalPF
bool assign_GeneratingUnit_normalPF(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::GeneratingUnit* element = dynamic_cast<IEC61970::Base::Generation::Production::GeneratingUnit*>(base_class_ptr))
	{
		buffer >> element->normalPF;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GeneratingUnit.penaltyFactor
bool assign_GeneratingUnit_penaltyFactor(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::GeneratingUnit* element = dynamic_cast<IEC61970::Base::Generation::Production::GeneratingUnit*>(base_class_ptr))
	{
		buffer >> element->penaltyFactor;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GeneratingUnit.raiseRampRate
bool assign_GeneratingUnit_raiseRampRate(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::GeneratingUnit* element = dynamic_cast<IEC61970::Base::Generation::Production::GeneratingUnit*>(base_class_ptr))
	{
		buffer >> element->raiseRampRate.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GeneratingUnit.ratedGrossMaxP
bool assign_GeneratingUnit_ratedGrossMaxP(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::GeneratingUnit* element = dynamic_cast<IEC61970::Base::Generation::Production::GeneratingUnit*>(base_class_ptr))
	{
		buffer >> element->ratedGrossMaxP.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GeneratingUnit.ratedGrossMinP
bool assign_GeneratingUnit_ratedGrossMinP(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::GeneratingUnit* element = dynamic_cast<IEC61970::Base::Generation::Production::GeneratingUnit*>(base_class_ptr))
	{
		buffer >> element->ratedGrossMinP.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GeneratingUnit.ratedNetMaxP
bool assign_GeneratingUnit_ratedNetMaxP(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::GeneratingUnit* element = dynamic_cast<IEC61970::Base::Generation::Production::GeneratingUnit*>(base_class_ptr))
	{
		buffer >> element->ratedNetMaxP.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GeneratingUnit.shortPF
bool assign_GeneratingUnit_shortPF(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::GeneratingUnit* element = dynamic_cast<IEC61970::Base::Generation::Production::GeneratingUnit*>(base_class_ptr))
	{
		buffer >> element->shortPF;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GeneratingUnit.startupCost
bool assign_GeneratingUnit_startupCost(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::GeneratingUnit* element = dynamic_cast<IEC61970::Base::Generation::Production::GeneratingUnit*>(base_class_ptr))
	{
		buffer >> element->startupCost.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GeneratingUnit.startupTime
bool assign_GeneratingUnit_startupTime(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::GeneratingUnit* element = dynamic_cast<IEC61970::Base::Generation::Production::GeneratingUnit*>(base_class_ptr))
	{
		buffer >> element->startupTime.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GeneratingUnit.tieLinePF
bool assign_GeneratingUnit_tieLinePF(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::GeneratingUnit* element = dynamic_cast<IEC61970::Base::Generation::Production::GeneratingUnit*>(base_class_ptr))
	{
		buffer >> element->tieLinePF;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GeneratingUnit.totalEfficiency
bool assign_GeneratingUnit_totalEfficiency(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::GeneratingUnit* element = dynamic_cast<IEC61970::Base::Generation::Production::GeneratingUnit*>(base_class_ptr))
	{
		buffer >> element->totalEfficiency.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GeneratingUnit.variableCost
bool assign_GeneratingUnit_variableCost(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::GeneratingUnit* element = dynamic_cast<IEC61970::Base::Generation::Production::GeneratingUnit*>(base_class_ptr))
	{
		buffer >> element->variableCost.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TieFlow.positiveFlowIn
bool assign_TieFlow_positiveFlowIn(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::ControlArea::TieFlow* element = dynamic_cast<IEC61970::Base::ControlArea::TieFlow*>(base_class_ptr))
	{
		buffer >> element->positiveFlowIn;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ControlArea.netInterchange
bool assign_ControlArea_netInterchange(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::ControlArea::ControlArea* element = dynamic_cast<IEC61970::Base::ControlArea::ControlArea*>(base_class_ptr))
	{
		buffer >> element->netInterchange.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ControlArea.pTolerance
bool assign_ControlArea_pTolerance(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::ControlArea::ControlArea* element = dynamic_cast<IEC61970::Base::ControlArea::ControlArea*>(base_class_ptr))
	{
		buffer >> element->pTolerance.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ControlArea.type
bool assign_ControlArea_type(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::ControlArea::ControlArea* element = dynamic_cast<IEC61970::Base::ControlArea::ControlArea*>(base_class_ptr))
	{
		buffer >> element->type;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Frequency.multiplier
bool assign_Frequency_multiplier(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Domain::Frequency* element = dynamic_cast<IEC61970::Base::Domain::Frequency*>(base_class_ptr))
	{
		buffer >> element->multiplier;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:BaseFrequency.frequency
bool assign_BaseFrequency_frequency(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Core::BaseFrequency* element = dynamic_cast<IEC61970::Base::Core::BaseFrequency*>(base_class_ptr))
	{
		buffer >> element->frequency.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:BasePower.basePower
bool assign_BasePower_basePower(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Core::BasePower* element = dynamic_cast<IEC61970::Base::Core::BasePower*>(base_class_ptr))
	{
		buffer >> element->basePower.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:BaseVoltage.nominalVoltage
bool assign_BaseVoltage_nominalVoltage(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Core::BaseVoltage* element = dynamic_cast<IEC61970::Base::Core::BaseVoltage*>(base_class_ptr))
	{
		buffer >> element->nominalVoltage.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Bay.bayEnergyMeasFlag
bool assign_Bay_bayEnergyMeasFlag(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Core::Bay* element = dynamic_cast<IEC61970::Base::Core::Bay*>(base_class_ptr))
	{
		buffer >> element->bayEnergyMeasFlag;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Bay.bayPowerMeasFlag
bool assign_Bay_bayPowerMeasFlag(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Core::Bay* element = dynamic_cast<IEC61970::Base::Core::Bay*>(base_class_ptr))
	{
		buffer >> element->bayPowerMeasFlag;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Bay.breakerConfiguration
bool assign_Bay_breakerConfiguration(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Core::Bay* element = dynamic_cast<IEC61970::Base::Core::Bay*>(base_class_ptr))
	{
		buffer >> element->breakerConfiguration;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Bay.busBarConfiguration
bool assign_Bay_busBarConfiguration(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Core::Bay* element = dynamic_cast<IEC61970::Base::Core::Bay*>(base_class_ptr))
	{
		buffer >> element->busBarConfiguration;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:VoltageLevel.highVoltageLimit
bool assign_VoltageLevel_highVoltageLimit(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Core::VoltageLevel* element = dynamic_cast<IEC61970::Base::Core::VoltageLevel*>(base_class_ptr))
	{
		buffer >> element->highVoltageLimit.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:VoltageLevel.lowVoltageLimit
bool assign_VoltageLevel_lowVoltageLimit(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Core::VoltageLevel* element = dynamic_cast<IEC61970::Base::Core::VoltageLevel*>(base_class_ptr))
	{
		buffer >> element->lowVoltageLimit.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:DCConverterUnit.operationMode
bool assign_DCConverterUnit_operationMode(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DC::DCConverterUnit* element = dynamic_cast<IEC61970::Base::DC::DCConverterUnit*>(base_class_ptr))
	{
		buffer >> element->operationMode;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:IrregularTimePoint.time
bool assign_IrregularTimePoint_time(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Core::IrregularTimePoint* element = dynamic_cast<IEC61970::Base::Core::IrregularTimePoint*>(base_class_ptr))
	{
		buffer >> element->time.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:IrregularTimePoint.value1
bool assign_IrregularTimePoint_value1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Core::IrregularTimePoint* element = dynamic_cast<IEC61970::Base::Core::IrregularTimePoint*>(base_class_ptr))
	{
		buffer >> element->value1;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:IrregularTimePoint.value2
bool assign_IrregularTimePoint_value2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Core::IrregularTimePoint* element = dynamic_cast<IEC61970::Base::Core::IrregularTimePoint*>(base_class_ptr))
	{
		buffer >> element->value2;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:NameTypeAuthority.description
bool assign_NameTypeAuthority_description(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Core::NameTypeAuthority* element = dynamic_cast<IEC61970::Base::Core::NameTypeAuthority*>(base_class_ptr))
	{
		element->description = buffer.str();
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:NameTypeAuthority.name
bool assign_NameTypeAuthority_name(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Core::NameTypeAuthority* element = dynamic_cast<IEC61970::Base::Core::NameTypeAuthority*>(base_class_ptr))
	{
		element->name = buffer.str();
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:NameType.description
bool assign_NameType_description(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Core::NameType* element = dynamic_cast<IEC61970::Base::Core::NameType*>(base_class_ptr))
	{
		element->description = buffer.str();
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:NameType.name
bool assign_NameType_name(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Core::NameType* element = dynamic_cast<IEC61970::Base::Core::NameType*>(base_class_ptr))
	{
		element->name = buffer.str();
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Name.name
bool assign_Name_name(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Core::Name* element = dynamic_cast<IEC61970::Base::Core::Name*>(base_class_ptr))
	{
		element->name = buffer.str();
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:OperatingShare.percentage
bool assign_OperatingShare_percentage(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Core::OperatingShare* element = dynamic_cast<IEC61970::Base::Core::OperatingShare*>(base_class_ptr))
	{
		buffer >> element->percentage.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:CurrentFlow.multiplier
bool assign_CurrentFlow_multiplier(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Domain::CurrentFlow* element = dynamic_cast<IEC61970::Base::Domain::CurrentFlow*>(base_class_ptr))
	{
		buffer >> element->multiplier;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Resistance.multiplier
bool assign_Resistance_multiplier(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Domain::Resistance* element = dynamic_cast<IEC61970::Base::Domain::Resistance*>(base_class_ptr))
	{
		buffer >> element->multiplier;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ActivePowerPerCurrentFlow.multiplier
bool assign_ActivePowerPerCurrentFlow_multiplier(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Domain::ActivePowerPerCurrentFlow* element = dynamic_cast<IEC61970::Base::Domain::ActivePowerPerCurrentFlow*>(base_class_ptr))
	{
		buffer >> element->multiplier;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ACDCConverter.baseS
bool assign_ACDCConverter_baseS(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DC::ACDCConverter* element = dynamic_cast<IEC61970::Base::DC::ACDCConverter*>(base_class_ptr))
	{
		buffer >> element->baseS.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ACDCConverter.idc
bool assign_ACDCConverter_idc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DC::ACDCConverter* element = dynamic_cast<IEC61970::Base::DC::ACDCConverter*>(base_class_ptr))
	{
		buffer >> element->idc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ACDCConverter.idleLoss
bool assign_ACDCConverter_idleLoss(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DC::ACDCConverter* element = dynamic_cast<IEC61970::Base::DC::ACDCConverter*>(base_class_ptr))
	{
		buffer >> element->idleLoss.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ACDCConverter.maxUdc
bool assign_ACDCConverter_maxUdc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DC::ACDCConverter* element = dynamic_cast<IEC61970::Base::DC::ACDCConverter*>(base_class_ptr))
	{
		buffer >> element->maxUdc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ACDCConverter.minUdc
bool assign_ACDCConverter_minUdc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DC::ACDCConverter* element = dynamic_cast<IEC61970::Base::DC::ACDCConverter*>(base_class_ptr))
	{
		buffer >> element->minUdc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ACDCConverter.numberOfValves
bool assign_ACDCConverter_numberOfValves(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DC::ACDCConverter* element = dynamic_cast<IEC61970::Base::DC::ACDCConverter*>(base_class_ptr))
	{
		buffer >> element->numberOfValves;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ACDCConverter.p
bool assign_ACDCConverter_p(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DC::ACDCConverter* element = dynamic_cast<IEC61970::Base::DC::ACDCConverter*>(base_class_ptr))
	{
		buffer >> element->p.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ACDCConverter.poleLossP
bool assign_ACDCConverter_poleLossP(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DC::ACDCConverter* element = dynamic_cast<IEC61970::Base::DC::ACDCConverter*>(base_class_ptr))
	{
		buffer >> element->poleLossP.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ACDCConverter.q
bool assign_ACDCConverter_q(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DC::ACDCConverter* element = dynamic_cast<IEC61970::Base::DC::ACDCConverter*>(base_class_ptr))
	{
		buffer >> element->q.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ACDCConverter.ratedUdc
bool assign_ACDCConverter_ratedUdc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DC::ACDCConverter* element = dynamic_cast<IEC61970::Base::DC::ACDCConverter*>(base_class_ptr))
	{
		buffer >> element->ratedUdc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ACDCConverter.resistiveLoss
bool assign_ACDCConverter_resistiveLoss(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DC::ACDCConverter* element = dynamic_cast<IEC61970::Base::DC::ACDCConverter*>(base_class_ptr))
	{
		buffer >> element->resistiveLoss.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ACDCConverter.switchingLoss
bool assign_ACDCConverter_switchingLoss(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DC::ACDCConverter* element = dynamic_cast<IEC61970::Base::DC::ACDCConverter*>(base_class_ptr))
	{
		buffer >> element->switchingLoss.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ACDCConverter.targetPpcc
bool assign_ACDCConverter_targetPpcc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DC::ACDCConverter* element = dynamic_cast<IEC61970::Base::DC::ACDCConverter*>(base_class_ptr))
	{
		buffer >> element->targetPpcc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ACDCConverter.targetUdc
bool assign_ACDCConverter_targetUdc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DC::ACDCConverter* element = dynamic_cast<IEC61970::Base::DC::ACDCConverter*>(base_class_ptr))
	{
		buffer >> element->targetUdc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ACDCConverter.uc
bool assign_ACDCConverter_uc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DC::ACDCConverter* element = dynamic_cast<IEC61970::Base::DC::ACDCConverter*>(base_class_ptr))
	{
		buffer >> element->uc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ACDCConverter.udc
bool assign_ACDCConverter_udc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DC::ACDCConverter* element = dynamic_cast<IEC61970::Base::DC::ACDCConverter*>(base_class_ptr))
	{
		buffer >> element->udc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ACDCConverter.valveU0
bool assign_ACDCConverter_valveU0(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DC::ACDCConverter* element = dynamic_cast<IEC61970::Base::DC::ACDCConverter*>(base_class_ptr))
	{
		buffer >> element->valveU0.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ACDCConverterDCTerminal.polarity
bool assign_ACDCConverterDCTerminal_polarity(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DC::ACDCConverterDCTerminal* element = dynamic_cast<IEC61970::Base::DC::ACDCConverterDCTerminal*>(base_class_ptr))
	{
		buffer >> element->polarity;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:CsConverter.alpha
bool assign_CsConverter_alpha(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DC::CsConverter* element = dynamic_cast<IEC61970::Base::DC::CsConverter*>(base_class_ptr))
	{
		buffer >> element->alpha.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:CsConverter.gamma
bool assign_CsConverter_gamma(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DC::CsConverter* element = dynamic_cast<IEC61970::Base::DC::CsConverter*>(base_class_ptr))
	{
		buffer >> element->gamma.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:CsConverter.maxAlpha
bool assign_CsConverter_maxAlpha(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DC::CsConverter* element = dynamic_cast<IEC61970::Base::DC::CsConverter*>(base_class_ptr))
	{
		buffer >> element->maxAlpha.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:CsConverter.maxGamma
bool assign_CsConverter_maxGamma(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DC::CsConverter* element = dynamic_cast<IEC61970::Base::DC::CsConverter*>(base_class_ptr))
	{
		buffer >> element->maxGamma.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:CsConverter.maxIdc
bool assign_CsConverter_maxIdc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DC::CsConverter* element = dynamic_cast<IEC61970::Base::DC::CsConverter*>(base_class_ptr))
	{
		buffer >> element->maxIdc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:CsConverter.minAlpha
bool assign_CsConverter_minAlpha(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DC::CsConverter* element = dynamic_cast<IEC61970::Base::DC::CsConverter*>(base_class_ptr))
	{
		buffer >> element->minAlpha.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:CsConverter.minGamma
bool assign_CsConverter_minGamma(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DC::CsConverter* element = dynamic_cast<IEC61970::Base::DC::CsConverter*>(base_class_ptr))
	{
		buffer >> element->minGamma.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:CsConverter.minIdc
bool assign_CsConverter_minIdc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DC::CsConverter* element = dynamic_cast<IEC61970::Base::DC::CsConverter*>(base_class_ptr))
	{
		buffer >> element->minIdc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:CsConverter.operatingMode
bool assign_CsConverter_operatingMode(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DC::CsConverter* element = dynamic_cast<IEC61970::Base::DC::CsConverter*>(base_class_ptr))
	{
		buffer >> element->operatingMode;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:CsConverter.pPccControl
bool assign_CsConverter_pPccControl(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DC::CsConverter* element = dynamic_cast<IEC61970::Base::DC::CsConverter*>(base_class_ptr))
	{
		buffer >> element->pPccControl;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:CsConverter.ratedIdc
bool assign_CsConverter_ratedIdc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DC::CsConverter* element = dynamic_cast<IEC61970::Base::DC::CsConverter*>(base_class_ptr))
	{
		buffer >> element->ratedIdc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:CsConverter.targetAlpha
bool assign_CsConverter_targetAlpha(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DC::CsConverter* element = dynamic_cast<IEC61970::Base::DC::CsConverter*>(base_class_ptr))
	{
		buffer >> element->targetAlpha.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:CsConverter.targetGamma
bool assign_CsConverter_targetGamma(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DC::CsConverter* element = dynamic_cast<IEC61970::Base::DC::CsConverter*>(base_class_ptr))
	{
		buffer >> element->targetGamma.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:CsConverter.targetIdc
bool assign_CsConverter_targetIdc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DC::CsConverter* element = dynamic_cast<IEC61970::Base::DC::CsConverter*>(base_class_ptr))
	{
		buffer >> element->targetIdc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Inductance.multiplier
bool assign_Inductance_multiplier(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Domain::Inductance* element = dynamic_cast<IEC61970::Base::Domain::Inductance*>(base_class_ptr))
	{
		buffer >> element->multiplier;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:DCGround.inductance
bool assign_DCGround_inductance(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DC::DCGround* element = dynamic_cast<IEC61970::Base::DC::DCGround*>(base_class_ptr))
	{
		buffer >> element->inductance.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:DCGround.r
bool assign_DCGround_r(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DC::DCGround* element = dynamic_cast<IEC61970::Base::DC::DCGround*>(base_class_ptr))
	{
		buffer >> element->r.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Capacitance.multiplier
bool assign_Capacitance_multiplier(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Domain::Capacitance* element = dynamic_cast<IEC61970::Base::Domain::Capacitance*>(base_class_ptr))
	{
		buffer >> element->multiplier;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Length.multiplier
bool assign_Length_multiplier(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Domain::Length* element = dynamic_cast<IEC61970::Base::Domain::Length*>(base_class_ptr))
	{
		buffer >> element->multiplier;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:DCLineSegment.capacitance
bool assign_DCLineSegment_capacitance(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DC::DCLineSegment* element = dynamic_cast<IEC61970::Base::DC::DCLineSegment*>(base_class_ptr))
	{
		buffer >> element->capacitance.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:DCLineSegment.inductance
bool assign_DCLineSegment_inductance(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DC::DCLineSegment* element = dynamic_cast<IEC61970::Base::DC::DCLineSegment*>(base_class_ptr))
	{
		buffer >> element->inductance.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:DCLineSegment.length
bool assign_DCLineSegment_length(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DC::DCLineSegment* element = dynamic_cast<IEC61970::Base::DC::DCLineSegment*>(base_class_ptr))
	{
		buffer >> element->length.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:DCLineSegment.resistance
bool assign_DCLineSegment_resistance(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DC::DCLineSegment* element = dynamic_cast<IEC61970::Base::DC::DCLineSegment*>(base_class_ptr))
	{
		buffer >> element->resistance.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:DCSeriesDevice.inductance
bool assign_DCSeriesDevice_inductance(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DC::DCSeriesDevice* element = dynamic_cast<IEC61970::Base::DC::DCSeriesDevice*>(base_class_ptr))
	{
		buffer >> element->inductance.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:DCSeriesDevice.ratedUdc
bool assign_DCSeriesDevice_ratedUdc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DC::DCSeriesDevice* element = dynamic_cast<IEC61970::Base::DC::DCSeriesDevice*>(base_class_ptr))
	{
		buffer >> element->ratedUdc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:DCSeriesDevice.resistance
bool assign_DCSeriesDevice_resistance(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DC::DCSeriesDevice* element = dynamic_cast<IEC61970::Base::DC::DCSeriesDevice*>(base_class_ptr))
	{
		buffer >> element->resistance.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:DCShunt.capacitance
bool assign_DCShunt_capacitance(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DC::DCShunt* element = dynamic_cast<IEC61970::Base::DC::DCShunt*>(base_class_ptr))
	{
		buffer >> element->capacitance.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:DCShunt.ratedUdc
bool assign_DCShunt_ratedUdc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DC::DCShunt* element = dynamic_cast<IEC61970::Base::DC::DCShunt*>(base_class_ptr))
	{
		buffer >> element->ratedUdc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:DCShunt.resistance
bool assign_DCShunt_resistance(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DC::DCShunt* element = dynamic_cast<IEC61970::Base::DC::DCShunt*>(base_class_ptr))
	{
		buffer >> element->resistance.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PerLengthDCLineParameter.capacitance
bool assign_PerLengthDCLineParameter_capacitance(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DC::PerLengthDCLineParameter* element = dynamic_cast<IEC61970::Base::DC::PerLengthDCLineParameter*>(base_class_ptr))
	{
		buffer >> element->capacitance.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PerLengthDCLineParameter.inductance
bool assign_PerLengthDCLineParameter_inductance(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DC::PerLengthDCLineParameter* element = dynamic_cast<IEC61970::Base::DC::PerLengthDCLineParameter*>(base_class_ptr))
	{
		buffer >> element->inductance.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PerLengthDCLineParameter.resistance
bool assign_PerLengthDCLineParameter_resistance(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DC::PerLengthDCLineParameter* element = dynamic_cast<IEC61970::Base::DC::PerLengthDCLineParameter*>(base_class_ptr))
	{
		buffer >> element->resistance.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:VsConverter.delta
bool assign_VsConverter_delta(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DC::VsConverter* element = dynamic_cast<IEC61970::Base::DC::VsConverter*>(base_class_ptr))
	{
		buffer >> element->delta.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:VsConverter.droop
bool assign_VsConverter_droop(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DC::VsConverter* element = dynamic_cast<IEC61970::Base::DC::VsConverter*>(base_class_ptr))
	{
		buffer >> element->droop.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:VsConverter.droopCompensation
bool assign_VsConverter_droopCompensation(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DC::VsConverter* element = dynamic_cast<IEC61970::Base::DC::VsConverter*>(base_class_ptr))
	{
		buffer >> element->droopCompensation.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:VsConverter.maxModulationIndex
bool assign_VsConverter_maxModulationIndex(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DC::VsConverter* element = dynamic_cast<IEC61970::Base::DC::VsConverter*>(base_class_ptr))
	{
		buffer >> element->maxModulationIndex;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:VsConverter.maxValveCurrent
bool assign_VsConverter_maxValveCurrent(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DC::VsConverter* element = dynamic_cast<IEC61970::Base::DC::VsConverter*>(base_class_ptr))
	{
		buffer >> element->maxValveCurrent.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:VsConverter.pPccControl
bool assign_VsConverter_pPccControl(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DC::VsConverter* element = dynamic_cast<IEC61970::Base::DC::VsConverter*>(base_class_ptr))
	{
		buffer >> element->pPccControl;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:VsConverter.qPccControl
bool assign_VsConverter_qPccControl(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DC::VsConverter* element = dynamic_cast<IEC61970::Base::DC::VsConverter*>(base_class_ptr))
	{
		buffer >> element->qPccControl;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:VsConverter.qShare
bool assign_VsConverter_qShare(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DC::VsConverter* element = dynamic_cast<IEC61970::Base::DC::VsConverter*>(base_class_ptr))
	{
		buffer >> element->qShare.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:VsConverter.targetQpcc
bool assign_VsConverter_targetQpcc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DC::VsConverter* element = dynamic_cast<IEC61970::Base::DC::VsConverter*>(base_class_ptr))
	{
		buffer >> element->targetQpcc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:VsConverter.targetUpcc
bool assign_VsConverter_targetUpcc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DC::VsConverter* element = dynamic_cast<IEC61970::Base::DC::VsConverter*>(base_class_ptr))
	{
		buffer >> element->targetUpcc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:VsConverter.uf
bool assign_VsConverter_uf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DC::VsConverter* element = dynamic_cast<IEC61970::Base::DC::VsConverter*>(base_class_ptr))
	{
		buffer >> element->uf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Diagram.orientation
bool assign_Diagram_orientation(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DiagramLayout::Diagram* element = dynamic_cast<IEC61970::Base::DiagramLayout::Diagram*>(base_class_ptr))
	{
		buffer >> element->orientation;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Diagram.x1InitialView
bool assign_Diagram_x1InitialView(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DiagramLayout::Diagram* element = dynamic_cast<IEC61970::Base::DiagramLayout::Diagram*>(base_class_ptr))
	{
		buffer >> element->x1InitialView;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Diagram.x2InitialView
bool assign_Diagram_x2InitialView(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DiagramLayout::Diagram* element = dynamic_cast<IEC61970::Base::DiagramLayout::Diagram*>(base_class_ptr))
	{
		buffer >> element->x2InitialView;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Diagram.y1InitialView
bool assign_Diagram_y1InitialView(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DiagramLayout::Diagram* element = dynamic_cast<IEC61970::Base::DiagramLayout::Diagram*>(base_class_ptr))
	{
		buffer >> element->y1InitialView;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Diagram.y2InitialView
bool assign_Diagram_y2InitialView(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DiagramLayout::Diagram* element = dynamic_cast<IEC61970::Base::DiagramLayout::Diagram*>(base_class_ptr))
	{
		buffer >> element->y2InitialView;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:VisibilityLayer.drawingOrder
bool assign_VisibilityLayer_drawingOrder(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DiagramLayout::VisibilityLayer* element = dynamic_cast<IEC61970::Base::DiagramLayout::VisibilityLayer*>(base_class_ptr))
	{
		buffer >> element->drawingOrder;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:DiagramObjectPoint.sequenceNumber
bool assign_DiagramObjectPoint_sequenceNumber(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DiagramLayout::DiagramObjectPoint* element = dynamic_cast<IEC61970::Base::DiagramLayout::DiagramObjectPoint*>(base_class_ptr))
	{
		buffer >> element->sequenceNumber;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:DiagramObjectPoint.xPosition
bool assign_DiagramObjectPoint_xPosition(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DiagramLayout::DiagramObjectPoint* element = dynamic_cast<IEC61970::Base::DiagramLayout::DiagramObjectPoint*>(base_class_ptr))
	{
		buffer >> element->xPosition;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:DiagramObjectPoint.yPosition
bool assign_DiagramObjectPoint_yPosition(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DiagramLayout::DiagramObjectPoint* element = dynamic_cast<IEC61970::Base::DiagramLayout::DiagramObjectPoint*>(base_class_ptr))
	{
		buffer >> element->yPosition;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:DiagramObjectPoint.zPosition
bool assign_DiagramObjectPoint_zPosition(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DiagramLayout::DiagramObjectPoint* element = dynamic_cast<IEC61970::Base::DiagramLayout::DiagramObjectPoint*>(base_class_ptr))
	{
		buffer >> element->zPosition;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:DiagramObject.drawingOrder
bool assign_DiagramObject_drawingOrder(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DiagramLayout::DiagramObject* element = dynamic_cast<IEC61970::Base::DiagramLayout::DiagramObject*>(base_class_ptr))
	{
		buffer >> element->drawingOrder;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:DiagramObject.isPolygon
bool assign_DiagramObject_isPolygon(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DiagramLayout::DiagramObject* element = dynamic_cast<IEC61970::Base::DiagramLayout::DiagramObject*>(base_class_ptr))
	{
		buffer >> element->isPolygon;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:DiagramObject.offsetX
bool assign_DiagramObject_offsetX(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DiagramLayout::DiagramObject* element = dynamic_cast<IEC61970::Base::DiagramLayout::DiagramObject*>(base_class_ptr))
	{
		buffer >> element->offsetX;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:DiagramObject.offsetY
bool assign_DiagramObject_offsetY(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DiagramLayout::DiagramObject* element = dynamic_cast<IEC61970::Base::DiagramLayout::DiagramObject*>(base_class_ptr))
	{
		buffer >> element->offsetY;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:DiagramObject.rotation
bool assign_DiagramObject_rotation(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DiagramLayout::DiagramObject* element = dynamic_cast<IEC61970::Base::DiagramLayout::DiagramObject*>(base_class_ptr))
	{
		buffer >> element->rotation.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TextDiagramObject.text
bool assign_TextDiagramObject_text(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::DiagramLayout::TextDiagramObject* element = dynamic_cast<IEC61970::Base::DiagramLayout::TextDiagramObject*>(base_class_ptr))
	{
		element->text = buffer.str();
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ActivePowerPerFrequency.multiplier
bool assign_ActivePowerPerFrequency_multiplier(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Domain::ActivePowerPerFrequency* element = dynamic_cast<IEC61970::Base::Domain::ActivePowerPerFrequency*>(base_class_ptr))
	{
		buffer >> element->multiplier;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Admittance.multiplier
bool assign_Admittance_multiplier(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Domain::Admittance* element = dynamic_cast<IEC61970::Base::Domain::Admittance*>(base_class_ptr))
	{
		buffer >> element->multiplier;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Area.multiplier
bool assign_Area_multiplier(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Domain::Area* element = dynamic_cast<IEC61970::Base::Domain::Area*>(base_class_ptr))
	{
		buffer >> element->multiplier;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Conductance.multiplier
bool assign_Conductance_multiplier(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Domain::Conductance* element = dynamic_cast<IEC61970::Base::Domain::Conductance*>(base_class_ptr))
	{
		buffer >> element->multiplier;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:CostPerEnergyUnit.multiplier
bool assign_CostPerEnergyUnit_multiplier(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Domain::CostPerEnergyUnit* element = dynamic_cast<IEC61970::Base::Domain::CostPerEnergyUnit*>(base_class_ptr))
	{
		buffer >> element->multiplier;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:CostPerEnergyUnit.unit
bool assign_CostPerEnergyUnit_unit(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Domain::CostPerEnergyUnit* element = dynamic_cast<IEC61970::Base::Domain::CostPerEnergyUnit*>(base_class_ptr))
	{
		buffer >> element->unit;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:CostPerVolume.multiplier
bool assign_CostPerVolume_multiplier(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Domain::CostPerVolume* element = dynamic_cast<IEC61970::Base::Domain::CostPerVolume*>(base_class_ptr))
	{
		buffer >> element->multiplier;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:CostPerVolume.unit
bool assign_CostPerVolume_unit(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Domain::CostPerVolume* element = dynamic_cast<IEC61970::Base::Domain::CostPerVolume*>(base_class_ptr))
	{
		buffer >> element->unit;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:CostRate.multiplier
bool assign_CostRate_multiplier(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Domain::CostRate* element = dynamic_cast<IEC61970::Base::Domain::CostRate*>(base_class_ptr))
	{
		buffer >> element->multiplier;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:CostRate.unit
bool assign_CostRate_unit(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Domain::CostRate* element = dynamic_cast<IEC61970::Base::Domain::CostRate*>(base_class_ptr))
	{
		buffer >> element->unit;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:DateInterval.end
bool assign_DateInterval_end(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Domain::DateInterval* element = dynamic_cast<IEC61970::Base::Domain::DateInterval*>(base_class_ptr))
	{
		element->end.value = buffer.str();
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:DateInterval.start
bool assign_DateInterval_start(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Domain::DateInterval* element = dynamic_cast<IEC61970::Base::Domain::DateInterval*>(base_class_ptr))
	{
		element->start.value = buffer.str();
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:DateTimeInterval.end
bool assign_DateTimeInterval_end(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Domain::DateTimeInterval* element = dynamic_cast<IEC61970::Base::Domain::DateTimeInterval*>(base_class_ptr))
	{
		element->end.value = buffer.str();
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:DateTimeInterval.start
bool assign_DateTimeInterval_start(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Domain::DateTimeInterval* element = dynamic_cast<IEC61970::Base::Domain::DateTimeInterval*>(base_class_ptr))
	{
		element->start.value = buffer.str();
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:DecimalQuantity.currency
bool assign_DecimalQuantity_currency(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Domain::DecimalQuantity* element = dynamic_cast<IEC61970::Base::Domain::DecimalQuantity*>(base_class_ptr))
	{
		buffer >> element->currency;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:DecimalQuantity.multiplier
bool assign_DecimalQuantity_multiplier(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Domain::DecimalQuantity* element = dynamic_cast<IEC61970::Base::Domain::DecimalQuantity*>(base_class_ptr))
	{
		buffer >> element->multiplier;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:DecimalQuantity.unit
bool assign_DecimalQuantity_unit(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Domain::DecimalQuantity* element = dynamic_cast<IEC61970::Base::Domain::DecimalQuantity*>(base_class_ptr))
	{
		buffer >> element->unit;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:FloatQuantity.multiplier
bool assign_FloatQuantity_multiplier(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Domain::FloatQuantity* element = dynamic_cast<IEC61970::Base::Domain::FloatQuantity*>(base_class_ptr))
	{
		buffer >> element->multiplier;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:FloatQuantity.unit
bool assign_FloatQuantity_unit(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Domain::FloatQuantity* element = dynamic_cast<IEC61970::Base::Domain::FloatQuantity*>(base_class_ptr))
	{
		buffer >> element->unit;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Impedance.multiplier
bool assign_Impedance_multiplier(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Domain::Impedance* element = dynamic_cast<IEC61970::Base::Domain::Impedance*>(base_class_ptr))
	{
		buffer >> element->multiplier;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:IntegerQuantity.multiplier
bool assign_IntegerQuantity_multiplier(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Domain::IntegerQuantity* element = dynamic_cast<IEC61970::Base::Domain::IntegerQuantity*>(base_class_ptr))
	{
		buffer >> element->multiplier;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:IntegerQuantity.unit
bool assign_IntegerQuantity_unit(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Domain::IntegerQuantity* element = dynamic_cast<IEC61970::Base::Domain::IntegerQuantity*>(base_class_ptr))
	{
		buffer >> element->unit;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:MonthDayInterval.end
bool assign_MonthDayInterval_end(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Domain::MonthDayInterval* element = dynamic_cast<IEC61970::Base::Domain::MonthDayInterval*>(base_class_ptr))
	{
		element->end.value = buffer.str();
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:MonthDayInterval.start
bool assign_MonthDayInterval_start(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Domain::MonthDayInterval* element = dynamic_cast<IEC61970::Base::Domain::MonthDayInterval*>(base_class_ptr))
	{
		element->start.value = buffer.str();
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pressure.multiplier
bool assign_Pressure_multiplier(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Domain::Pressure* element = dynamic_cast<IEC61970::Base::Domain::Pressure*>(base_class_ptr))
	{
		buffer >> element->multiplier;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Reactance.multiplier
bool assign_Reactance_multiplier(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Domain::Reactance* element = dynamic_cast<IEC61970::Base::Domain::Reactance*>(base_class_ptr))
	{
		buffer >> element->multiplier;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:RealEnergy.multiplier
bool assign_RealEnergy_multiplier(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Domain::RealEnergy* element = dynamic_cast<IEC61970::Base::Domain::RealEnergy*>(base_class_ptr))
	{
		buffer >> element->multiplier;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:StringQuantity.multiplier
bool assign_StringQuantity_multiplier(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Domain::StringQuantity* element = dynamic_cast<IEC61970::Base::Domain::StringQuantity*>(base_class_ptr))
	{
		buffer >> element->multiplier;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:StringQuantity.unit
bool assign_StringQuantity_unit(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Domain::StringQuantity* element = dynamic_cast<IEC61970::Base::Domain::StringQuantity*>(base_class_ptr))
	{
		buffer >> element->unit;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Susceptance.multiplier
bool assign_Susceptance_multiplier(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Domain::Susceptance* element = dynamic_cast<IEC61970::Base::Domain::Susceptance*>(base_class_ptr))
	{
		buffer >> element->multiplier;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TimeInterval.end
bool assign_TimeInterval_end(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Domain::TimeInterval* element = dynamic_cast<IEC61970::Base::Domain::TimeInterval*>(base_class_ptr))
	{
		element->end.value = buffer.str();
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TimeInterval.start
bool assign_TimeInterval_start(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Domain::TimeInterval* element = dynamic_cast<IEC61970::Base::Domain::TimeInterval*>(base_class_ptr))
	{
		element->start.value = buffer.str();
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:VoltagePerReactivePower.multiplier
bool assign_VoltagePerReactivePower_multiplier(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Domain::VoltagePerReactivePower* element = dynamic_cast<IEC61970::Base::Domain::VoltagePerReactivePower*>(base_class_ptr))
	{
		buffer >> element->multiplier;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Volume.multiplier
bool assign_Volume_multiplier(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Domain::Volume* element = dynamic_cast<IEC61970::Base::Domain::Volume*>(base_class_ptr))
	{
		buffer >> element->multiplier;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WaterLevel.multiplier
bool assign_WaterLevel_multiplier(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Domain::WaterLevel* element = dynamic_cast<IEC61970::Base::Domain::WaterLevel*>(base_class_ptr))
	{
		buffer >> element->multiplier;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Weight.multiplier
bool assign_Weight_multiplier(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Domain::Weight* element = dynamic_cast<IEC61970::Base::Domain::Weight*>(base_class_ptr))
	{
		buffer >> element->multiplier;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EquivalentBranch.negativeR12
bool assign_EquivalentBranch_negativeR12(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Equivalents::EquivalentBranch* element = dynamic_cast<IEC61970::Base::Equivalents::EquivalentBranch*>(base_class_ptr))
	{
		buffer >> element->negativeR12.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EquivalentBranch.negativeR21
bool assign_EquivalentBranch_negativeR21(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Equivalents::EquivalentBranch* element = dynamic_cast<IEC61970::Base::Equivalents::EquivalentBranch*>(base_class_ptr))
	{
		buffer >> element->negativeR21.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EquivalentBranch.negativeX12
bool assign_EquivalentBranch_negativeX12(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Equivalents::EquivalentBranch* element = dynamic_cast<IEC61970::Base::Equivalents::EquivalentBranch*>(base_class_ptr))
	{
		buffer >> element->negativeX12.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EquivalentBranch.negativeX21
bool assign_EquivalentBranch_negativeX21(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Equivalents::EquivalentBranch* element = dynamic_cast<IEC61970::Base::Equivalents::EquivalentBranch*>(base_class_ptr))
	{
		buffer >> element->negativeX21.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EquivalentBranch.positiveR12
bool assign_EquivalentBranch_positiveR12(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Equivalents::EquivalentBranch* element = dynamic_cast<IEC61970::Base::Equivalents::EquivalentBranch*>(base_class_ptr))
	{
		buffer >> element->positiveR12.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EquivalentBranch.positiveR21
bool assign_EquivalentBranch_positiveR21(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Equivalents::EquivalentBranch* element = dynamic_cast<IEC61970::Base::Equivalents::EquivalentBranch*>(base_class_ptr))
	{
		buffer >> element->positiveR21.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EquivalentBranch.positiveX12
bool assign_EquivalentBranch_positiveX12(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Equivalents::EquivalentBranch* element = dynamic_cast<IEC61970::Base::Equivalents::EquivalentBranch*>(base_class_ptr))
	{
		buffer >> element->positiveX12.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EquivalentBranch.positiveX21
bool assign_EquivalentBranch_positiveX21(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Equivalents::EquivalentBranch* element = dynamic_cast<IEC61970::Base::Equivalents::EquivalentBranch*>(base_class_ptr))
	{
		buffer >> element->positiveX21.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EquivalentBranch.r
bool assign_EquivalentBranch_r(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Equivalents::EquivalentBranch* element = dynamic_cast<IEC61970::Base::Equivalents::EquivalentBranch*>(base_class_ptr))
	{
		buffer >> element->r.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EquivalentBranch.r21
bool assign_EquivalentBranch_r21(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Equivalents::EquivalentBranch* element = dynamic_cast<IEC61970::Base::Equivalents::EquivalentBranch*>(base_class_ptr))
	{
		buffer >> element->r21.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EquivalentBranch.x
bool assign_EquivalentBranch_x(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Equivalents::EquivalentBranch* element = dynamic_cast<IEC61970::Base::Equivalents::EquivalentBranch*>(base_class_ptr))
	{
		buffer >> element->x.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EquivalentBranch.x21
bool assign_EquivalentBranch_x21(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Equivalents::EquivalentBranch* element = dynamic_cast<IEC61970::Base::Equivalents::EquivalentBranch*>(base_class_ptr))
	{
		buffer >> element->x21.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EquivalentBranch.zeroR12
bool assign_EquivalentBranch_zeroR12(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Equivalents::EquivalentBranch* element = dynamic_cast<IEC61970::Base::Equivalents::EquivalentBranch*>(base_class_ptr))
	{
		buffer >> element->zeroR12.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EquivalentBranch.zeroR21
bool assign_EquivalentBranch_zeroR21(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Equivalents::EquivalentBranch* element = dynamic_cast<IEC61970::Base::Equivalents::EquivalentBranch*>(base_class_ptr))
	{
		buffer >> element->zeroR21.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EquivalentBranch.zeroX12
bool assign_EquivalentBranch_zeroX12(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Equivalents::EquivalentBranch* element = dynamic_cast<IEC61970::Base::Equivalents::EquivalentBranch*>(base_class_ptr))
	{
		buffer >> element->zeroX12.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EquivalentBranch.zeroX21
bool assign_EquivalentBranch_zeroX21(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Equivalents::EquivalentBranch* element = dynamic_cast<IEC61970::Base::Equivalents::EquivalentBranch*>(base_class_ptr))
	{
		buffer >> element->zeroX21.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EquivalentInjection.maxP
bool assign_EquivalentInjection_maxP(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Equivalents::EquivalentInjection* element = dynamic_cast<IEC61970::Base::Equivalents::EquivalentInjection*>(base_class_ptr))
	{
		buffer >> element->maxP.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EquivalentInjection.maxQ
bool assign_EquivalentInjection_maxQ(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Equivalents::EquivalentInjection* element = dynamic_cast<IEC61970::Base::Equivalents::EquivalentInjection*>(base_class_ptr))
	{
		buffer >> element->maxQ.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EquivalentInjection.minP
bool assign_EquivalentInjection_minP(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Equivalents::EquivalentInjection* element = dynamic_cast<IEC61970::Base::Equivalents::EquivalentInjection*>(base_class_ptr))
	{
		buffer >> element->minP.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EquivalentInjection.minQ
bool assign_EquivalentInjection_minQ(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Equivalents::EquivalentInjection* element = dynamic_cast<IEC61970::Base::Equivalents::EquivalentInjection*>(base_class_ptr))
	{
		buffer >> element->minQ.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EquivalentInjection.p
bool assign_EquivalentInjection_p(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Equivalents::EquivalentInjection* element = dynamic_cast<IEC61970::Base::Equivalents::EquivalentInjection*>(base_class_ptr))
	{
		buffer >> element->p.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EquivalentInjection.q
bool assign_EquivalentInjection_q(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Equivalents::EquivalentInjection* element = dynamic_cast<IEC61970::Base::Equivalents::EquivalentInjection*>(base_class_ptr))
	{
		buffer >> element->q.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EquivalentInjection.r
bool assign_EquivalentInjection_r(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Equivalents::EquivalentInjection* element = dynamic_cast<IEC61970::Base::Equivalents::EquivalentInjection*>(base_class_ptr))
	{
		buffer >> element->r.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EquivalentInjection.r0
bool assign_EquivalentInjection_r0(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Equivalents::EquivalentInjection* element = dynamic_cast<IEC61970::Base::Equivalents::EquivalentInjection*>(base_class_ptr))
	{
		buffer >> element->r0.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EquivalentInjection.r2
bool assign_EquivalentInjection_r2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Equivalents::EquivalentInjection* element = dynamic_cast<IEC61970::Base::Equivalents::EquivalentInjection*>(base_class_ptr))
	{
		buffer >> element->r2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EquivalentInjection.regulationCapability
bool assign_EquivalentInjection_regulationCapability(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Equivalents::EquivalentInjection* element = dynamic_cast<IEC61970::Base::Equivalents::EquivalentInjection*>(base_class_ptr))
	{
		buffer >> element->regulationCapability;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EquivalentInjection.regulationStatus
bool assign_EquivalentInjection_regulationStatus(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Equivalents::EquivalentInjection* element = dynamic_cast<IEC61970::Base::Equivalents::EquivalentInjection*>(base_class_ptr))
	{
		buffer >> element->regulationStatus;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EquivalentInjection.regulationTarget
bool assign_EquivalentInjection_regulationTarget(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Equivalents::EquivalentInjection* element = dynamic_cast<IEC61970::Base::Equivalents::EquivalentInjection*>(base_class_ptr))
	{
		buffer >> element->regulationTarget.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EquivalentInjection.x
bool assign_EquivalentInjection_x(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Equivalents::EquivalentInjection* element = dynamic_cast<IEC61970::Base::Equivalents::EquivalentInjection*>(base_class_ptr))
	{
		buffer >> element->x.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EquivalentInjection.x0
bool assign_EquivalentInjection_x0(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Equivalents::EquivalentInjection* element = dynamic_cast<IEC61970::Base::Equivalents::EquivalentInjection*>(base_class_ptr))
	{
		buffer >> element->x0.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EquivalentInjection.x2
bool assign_EquivalentInjection_x2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Equivalents::EquivalentInjection* element = dynamic_cast<IEC61970::Base::Equivalents::EquivalentInjection*>(base_class_ptr))
	{
		buffer >> element->x2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EquivalentShunt.b
bool assign_EquivalentShunt_b(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Equivalents::EquivalentShunt* element = dynamic_cast<IEC61970::Base::Equivalents::EquivalentShunt*>(base_class_ptr))
	{
		buffer >> element->b.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EquivalentShunt.g
bool assign_EquivalentShunt_g(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Equivalents::EquivalentShunt* element = dynamic_cast<IEC61970::Base::Equivalents::EquivalentShunt*>(base_class_ptr))
	{
		buffer >> element->g.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:FaultImpedance.rGround
bool assign_FaultImpedance_rGround(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Faults::FaultImpedance* element = dynamic_cast<IEC61970::Base::Faults::FaultImpedance*>(base_class_ptr))
	{
		buffer >> element->rGround.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:FaultImpedance.rLineToLine
bool assign_FaultImpedance_rLineToLine(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Faults::FaultImpedance* element = dynamic_cast<IEC61970::Base::Faults::FaultImpedance*>(base_class_ptr))
	{
		buffer >> element->rLineToLine.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:FaultImpedance.xGround
bool assign_FaultImpedance_xGround(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Faults::FaultImpedance* element = dynamic_cast<IEC61970::Base::Faults::FaultImpedance*>(base_class_ptr))
	{
		buffer >> element->xGround.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:FaultImpedance.xLineToLine
bool assign_FaultImpedance_xLineToLine(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Faults::FaultImpedance* element = dynamic_cast<IEC61970::Base::Faults::FaultImpedance*>(base_class_ptr))
	{
		buffer >> element->xLineToLine.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Fault.kind
bool assign_Fault_kind(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Faults::Fault* element = dynamic_cast<IEC61970::Base::Faults::Fault*>(base_class_ptr))
	{
		buffer >> element->kind;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Fault.phases
bool assign_Fault_phases(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Faults::Fault* element = dynamic_cast<IEC61970::Base::Faults::Fault*>(base_class_ptr))
	{
		buffer >> element->phases;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Conductor.length
bool assign_Conductor_length(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::Conductor* element = dynamic_cast<IEC61970::Base::Wires::Conductor*>(base_class_ptr))
	{
		buffer >> element->length.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Clamp.lengthFromTerminal1
bool assign_Clamp_lengthFromTerminal1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::Clamp* element = dynamic_cast<IEC61970::Base::Wires::Clamp*>(base_class_ptr))
	{
		buffer >> element->lengthFromTerminal1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ACLineSegment.b0ch
bool assign_ACLineSegment_b0ch(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::ACLineSegment* element = dynamic_cast<IEC61970::Base::Wires::ACLineSegment*>(base_class_ptr))
	{
		buffer >> element->b0ch.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ACLineSegment.bch
bool assign_ACLineSegment_bch(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::ACLineSegment* element = dynamic_cast<IEC61970::Base::Wires::ACLineSegment*>(base_class_ptr))
	{
		buffer >> element->bch.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ACLineSegment.g0ch
bool assign_ACLineSegment_g0ch(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::ACLineSegment* element = dynamic_cast<IEC61970::Base::Wires::ACLineSegment*>(base_class_ptr))
	{
		buffer >> element->g0ch.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ACLineSegment.gch
bool assign_ACLineSegment_gch(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::ACLineSegment* element = dynamic_cast<IEC61970::Base::Wires::ACLineSegment*>(base_class_ptr))
	{
		buffer >> element->gch.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ACLineSegment.r
bool assign_ACLineSegment_r(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::ACLineSegment* element = dynamic_cast<IEC61970::Base::Wires::ACLineSegment*>(base_class_ptr))
	{
		buffer >> element->r.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ACLineSegment.r0
bool assign_ACLineSegment_r0(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::ACLineSegment* element = dynamic_cast<IEC61970::Base::Wires::ACLineSegment*>(base_class_ptr))
	{
		buffer >> element->r0.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ACLineSegment.shortCircuitEndTemperature
bool assign_ACLineSegment_shortCircuitEndTemperature(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::ACLineSegment* element = dynamic_cast<IEC61970::Base::Wires::ACLineSegment*>(base_class_ptr))
	{
		buffer >> element->shortCircuitEndTemperature.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ACLineSegment.x
bool assign_ACLineSegment_x(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::ACLineSegment* element = dynamic_cast<IEC61970::Base::Wires::ACLineSegment*>(base_class_ptr))
	{
		buffer >> element->x.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ACLineSegment.x0
bool assign_ACLineSegment_x0(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::ACLineSegment* element = dynamic_cast<IEC61970::Base::Wires::ACLineSegment*>(base_class_ptr))
	{
		buffer >> element->x0.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LineFault.lengthFromTerminal1
bool assign_LineFault_lengthFromTerminal1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Faults::LineFault* element = dynamic_cast<IEC61970::Base::Faults::LineFault*>(base_class_ptr))
	{
		buffer >> element->lengthFromTerminal1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachine.aVRToManualLag
bool assign_SynchronousMachine_aVRToManualLag(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::SynchronousMachine* element = dynamic_cast<IEC61970::Base::Wires::SynchronousMachine*>(base_class_ptr))
	{
		buffer >> element->aVRToManualLag.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachine.aVRToManualLead
bool assign_SynchronousMachine_aVRToManualLead(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::SynchronousMachine* element = dynamic_cast<IEC61970::Base::Wires::SynchronousMachine*>(base_class_ptr))
	{
		buffer >> element->aVRToManualLead.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachine.baseQ
bool assign_SynchronousMachine_baseQ(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::SynchronousMachine* element = dynamic_cast<IEC61970::Base::Wires::SynchronousMachine*>(base_class_ptr))
	{
		buffer >> element->baseQ.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachine.condenserP
bool assign_SynchronousMachine_condenserP(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::SynchronousMachine* element = dynamic_cast<IEC61970::Base::Wires::SynchronousMachine*>(base_class_ptr))
	{
		buffer >> element->condenserP.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachine.coolantCondition
bool assign_SynchronousMachine_coolantCondition(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::SynchronousMachine* element = dynamic_cast<IEC61970::Base::Wires::SynchronousMachine*>(base_class_ptr))
	{
		buffer >> element->coolantCondition;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachine.coolantType
bool assign_SynchronousMachine_coolantType(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::SynchronousMachine* element = dynamic_cast<IEC61970::Base::Wires::SynchronousMachine*>(base_class_ptr))
	{
		buffer >> element->coolantType;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachine.earthing
bool assign_SynchronousMachine_earthing(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::SynchronousMachine* element = dynamic_cast<IEC61970::Base::Wires::SynchronousMachine*>(base_class_ptr))
	{
		buffer >> element->earthing;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachine.earthingStarPointR
bool assign_SynchronousMachine_earthingStarPointR(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::SynchronousMachine* element = dynamic_cast<IEC61970::Base::Wires::SynchronousMachine*>(base_class_ptr))
	{
		buffer >> element->earthingStarPointR.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachine.earthingStarPointX
bool assign_SynchronousMachine_earthingStarPointX(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::SynchronousMachine* element = dynamic_cast<IEC61970::Base::Wires::SynchronousMachine*>(base_class_ptr))
	{
		buffer >> element->earthingStarPointX.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachine.ikk
bool assign_SynchronousMachine_ikk(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::SynchronousMachine* element = dynamic_cast<IEC61970::Base::Wires::SynchronousMachine*>(base_class_ptr))
	{
		buffer >> element->ikk.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachine.manualToAVR
bool assign_SynchronousMachine_manualToAVR(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::SynchronousMachine* element = dynamic_cast<IEC61970::Base::Wires::SynchronousMachine*>(base_class_ptr))
	{
		buffer >> element->manualToAVR.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachine.maxQ
bool assign_SynchronousMachine_maxQ(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::SynchronousMachine* element = dynamic_cast<IEC61970::Base::Wires::SynchronousMachine*>(base_class_ptr))
	{
		buffer >> element->maxQ.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachine.maxU
bool assign_SynchronousMachine_maxU(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::SynchronousMachine* element = dynamic_cast<IEC61970::Base::Wires::SynchronousMachine*>(base_class_ptr))
	{
		buffer >> element->maxU.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachine.minQ
bool assign_SynchronousMachine_minQ(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::SynchronousMachine* element = dynamic_cast<IEC61970::Base::Wires::SynchronousMachine*>(base_class_ptr))
	{
		buffer >> element->minQ.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachine.minU
bool assign_SynchronousMachine_minU(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::SynchronousMachine* element = dynamic_cast<IEC61970::Base::Wires::SynchronousMachine*>(base_class_ptr))
	{
		buffer >> element->minU.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachine.mu
bool assign_SynchronousMachine_mu(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::SynchronousMachine* element = dynamic_cast<IEC61970::Base::Wires::SynchronousMachine*>(base_class_ptr))
	{
		buffer >> element->mu;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachine.operatingMode
bool assign_SynchronousMachine_operatingMode(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::SynchronousMachine* element = dynamic_cast<IEC61970::Base::Wires::SynchronousMachine*>(base_class_ptr))
	{
		buffer >> element->operatingMode;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachine.qPercent
bool assign_SynchronousMachine_qPercent(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::SynchronousMachine* element = dynamic_cast<IEC61970::Base::Wires::SynchronousMachine*>(base_class_ptr))
	{
		buffer >> element->qPercent.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachine.r
bool assign_SynchronousMachine_r(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::SynchronousMachine* element = dynamic_cast<IEC61970::Base::Wires::SynchronousMachine*>(base_class_ptr))
	{
		buffer >> element->r.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachine.r0
bool assign_SynchronousMachine_r0(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::SynchronousMachine* element = dynamic_cast<IEC61970::Base::Wires::SynchronousMachine*>(base_class_ptr))
	{
		buffer >> element->r0.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachine.r2
bool assign_SynchronousMachine_r2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::SynchronousMachine* element = dynamic_cast<IEC61970::Base::Wires::SynchronousMachine*>(base_class_ptr))
	{
		buffer >> element->r2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachine.referencePriority
bool assign_SynchronousMachine_referencePriority(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::SynchronousMachine* element = dynamic_cast<IEC61970::Base::Wires::SynchronousMachine*>(base_class_ptr))
	{
		buffer >> element->referencePriority;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachine.satDirectSubtransX
bool assign_SynchronousMachine_satDirectSubtransX(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::SynchronousMachine* element = dynamic_cast<IEC61970::Base::Wires::SynchronousMachine*>(base_class_ptr))
	{
		buffer >> element->satDirectSubtransX.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachine.satDirectSyncX
bool assign_SynchronousMachine_satDirectSyncX(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::SynchronousMachine* element = dynamic_cast<IEC61970::Base::Wires::SynchronousMachine*>(base_class_ptr))
	{
		buffer >> element->satDirectSyncX.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachine.satDirectTransX
bool assign_SynchronousMachine_satDirectTransX(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::SynchronousMachine* element = dynamic_cast<IEC61970::Base::Wires::SynchronousMachine*>(base_class_ptr))
	{
		buffer >> element->satDirectTransX.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachine.shortCircuitRotorType
bool assign_SynchronousMachine_shortCircuitRotorType(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::SynchronousMachine* element = dynamic_cast<IEC61970::Base::Wires::SynchronousMachine*>(base_class_ptr))
	{
		buffer >> element->shortCircuitRotorType;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachine.type
bool assign_SynchronousMachine_type(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::SynchronousMachine* element = dynamic_cast<IEC61970::Base::Wires::SynchronousMachine*>(base_class_ptr))
	{
		buffer >> element->type;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachine.voltageRegulationRange
bool assign_SynchronousMachine_voltageRegulationRange(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::SynchronousMachine* element = dynamic_cast<IEC61970::Base::Wires::SynchronousMachine*>(base_class_ptr))
	{
		buffer >> element->voltageRegulationRange.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachine.x0
bool assign_SynchronousMachine_x0(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::SynchronousMachine* element = dynamic_cast<IEC61970::Base::Wires::SynchronousMachine*>(base_class_ptr))
	{
		buffer >> element->x0.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachine.x2
bool assign_SynchronousMachine_x2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::SynchronousMachine* element = dynamic_cast<IEC61970::Base::Wires::SynchronousMachine*>(base_class_ptr))
	{
		buffer >> element->x2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PrimeMover.primeMoverRating
bool assign_PrimeMover_primeMoverRating(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::PrimeMover* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::PrimeMover*>(base_class_ptr))
	{
		buffer >> element->primeMoverRating;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SteamTurbine.crossoverTC
bool assign_SteamTurbine_crossoverTC(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::SteamTurbine* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::SteamTurbine*>(base_class_ptr))
	{
		buffer >> element->crossoverTC.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SteamTurbine.reheater1TC
bool assign_SteamTurbine_reheater1TC(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::SteamTurbine* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::SteamTurbine*>(base_class_ptr))
	{
		buffer >> element->reheater1TC.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SteamTurbine.reheater2TC
bool assign_SteamTurbine_reheater2TC(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::SteamTurbine* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::SteamTurbine*>(base_class_ptr))
	{
		buffer >> element->reheater2TC.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SteamTurbine.shaft1PowerHP
bool assign_SteamTurbine_shaft1PowerHP(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::SteamTurbine* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::SteamTurbine*>(base_class_ptr))
	{
		buffer >> element->shaft1PowerHP;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SteamTurbine.shaft1PowerIP
bool assign_SteamTurbine_shaft1PowerIP(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::SteamTurbine* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::SteamTurbine*>(base_class_ptr))
	{
		buffer >> element->shaft1PowerIP;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SteamTurbine.shaft1PowerLP1
bool assign_SteamTurbine_shaft1PowerLP1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::SteamTurbine* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::SteamTurbine*>(base_class_ptr))
	{
		buffer >> element->shaft1PowerLP1;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SteamTurbine.shaft1PowerLP2
bool assign_SteamTurbine_shaft1PowerLP2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::SteamTurbine* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::SteamTurbine*>(base_class_ptr))
	{
		buffer >> element->shaft1PowerLP2;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SteamTurbine.shaft2PowerHP
bool assign_SteamTurbine_shaft2PowerHP(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::SteamTurbine* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::SteamTurbine*>(base_class_ptr))
	{
		buffer >> element->shaft2PowerHP;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SteamTurbine.shaft2PowerIP
bool assign_SteamTurbine_shaft2PowerIP(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::SteamTurbine* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::SteamTurbine*>(base_class_ptr))
	{
		buffer >> element->shaft2PowerIP;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SteamTurbine.shaft2PowerLP1
bool assign_SteamTurbine_shaft2PowerLP1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::SteamTurbine* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::SteamTurbine*>(base_class_ptr))
	{
		buffer >> element->shaft2PowerLP1;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SteamTurbine.shaft2PowerLP2
bool assign_SteamTurbine_shaft2PowerLP2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::SteamTurbine* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::SteamTurbine*>(base_class_ptr))
	{
		buffer >> element->shaft2PowerLP2;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SteamTurbine.steamChestTC
bool assign_SteamTurbine_steamChestTC(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::SteamTurbine* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::SteamTurbine*>(base_class_ptr))
	{
		buffer >> element->steamChestTC.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SteamSupply.steamSupplyRating
bool assign_SteamSupply_steamSupplyRating(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::SteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::SteamSupply*>(base_class_ptr))
	{
		buffer >> element->steamSupplyRating;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:BWRSteamSupply.highPowerLimit
bool assign_BWRSteamSupply_highPowerLimit(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::BWRSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::BWRSteamSupply*>(base_class_ptr))
	{
		buffer >> element->highPowerLimit.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:BWRSteamSupply.inCoreThermalTC
bool assign_BWRSteamSupply_inCoreThermalTC(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::BWRSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::BWRSteamSupply*>(base_class_ptr))
	{
		buffer >> element->inCoreThermalTC.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:BWRSteamSupply.integralGain
bool assign_BWRSteamSupply_integralGain(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::BWRSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::BWRSteamSupply*>(base_class_ptr))
	{
		buffer >> element->integralGain;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:BWRSteamSupply.lowerLimit
bool assign_BWRSteamSupply_lowerLimit(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::BWRSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::BWRSteamSupply*>(base_class_ptr))
	{
		buffer >> element->lowerLimit.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:BWRSteamSupply.lowPowerLimit
bool assign_BWRSteamSupply_lowPowerLimit(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::BWRSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::BWRSteamSupply*>(base_class_ptr))
	{
		buffer >> element->lowPowerLimit.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:BWRSteamSupply.pressureLimit
bool assign_BWRSteamSupply_pressureLimit(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::BWRSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::BWRSteamSupply*>(base_class_ptr))
	{
		buffer >> element->pressureLimit.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:BWRSteamSupply.pressureSetpointGA
bool assign_BWRSteamSupply_pressureSetpointGA(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::BWRSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::BWRSteamSupply*>(base_class_ptr))
	{
		buffer >> element->pressureSetpointGA;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:BWRSteamSupply.pressureSetpointTC1
bool assign_BWRSteamSupply_pressureSetpointTC1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::BWRSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::BWRSteamSupply*>(base_class_ptr))
	{
		buffer >> element->pressureSetpointTC1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:BWRSteamSupply.pressureSetpointTC2
bool assign_BWRSteamSupply_pressureSetpointTC2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::BWRSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::BWRSteamSupply*>(base_class_ptr))
	{
		buffer >> element->pressureSetpointTC2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:BWRSteamSupply.proportionalGain
bool assign_BWRSteamSupply_proportionalGain(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::BWRSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::BWRSteamSupply*>(base_class_ptr))
	{
		buffer >> element->proportionalGain;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:BWRSteamSupply.rfAux1
bool assign_BWRSteamSupply_rfAux1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::BWRSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::BWRSteamSupply*>(base_class_ptr))
	{
		buffer >> element->rfAux1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:BWRSteamSupply.rfAux2
bool assign_BWRSteamSupply_rfAux2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::BWRSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::BWRSteamSupply*>(base_class_ptr))
	{
		buffer >> element->rfAux2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:BWRSteamSupply.rfAux3
bool assign_BWRSteamSupply_rfAux3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::BWRSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::BWRSteamSupply*>(base_class_ptr))
	{
		buffer >> element->rfAux3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:BWRSteamSupply.rfAux4
bool assign_BWRSteamSupply_rfAux4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::BWRSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::BWRSteamSupply*>(base_class_ptr))
	{
		buffer >> element->rfAux4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:BWRSteamSupply.rfAux5
bool assign_BWRSteamSupply_rfAux5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::BWRSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::BWRSteamSupply*>(base_class_ptr))
	{
		buffer >> element->rfAux5.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:BWRSteamSupply.rfAux6
bool assign_BWRSteamSupply_rfAux6(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::BWRSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::BWRSteamSupply*>(base_class_ptr))
	{
		buffer >> element->rfAux6.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:BWRSteamSupply.rfAux7
bool assign_BWRSteamSupply_rfAux7(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::BWRSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::BWRSteamSupply*>(base_class_ptr))
	{
		buffer >> element->rfAux7.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:BWRSteamSupply.rfAux8
bool assign_BWRSteamSupply_rfAux8(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::BWRSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::BWRSteamSupply*>(base_class_ptr))
	{
		buffer >> element->rfAux8.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:BWRSteamSupply.rodPattern
bool assign_BWRSteamSupply_rodPattern(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::BWRSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::BWRSteamSupply*>(base_class_ptr))
	{
		buffer >> element->rodPattern.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:BWRSteamSupply.rodPatternConstant
bool assign_BWRSteamSupply_rodPatternConstant(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::BWRSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::BWRSteamSupply*>(base_class_ptr))
	{
		buffer >> element->rodPatternConstant;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:BWRSteamSupply.upperLimit
bool assign_BWRSteamSupply_upperLimit(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::BWRSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::BWRSteamSupply*>(base_class_ptr))
	{
		buffer >> element->upperLimit.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:AirCompressor.airCompressorRating
bool assign_AirCompressor_airCompressorRating(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::AirCompressor* element = dynamic_cast<IEC61970::Base::Generation::Production::AirCompressor*>(base_class_ptr))
	{
		buffer >> element->airCompressorRating;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:CombustionTurbine.ambientTemp
bool assign_CombustionTurbine_ambientTemp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::CombustionTurbine* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::CombustionTurbine*>(base_class_ptr))
	{
		buffer >> element->ambientTemp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:CombustionTurbine.auxPowerVersusFrequency
bool assign_CombustionTurbine_auxPowerVersusFrequency(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::CombustionTurbine* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::CombustionTurbine*>(base_class_ptr))
	{
		buffer >> element->auxPowerVersusFrequency.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:CombustionTurbine.auxPowerVersusVoltage
bool assign_CombustionTurbine_auxPowerVersusVoltage(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::CombustionTurbine* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::CombustionTurbine*>(base_class_ptr))
	{
		buffer >> element->auxPowerVersusVoltage.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:CombustionTurbine.capabilityVersusFrequency
bool assign_CombustionTurbine_capabilityVersusFrequency(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::CombustionTurbine* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::CombustionTurbine*>(base_class_ptr))
	{
		buffer >> element->capabilityVersusFrequency.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:CombustionTurbine.heatRecoveryFlag
bool assign_CombustionTurbine_heatRecoveryFlag(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::CombustionTurbine* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::CombustionTurbine*>(base_class_ptr))
	{
		buffer >> element->heatRecoveryFlag;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:CombustionTurbine.powerVariationByTemp
bool assign_CombustionTurbine_powerVariationByTemp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::CombustionTurbine* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::CombustionTurbine*>(base_class_ptr))
	{
		buffer >> element->powerVariationByTemp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:CombustionTurbine.referenceTemp
bool assign_CombustionTurbine_referenceTemp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::CombustionTurbine* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::CombustionTurbine*>(base_class_ptr))
	{
		buffer >> element->referenceTemp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:CombustionTurbine.timeConstant
bool assign_CombustionTurbine_timeConstant(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::CombustionTurbine* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::CombustionTurbine*>(base_class_ptr))
	{
		buffer >> element->timeConstant.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:FossilSteamSupply.auxPowerVersusFrequency
bool assign_FossilSteamSupply_auxPowerVersusFrequency(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::FossilSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::FossilSteamSupply*>(base_class_ptr))
	{
		buffer >> element->auxPowerVersusFrequency.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:FossilSteamSupply.auxPowerVersusVoltage
bool assign_FossilSteamSupply_auxPowerVersusVoltage(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::FossilSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::FossilSteamSupply*>(base_class_ptr))
	{
		buffer >> element->auxPowerVersusVoltage.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:FossilSteamSupply.boilerControlMode
bool assign_FossilSteamSupply_boilerControlMode(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::FossilSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::FossilSteamSupply*>(base_class_ptr))
	{
		buffer >> element->boilerControlMode;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:FossilSteamSupply.controlErrorBiasP
bool assign_FossilSteamSupply_controlErrorBiasP(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::FossilSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::FossilSteamSupply*>(base_class_ptr))
	{
		buffer >> element->controlErrorBiasP;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:FossilSteamSupply.controlIC
bool assign_FossilSteamSupply_controlIC(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::FossilSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::FossilSteamSupply*>(base_class_ptr))
	{
		buffer >> element->controlIC;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:FossilSteamSupply.controlPC
bool assign_FossilSteamSupply_controlPC(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::FossilSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::FossilSteamSupply*>(base_class_ptr))
	{
		buffer >> element->controlPC;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:FossilSteamSupply.controlPEB
bool assign_FossilSteamSupply_controlPEB(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::FossilSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::FossilSteamSupply*>(base_class_ptr))
	{
		buffer >> element->controlPEB;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:FossilSteamSupply.controlPED
bool assign_FossilSteamSupply_controlPED(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::FossilSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::FossilSteamSupply*>(base_class_ptr))
	{
		buffer >> element->controlPED.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:FossilSteamSupply.controlTC
bool assign_FossilSteamSupply_controlTC(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::FossilSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::FossilSteamSupply*>(base_class_ptr))
	{
		buffer >> element->controlTC;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:FossilSteamSupply.feedWaterIG
bool assign_FossilSteamSupply_feedWaterIG(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::FossilSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::FossilSteamSupply*>(base_class_ptr))
	{
		buffer >> element->feedWaterIG;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:FossilSteamSupply.feedWaterPG
bool assign_FossilSteamSupply_feedWaterPG(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::FossilSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::FossilSteamSupply*>(base_class_ptr))
	{
		buffer >> element->feedWaterPG;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:FossilSteamSupply.feedWaterTC
bool assign_FossilSteamSupply_feedWaterTC(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::FossilSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::FossilSteamSupply*>(base_class_ptr))
	{
		buffer >> element->feedWaterTC.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:FossilSteamSupply.fuelDemandLimit
bool assign_FossilSteamSupply_fuelDemandLimit(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::FossilSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::FossilSteamSupply*>(base_class_ptr))
	{
		buffer >> element->fuelDemandLimit.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:FossilSteamSupply.fuelSupplyDelay
bool assign_FossilSteamSupply_fuelSupplyDelay(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::FossilSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::FossilSteamSupply*>(base_class_ptr))
	{
		buffer >> element->fuelSupplyDelay.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:FossilSteamSupply.fuelSupplyTC
bool assign_FossilSteamSupply_fuelSupplyTC(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::FossilSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::FossilSteamSupply*>(base_class_ptr))
	{
		buffer >> element->fuelSupplyTC.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:FossilSteamSupply.maxErrorRateP
bool assign_FossilSteamSupply_maxErrorRateP(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::FossilSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::FossilSteamSupply*>(base_class_ptr))
	{
		buffer >> element->maxErrorRateP;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:FossilSteamSupply.mechPowerSensorLag
bool assign_FossilSteamSupply_mechPowerSensorLag(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::FossilSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::FossilSteamSupply*>(base_class_ptr))
	{
		buffer >> element->mechPowerSensorLag.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:FossilSteamSupply.minErrorRateP
bool assign_FossilSteamSupply_minErrorRateP(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::FossilSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::FossilSteamSupply*>(base_class_ptr))
	{
		buffer >> element->minErrorRateP;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:FossilSteamSupply.pressureCtrlDG
bool assign_FossilSteamSupply_pressureCtrlDG(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::FossilSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::FossilSteamSupply*>(base_class_ptr))
	{
		buffer >> element->pressureCtrlDG;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:FossilSteamSupply.pressureCtrlIG
bool assign_FossilSteamSupply_pressureCtrlIG(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::FossilSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::FossilSteamSupply*>(base_class_ptr))
	{
		buffer >> element->pressureCtrlIG;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:FossilSteamSupply.pressureCtrlPG
bool assign_FossilSteamSupply_pressureCtrlPG(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::FossilSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::FossilSteamSupply*>(base_class_ptr))
	{
		buffer >> element->pressureCtrlPG;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:FossilSteamSupply.pressureFeedback
bool assign_FossilSteamSupply_pressureFeedback(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::FossilSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::FossilSteamSupply*>(base_class_ptr))
	{
		buffer >> element->pressureFeedback;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:FossilSteamSupply.superHeater1Capacity
bool assign_FossilSteamSupply_superHeater1Capacity(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::FossilSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::FossilSteamSupply*>(base_class_ptr))
	{
		buffer >> element->superHeater1Capacity;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:FossilSteamSupply.superHeater2Capacity
bool assign_FossilSteamSupply_superHeater2Capacity(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::FossilSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::FossilSteamSupply*>(base_class_ptr))
	{
		buffer >> element->superHeater2Capacity;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:FossilSteamSupply.superHeaterPipePD
bool assign_FossilSteamSupply_superHeaterPipePD(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::FossilSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::FossilSteamSupply*>(base_class_ptr))
	{
		buffer >> element->superHeaterPipePD;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:FossilSteamSupply.throttlePressureSP
bool assign_FossilSteamSupply_throttlePressureSP(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::FossilSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::FossilSteamSupply*>(base_class_ptr))
	{
		buffer >> element->throttlePressureSP.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:DrumBoiler.drumBoilerRating
bool assign_DrumBoiler_drumBoilerRating(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::DrumBoiler* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::DrumBoiler*>(base_class_ptr))
	{
		buffer >> element->drumBoilerRating;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:HeatRecoveryBoiler.steamSupplyRating2
bool assign_HeatRecoveryBoiler_steamSupplyRating2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::HeatRecoveryBoiler* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::HeatRecoveryBoiler*>(base_class_ptr))
	{
		buffer >> element->steamSupplyRating2;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:HydroTurbine.gateRateLimit
bool assign_HydroTurbine_gateRateLimit(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::HydroTurbine* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::HydroTurbine*>(base_class_ptr))
	{
		buffer >> element->gateRateLimit;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:HydroTurbine.gateUpperLimit
bool assign_HydroTurbine_gateUpperLimit(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::HydroTurbine* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::HydroTurbine*>(base_class_ptr))
	{
		buffer >> element->gateUpperLimit.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:HydroTurbine.maxHeadMaxP
bool assign_HydroTurbine_maxHeadMaxP(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::HydroTurbine* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::HydroTurbine*>(base_class_ptr))
	{
		buffer >> element->maxHeadMaxP.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:HydroTurbine.minHeadMaxP
bool assign_HydroTurbine_minHeadMaxP(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::HydroTurbine* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::HydroTurbine*>(base_class_ptr))
	{
		buffer >> element->minHeadMaxP.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:HydroTurbine.speedRating
bool assign_HydroTurbine_speedRating(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::HydroTurbine* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::HydroTurbine*>(base_class_ptr))
	{
		buffer >> element->speedRating.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:HydroTurbine.speedRegulation
bool assign_HydroTurbine_speedRegulation(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::HydroTurbine* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::HydroTurbine*>(base_class_ptr))
	{
		buffer >> element->speedRegulation.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:HydroTurbine.transientDroopTime
bool assign_HydroTurbine_transientDroopTime(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::HydroTurbine* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::HydroTurbine*>(base_class_ptr))
	{
		buffer >> element->transientDroopTime.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:HydroTurbine.transientRegulation
bool assign_HydroTurbine_transientRegulation(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::HydroTurbine* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::HydroTurbine*>(base_class_ptr))
	{
		buffer >> element->transientRegulation.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:HydroTurbine.turbineRating
bool assign_HydroTurbine_turbineRating(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::HydroTurbine* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::HydroTurbine*>(base_class_ptr))
	{
		buffer >> element->turbineRating.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:HydroTurbine.turbineType
bool assign_HydroTurbine_turbineType(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::HydroTurbine* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::HydroTurbine*>(base_class_ptr))
	{
		buffer >> element->turbineType;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:HydroTurbine.waterStartingTime
bool assign_HydroTurbine_waterStartingTime(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::HydroTurbine* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::HydroTurbine*>(base_class_ptr))
	{
		buffer >> element->waterStartingTime.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PWRSteamSupply.coldLegFBLagTC
bool assign_PWRSteamSupply_coldLegFBLagTC(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::PWRSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::PWRSteamSupply*>(base_class_ptr))
	{
		buffer >> element->coldLegFBLagTC.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PWRSteamSupply.coldLegFBLeadTC1
bool assign_PWRSteamSupply_coldLegFBLeadTC1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::PWRSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::PWRSteamSupply*>(base_class_ptr))
	{
		buffer >> element->coldLegFBLeadTC1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PWRSteamSupply.coldLegFBLeadTC2
bool assign_PWRSteamSupply_coldLegFBLeadTC2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::PWRSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::PWRSteamSupply*>(base_class_ptr))
	{
		buffer >> element->coldLegFBLeadTC2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PWRSteamSupply.coldLegFG1
bool assign_PWRSteamSupply_coldLegFG1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::PWRSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::PWRSteamSupply*>(base_class_ptr))
	{
		buffer >> element->coldLegFG1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PWRSteamSupply.coldLegFG2
bool assign_PWRSteamSupply_coldLegFG2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::PWRSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::PWRSteamSupply*>(base_class_ptr))
	{
		buffer >> element->coldLegFG2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PWRSteamSupply.coldLegLagTC
bool assign_PWRSteamSupply_coldLegLagTC(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::PWRSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::PWRSteamSupply*>(base_class_ptr))
	{
		buffer >> element->coldLegLagTC.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PWRSteamSupply.coreHTLagTC1
bool assign_PWRSteamSupply_coreHTLagTC1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::PWRSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::PWRSteamSupply*>(base_class_ptr))
	{
		buffer >> element->coreHTLagTC1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PWRSteamSupply.coreHTLagTC2
bool assign_PWRSteamSupply_coreHTLagTC2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::PWRSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::PWRSteamSupply*>(base_class_ptr))
	{
		buffer >> element->coreHTLagTC2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PWRSteamSupply.coreNeutronicsEffTC
bool assign_PWRSteamSupply_coreNeutronicsEffTC(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::PWRSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::PWRSteamSupply*>(base_class_ptr))
	{
		buffer >> element->coreNeutronicsEffTC.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PWRSteamSupply.coreNeutronicsHT
bool assign_PWRSteamSupply_coreNeutronicsHT(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::PWRSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::PWRSteamSupply*>(base_class_ptr))
	{
		buffer >> element->coreNeutronicsHT.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PWRSteamSupply.feedbackFactor
bool assign_PWRSteamSupply_feedbackFactor(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::PWRSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::PWRSteamSupply*>(base_class_ptr))
	{
		buffer >> element->feedbackFactor.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PWRSteamSupply.hotLegLagTC
bool assign_PWRSteamSupply_hotLegLagTC(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::PWRSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::PWRSteamSupply*>(base_class_ptr))
	{
		buffer >> element->hotLegLagTC.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PWRSteamSupply.hotLegSteamGain
bool assign_PWRSteamSupply_hotLegSteamGain(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::PWRSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::PWRSteamSupply*>(base_class_ptr))
	{
		buffer >> element->hotLegSteamGain.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PWRSteamSupply.hotLegToColdLegGain
bool assign_PWRSteamSupply_hotLegToColdLegGain(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::PWRSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::PWRSteamSupply*>(base_class_ptr))
	{
		buffer >> element->hotLegToColdLegGain.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PWRSteamSupply.pressureCG
bool assign_PWRSteamSupply_pressureCG(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::PWRSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::PWRSteamSupply*>(base_class_ptr))
	{
		buffer >> element->pressureCG.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PWRSteamSupply.steamFlowFG
bool assign_PWRSteamSupply_steamFlowFG(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::PWRSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::PWRSteamSupply*>(base_class_ptr))
	{
		buffer >> element->steamFlowFG.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PWRSteamSupply.steamPressureDropLagTC
bool assign_PWRSteamSupply_steamPressureDropLagTC(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::PWRSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::PWRSteamSupply*>(base_class_ptr))
	{
		buffer >> element->steamPressureDropLagTC.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PWRSteamSupply.steamPressureFG
bool assign_PWRSteamSupply_steamPressureFG(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::PWRSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::PWRSteamSupply*>(base_class_ptr))
	{
		buffer >> element->steamPressureFG.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PWRSteamSupply.throttlePressureFactor
bool assign_PWRSteamSupply_throttlePressureFactor(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::PWRSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::PWRSteamSupply*>(base_class_ptr))
	{
		buffer >> element->throttlePressureFactor.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PWRSteamSupply.throttlePressureSP
bool assign_PWRSteamSupply_throttlePressureSP(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::GenerationTrainingSimulation::PWRSteamSupply* element = dynamic_cast<IEC61970::Base::Generation::GenerationTrainingSimulation::PWRSteamSupply*>(base_class_ptr))
	{
		buffer >> element->throttlePressureSP.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:CostPerHeatUnit.multiplier
bool assign_CostPerHeatUnit_multiplier(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::CostPerHeatUnit* element = dynamic_cast<IEC61970::Base::Generation::Production::CostPerHeatUnit*>(base_class_ptr))
	{
		buffer >> element->multiplier;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:CostPerHeatUnit.unit
bool assign_CostPerHeatUnit_unit(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::CostPerHeatUnit* element = dynamic_cast<IEC61970::Base::Generation::Production::CostPerHeatUnit*>(base_class_ptr))
	{
		buffer >> element->unit;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:HeatRateCurve.isNetGrossP
bool assign_HeatRateCurve_isNetGrossP(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::HeatRateCurve* element = dynamic_cast<IEC61970::Base::Generation::Production::HeatRateCurve*>(base_class_ptr))
	{
		buffer >> element->isNetGrossP;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:FuelAllocationSchedule.fuelAllocationEndDate
bool assign_FuelAllocationSchedule_fuelAllocationEndDate(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::FuelAllocationSchedule* element = dynamic_cast<IEC61970::Base::Generation::Production::FuelAllocationSchedule*>(base_class_ptr))
	{
		element->fuelAllocationEndDate.value = buffer.str();
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:FuelAllocationSchedule.fuelAllocationStartDate
bool assign_FuelAllocationSchedule_fuelAllocationStartDate(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::FuelAllocationSchedule* element = dynamic_cast<IEC61970::Base::Generation::Production::FuelAllocationSchedule*>(base_class_ptr))
	{
		element->fuelAllocationStartDate.value = buffer.str();
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:FuelAllocationSchedule.fuelType
bool assign_FuelAllocationSchedule_fuelType(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::FuelAllocationSchedule* element = dynamic_cast<IEC61970::Base::Generation::Production::FuelAllocationSchedule*>(base_class_ptr))
	{
		buffer >> element->fuelType;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:FuelAllocationSchedule.maxFuelAllocation
bool assign_FuelAllocationSchedule_maxFuelAllocation(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::FuelAllocationSchedule* element = dynamic_cast<IEC61970::Base::Generation::Production::FuelAllocationSchedule*>(base_class_ptr))
	{
		buffer >> element->maxFuelAllocation;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:FuelAllocationSchedule.minFuelAllocation
bool assign_FuelAllocationSchedule_minFuelAllocation(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::FuelAllocationSchedule* element = dynamic_cast<IEC61970::Base::Generation::Production::FuelAllocationSchedule*>(base_class_ptr))
	{
		buffer >> element->minFuelAllocation;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:HeatRate.multiplier
bool assign_HeatRate_multiplier(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::HeatRate* element = dynamic_cast<IEC61970::Base::Generation::Production::HeatRate*>(base_class_ptr))
	{
		buffer >> element->multiplier;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:StartRampCurve.hotStandbyRamp
bool assign_StartRampCurve_hotStandbyRamp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::StartRampCurve* element = dynamic_cast<IEC61970::Base::Generation::Production::StartRampCurve*>(base_class_ptr))
	{
		buffer >> element->hotStandbyRamp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:StartIgnFuelCurve.ignitionFuelType
bool assign_StartIgnFuelCurve_ignitionFuelType(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::StartIgnFuelCurve* element = dynamic_cast<IEC61970::Base::Generation::Production::StartIgnFuelCurve*>(base_class_ptr))
	{
		buffer >> element->ignitionFuelType;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:StartMainFuelCurve.mainFuelType
bool assign_StartMainFuelCurve_mainFuelType(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::StartMainFuelCurve* element = dynamic_cast<IEC61970::Base::Generation::Production::StartMainFuelCurve*>(base_class_ptr))
	{
		buffer >> element->mainFuelType;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:StartupModel.fixedMaintCost
bool assign_StartupModel_fixedMaintCost(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::StartupModel* element = dynamic_cast<IEC61970::Base::Generation::Production::StartupModel*>(base_class_ptr))
	{
		buffer >> element->fixedMaintCost.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:StartupModel.hotStandbyHeat
bool assign_StartupModel_hotStandbyHeat(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::StartupModel* element = dynamic_cast<IEC61970::Base::Generation::Production::StartupModel*>(base_class_ptr))
	{
		buffer >> element->hotStandbyHeat.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:StartupModel.incrementalMaintCost
bool assign_StartupModel_incrementalMaintCost(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::StartupModel* element = dynamic_cast<IEC61970::Base::Generation::Production::StartupModel*>(base_class_ptr))
	{
		buffer >> element->incrementalMaintCost.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:StartupModel.minimumDownTime
bool assign_StartupModel_minimumDownTime(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::StartupModel* element = dynamic_cast<IEC61970::Base::Generation::Production::StartupModel*>(base_class_ptr))
	{
		buffer >> element->minimumDownTime.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:StartupModel.minimumRunTime
bool assign_StartupModel_minimumRunTime(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::StartupModel* element = dynamic_cast<IEC61970::Base::Generation::Production::StartupModel*>(base_class_ptr))
	{
		buffer >> element->minimumRunTime.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:StartupModel.riskFactorCost
bool assign_StartupModel_riskFactorCost(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::StartupModel* element = dynamic_cast<IEC61970::Base::Generation::Production::StartupModel*>(base_class_ptr))
	{
		buffer >> element->riskFactorCost.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:StartupModel.startupCost
bool assign_StartupModel_startupCost(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::StartupModel* element = dynamic_cast<IEC61970::Base::Generation::Production::StartupModel*>(base_class_ptr))
	{
		buffer >> element->startupCost.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:StartupModel.startupDate
bool assign_StartupModel_startupDate(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::StartupModel* element = dynamic_cast<IEC61970::Base::Generation::Production::StartupModel*>(base_class_ptr))
	{
		element->startupDate.value = buffer.str();
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:StartupModel.startupPriority
bool assign_StartupModel_startupPriority(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::StartupModel* element = dynamic_cast<IEC61970::Base::Generation::Production::StartupModel*>(base_class_ptr))
	{
		buffer >> element->startupPriority;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:StartupModel.stbyAuxP
bool assign_StartupModel_stbyAuxP(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::StartupModel* element = dynamic_cast<IEC61970::Base::Generation::Production::StartupModel*>(base_class_ptr))
	{
		buffer >> element->stbyAuxP.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EmissionCurve.emissionContent
bool assign_EmissionCurve_emissionContent(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::EmissionCurve* element = dynamic_cast<IEC61970::Base::Generation::Production::EmissionCurve*>(base_class_ptr))
	{
		buffer >> element->emissionContent.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EmissionCurve.emissionType
bool assign_EmissionCurve_emissionType(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::EmissionCurve* element = dynamic_cast<IEC61970::Base::Generation::Production::EmissionCurve*>(base_class_ptr))
	{
		buffer >> element->emissionType;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EmissionCurve.isNetGrossP
bool assign_EmissionCurve_isNetGrossP(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::EmissionCurve* element = dynamic_cast<IEC61970::Base::Generation::Production::EmissionCurve*>(base_class_ptr))
	{
		buffer >> element->isNetGrossP;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ShutdownCurve.shutdownCost
bool assign_ShutdownCurve_shutdownCost(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::ShutdownCurve* element = dynamic_cast<IEC61970::Base::Generation::Production::ShutdownCurve*>(base_class_ptr))
	{
		buffer >> element->shutdownCost.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ShutdownCurve.shutdownDate
bool assign_ShutdownCurve_shutdownDate(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::ShutdownCurve* element = dynamic_cast<IEC61970::Base::Generation::Production::ShutdownCurve*>(base_class_ptr))
	{
		element->shutdownDate.value = buffer.str();
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:IncrementalHeatRateCurve.isNetGrossP
bool assign_IncrementalHeatRateCurve_isNetGrossP(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::IncrementalHeatRateCurve* element = dynamic_cast<IEC61970::Base::Generation::Production::IncrementalHeatRateCurve*>(base_class_ptr))
	{
		buffer >> element->isNetGrossP;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EmissionAccount.emissionType
bool assign_EmissionAccount_emissionType(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::EmissionAccount* element = dynamic_cast<IEC61970::Base::Generation::Production::EmissionAccount*>(base_class_ptr))
	{
		buffer >> element->emissionType;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EmissionAccount.emissionValueSource
bool assign_EmissionAccount_emissionValueSource(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::EmissionAccount* element = dynamic_cast<IEC61970::Base::Generation::Production::EmissionAccount*>(base_class_ptr))
	{
		buffer >> element->emissionValueSource;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:HeatInputCurve.auxPowerMult
bool assign_HeatInputCurve_auxPowerMult(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::HeatInputCurve* element = dynamic_cast<IEC61970::Base::Generation::Production::HeatInputCurve*>(base_class_ptr))
	{
		buffer >> element->auxPowerMult.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:HeatInputCurve.auxPowerOffset
bool assign_HeatInputCurve_auxPowerOffset(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::HeatInputCurve* element = dynamic_cast<IEC61970::Base::Generation::Production::HeatInputCurve*>(base_class_ptr))
	{
		buffer >> element->auxPowerOffset.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:HeatInputCurve.heatInputEff
bool assign_HeatInputCurve_heatInputEff(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::HeatInputCurve* element = dynamic_cast<IEC61970::Base::Generation::Production::HeatInputCurve*>(base_class_ptr))
	{
		buffer >> element->heatInputEff.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:HeatInputCurve.heatInputOffset
bool assign_HeatInputCurve_heatInputOffset(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::HeatInputCurve* element = dynamic_cast<IEC61970::Base::Generation::Production::HeatInputCurve*>(base_class_ptr))
	{
		buffer >> element->heatInputOffset.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:HeatInputCurve.isNetGrossP
bool assign_HeatInputCurve_isNetGrossP(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::HeatInputCurve* element = dynamic_cast<IEC61970::Base::Generation::Production::HeatInputCurve*>(base_class_ptr))
	{
		buffer >> element->isNetGrossP;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ThermalGeneratingUnit.oMCost
bool assign_ThermalGeneratingUnit_oMCost(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::ThermalGeneratingUnit* element = dynamic_cast<IEC61970::Base::Generation::Production::ThermalGeneratingUnit*>(base_class_ptr))
	{
		buffer >> element->oMCost.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:CAESPlant.energyStorageCapacity
bool assign_CAESPlant_energyStorageCapacity(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::CAESPlant* element = dynamic_cast<IEC61970::Base::Generation::Production::CAESPlant*>(base_class_ptr))
	{
		buffer >> element->energyStorageCapacity.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:CAESPlant.ratedCapacityP
bool assign_CAESPlant_ratedCapacityP(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::CAESPlant* element = dynamic_cast<IEC61970::Base::Generation::Production::CAESPlant*>(base_class_ptr))
	{
		buffer >> element->ratedCapacityP.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:CogenerationPlant.cogenHPSendoutRating
bool assign_CogenerationPlant_cogenHPSendoutRating(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::CogenerationPlant* element = dynamic_cast<IEC61970::Base::Generation::Production::CogenerationPlant*>(base_class_ptr))
	{
		buffer >> element->cogenHPSendoutRating;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:CogenerationPlant.cogenHPSteamRating
bool assign_CogenerationPlant_cogenHPSteamRating(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::CogenerationPlant* element = dynamic_cast<IEC61970::Base::Generation::Production::CogenerationPlant*>(base_class_ptr))
	{
		buffer >> element->cogenHPSteamRating;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:CogenerationPlant.cogenLPSendoutRating
bool assign_CogenerationPlant_cogenLPSendoutRating(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::CogenerationPlant* element = dynamic_cast<IEC61970::Base::Generation::Production::CogenerationPlant*>(base_class_ptr))
	{
		buffer >> element->cogenLPSendoutRating;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:CogenerationPlant.cogenLPSteamRating
bool assign_CogenerationPlant_cogenLPSteamRating(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::CogenerationPlant* element = dynamic_cast<IEC61970::Base::Generation::Production::CogenerationPlant*>(base_class_ptr))
	{
		buffer >> element->cogenLPSteamRating;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:CogenerationPlant.ratedP
bool assign_CogenerationPlant_ratedP(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::CogenerationPlant* element = dynamic_cast<IEC61970::Base::Generation::Production::CogenerationPlant*>(base_class_ptr))
	{
		buffer >> element->ratedP.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:CombinedCyclePlant.combCyclePlantRating
bool assign_CombinedCyclePlant_combCyclePlantRating(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::CombinedCyclePlant* element = dynamic_cast<IEC61970::Base::Generation::Production::CombinedCyclePlant*>(base_class_ptr))
	{
		buffer >> element->combCyclePlantRating.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:FossilFuel.fossilFuelType
bool assign_FossilFuel_fossilFuelType(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::FossilFuel* element = dynamic_cast<IEC61970::Base::Generation::Production::FossilFuel*>(base_class_ptr))
	{
		buffer >> element->fossilFuelType;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:FossilFuel.fuelCost
bool assign_FossilFuel_fuelCost(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::FossilFuel* element = dynamic_cast<IEC61970::Base::Generation::Production::FossilFuel*>(base_class_ptr))
	{
		buffer >> element->fuelCost.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:FossilFuel.fuelDispatchCost
bool assign_FossilFuel_fuelDispatchCost(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::FossilFuel* element = dynamic_cast<IEC61970::Base::Generation::Production::FossilFuel*>(base_class_ptr))
	{
		buffer >> element->fuelDispatchCost.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:FossilFuel.fuelEffFactor
bool assign_FossilFuel_fuelEffFactor(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::FossilFuel* element = dynamic_cast<IEC61970::Base::Generation::Production::FossilFuel*>(base_class_ptr))
	{
		buffer >> element->fuelEffFactor.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:FossilFuel.fuelHandlingCost
bool assign_FossilFuel_fuelHandlingCost(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::FossilFuel* element = dynamic_cast<IEC61970::Base::Generation::Production::FossilFuel*>(base_class_ptr))
	{
		buffer >> element->fuelHandlingCost.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:FossilFuel.fuelHeatContent
bool assign_FossilFuel_fuelHeatContent(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::FossilFuel* element = dynamic_cast<IEC61970::Base::Generation::Production::FossilFuel*>(base_class_ptr))
	{
		buffer >> element->fuelHeatContent;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:FossilFuel.fuelMixture
bool assign_FossilFuel_fuelMixture(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::FossilFuel* element = dynamic_cast<IEC61970::Base::Generation::Production::FossilFuel*>(base_class_ptr))
	{
		buffer >> element->fuelMixture.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:FossilFuel.fuelSulfur
bool assign_FossilFuel_fuelSulfur(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::FossilFuel* element = dynamic_cast<IEC61970::Base::Generation::Production::FossilFuel*>(base_class_ptr))
	{
		buffer >> element->fuelSulfur.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:FossilFuel.highBreakpointP
bool assign_FossilFuel_highBreakpointP(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::FossilFuel* element = dynamic_cast<IEC61970::Base::Generation::Production::FossilFuel*>(base_class_ptr))
	{
		buffer >> element->highBreakpointP.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:FossilFuel.lowBreakpointP
bool assign_FossilFuel_lowBreakpointP(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::FossilFuel* element = dynamic_cast<IEC61970::Base::Generation::Production::FossilFuel*>(base_class_ptr))
	{
		buffer >> element->lowBreakpointP.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:HydroGeneratingUnit.energyConversionCapability
bool assign_HydroGeneratingUnit_energyConversionCapability(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::HydroGeneratingUnit* element = dynamic_cast<IEC61970::Base::Generation::Production::HydroGeneratingUnit*>(base_class_ptr))
	{
		buffer >> element->energyConversionCapability;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:HydroGeneratingUnit.hydroUnitWaterCost
bool assign_HydroGeneratingUnit_hydroUnitWaterCost(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::HydroGeneratingUnit* element = dynamic_cast<IEC61970::Base::Generation::Production::HydroGeneratingUnit*>(base_class_ptr))
	{
		buffer >> element->hydroUnitWaterCost.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TargetLevelSchedule.highLevelLimit
bool assign_TargetLevelSchedule_highLevelLimit(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::TargetLevelSchedule* element = dynamic_cast<IEC61970::Base::Generation::Production::TargetLevelSchedule*>(base_class_ptr))
	{
		buffer >> element->highLevelLimit.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TargetLevelSchedule.lowLevelLimit
bool assign_TargetLevelSchedule_lowLevelLimit(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::TargetLevelSchedule* element = dynamic_cast<IEC61970::Base::Generation::Production::TargetLevelSchedule*>(base_class_ptr))
	{
		buffer >> element->lowLevelLimit.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Reservoir.activeStorageCapacity
bool assign_Reservoir_activeStorageCapacity(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::Reservoir* element = dynamic_cast<IEC61970::Base::Generation::Production::Reservoir*>(base_class_ptr))
	{
		buffer >> element->activeStorageCapacity.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Reservoir.energyStorageRating
bool assign_Reservoir_energyStorageRating(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::Reservoir* element = dynamic_cast<IEC61970::Base::Generation::Production::Reservoir*>(base_class_ptr))
	{
		buffer >> element->energyStorageRating;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Reservoir.fullSupplyLevel
bool assign_Reservoir_fullSupplyLevel(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::Reservoir* element = dynamic_cast<IEC61970::Base::Generation::Production::Reservoir*>(base_class_ptr))
	{
		buffer >> element->fullSupplyLevel.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Reservoir.grossCapacity
bool assign_Reservoir_grossCapacity(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::Reservoir* element = dynamic_cast<IEC61970::Base::Generation::Production::Reservoir*>(base_class_ptr))
	{
		buffer >> element->grossCapacity.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Reservoir.normalMinOperateLevel
bool assign_Reservoir_normalMinOperateLevel(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::Reservoir* element = dynamic_cast<IEC61970::Base::Generation::Production::Reservoir*>(base_class_ptr))
	{
		buffer >> element->normalMinOperateLevel.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Reservoir.riverOutletWorks
bool assign_Reservoir_riverOutletWorks(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::Reservoir* element = dynamic_cast<IEC61970::Base::Generation::Production::Reservoir*>(base_class_ptr))
	{
		element->riverOutletWorks = buffer.str();
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Reservoir.spillTravelDelay
bool assign_Reservoir_spillTravelDelay(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::Reservoir* element = dynamic_cast<IEC61970::Base::Generation::Production::Reservoir*>(base_class_ptr))
	{
		buffer >> element->spillTravelDelay.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Reservoir.spillwayCapacity
bool assign_Reservoir_spillwayCapacity(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::Reservoir* element = dynamic_cast<IEC61970::Base::Generation::Production::Reservoir*>(base_class_ptr))
	{
		buffer >> element->spillwayCapacity;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Reservoir.spillwayCrestLength
bool assign_Reservoir_spillwayCrestLength(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::Reservoir* element = dynamic_cast<IEC61970::Base::Generation::Production::Reservoir*>(base_class_ptr))
	{
		buffer >> element->spillwayCrestLength.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Reservoir.spillwayCrestLevel
bool assign_Reservoir_spillwayCrestLevel(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::Reservoir* element = dynamic_cast<IEC61970::Base::Generation::Production::Reservoir*>(base_class_ptr))
	{
		buffer >> element->spillwayCrestLevel.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Reservoir.spillWayGateType
bool assign_Reservoir_spillWayGateType(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::Reservoir* element = dynamic_cast<IEC61970::Base::Generation::Production::Reservoir*>(base_class_ptr))
	{
		element->spillWayGateType = buffer.str();
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:HydroPowerPlant.dischargeTravelDelay
bool assign_HydroPowerPlant_dischargeTravelDelay(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::HydroPowerPlant* element = dynamic_cast<IEC61970::Base::Generation::Production::HydroPowerPlant*>(base_class_ptr))
	{
		buffer >> element->dischargeTravelDelay.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:HydroPowerPlant.genRatedP
bool assign_HydroPowerPlant_genRatedP(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::HydroPowerPlant* element = dynamic_cast<IEC61970::Base::Generation::Production::HydroPowerPlant*>(base_class_ptr))
	{
		buffer >> element->genRatedP.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:HydroPowerPlant.hydroPlantStorageType
bool assign_HydroPowerPlant_hydroPlantStorageType(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::HydroPowerPlant* element = dynamic_cast<IEC61970::Base::Generation::Production::HydroPowerPlant*>(base_class_ptr))
	{
		buffer >> element->hydroPlantStorageType;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:HydroPowerPlant.penstockType
bool assign_HydroPowerPlant_penstockType(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::HydroPowerPlant* element = dynamic_cast<IEC61970::Base::Generation::Production::HydroPowerPlant*>(base_class_ptr))
	{
		element->penstockType = buffer.str();
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:HydroPowerPlant.plantDischargeCapacity
bool assign_HydroPowerPlant_plantDischargeCapacity(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::HydroPowerPlant* element = dynamic_cast<IEC61970::Base::Generation::Production::HydroPowerPlant*>(base_class_ptr))
	{
		buffer >> element->plantDischargeCapacity.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:HydroPowerPlant.plantRatedHead
bool assign_HydroPowerPlant_plantRatedHead(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::HydroPowerPlant* element = dynamic_cast<IEC61970::Base::Generation::Production::HydroPowerPlant*>(base_class_ptr))
	{
		buffer >> element->plantRatedHead.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:HydroPowerPlant.pumpRatedP
bool assign_HydroPowerPlant_pumpRatedP(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::HydroPowerPlant* element = dynamic_cast<IEC61970::Base::Generation::Production::HydroPowerPlant*>(base_class_ptr))
	{
		buffer >> element->pumpRatedP.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:HydroPowerPlant.surgeTankCode
bool assign_HydroPowerPlant_surgeTankCode(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::HydroPowerPlant* element = dynamic_cast<IEC61970::Base::Generation::Production::HydroPowerPlant*>(base_class_ptr))
	{
		element->surgeTankCode = buffer.str();
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:HydroPowerPlant.surgeTankCrestLevel
bool assign_HydroPowerPlant_surgeTankCrestLevel(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::HydroPowerPlant* element = dynamic_cast<IEC61970::Base::Generation::Production::HydroPowerPlant*>(base_class_ptr))
	{
		buffer >> element->surgeTankCrestLevel.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindGeneratingUnit.windGenUnitType
bool assign_WindGeneratingUnit_windGenUnitType(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Generation::Production::WindGeneratingUnit* element = dynamic_cast<IEC61970::Base::Generation::Production::WindGeneratingUnit*>(base_class_ptr))
	{
		buffer >> element->windGenUnitType;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadResponseCharacteristic.exponentModel
bool assign_LoadResponseCharacteristic_exponentModel(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::LoadModel::LoadResponseCharacteristic* element = dynamic_cast<IEC61970::Base::LoadModel::LoadResponseCharacteristic*>(base_class_ptr))
	{
		buffer >> element->exponentModel;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadResponseCharacteristic.pConstantCurrent
bool assign_LoadResponseCharacteristic_pConstantCurrent(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::LoadModel::LoadResponseCharacteristic* element = dynamic_cast<IEC61970::Base::LoadModel::LoadResponseCharacteristic*>(base_class_ptr))
	{
		buffer >> element->pConstantCurrent;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadResponseCharacteristic.pConstantImpedance
bool assign_LoadResponseCharacteristic_pConstantImpedance(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::LoadModel::LoadResponseCharacteristic* element = dynamic_cast<IEC61970::Base::LoadModel::LoadResponseCharacteristic*>(base_class_ptr))
	{
		buffer >> element->pConstantImpedance;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadResponseCharacteristic.pConstantPower
bool assign_LoadResponseCharacteristic_pConstantPower(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::LoadModel::LoadResponseCharacteristic* element = dynamic_cast<IEC61970::Base::LoadModel::LoadResponseCharacteristic*>(base_class_ptr))
	{
		buffer >> element->pConstantPower;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadResponseCharacteristic.pFrequencyExponent
bool assign_LoadResponseCharacteristic_pFrequencyExponent(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::LoadModel::LoadResponseCharacteristic* element = dynamic_cast<IEC61970::Base::LoadModel::LoadResponseCharacteristic*>(base_class_ptr))
	{
		buffer >> element->pFrequencyExponent;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadResponseCharacteristic.pVoltageExponent
bool assign_LoadResponseCharacteristic_pVoltageExponent(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::LoadModel::LoadResponseCharacteristic* element = dynamic_cast<IEC61970::Base::LoadModel::LoadResponseCharacteristic*>(base_class_ptr))
	{
		buffer >> element->pVoltageExponent;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadResponseCharacteristic.qConstantCurrent
bool assign_LoadResponseCharacteristic_qConstantCurrent(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::LoadModel::LoadResponseCharacteristic* element = dynamic_cast<IEC61970::Base::LoadModel::LoadResponseCharacteristic*>(base_class_ptr))
	{
		buffer >> element->qConstantCurrent;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadResponseCharacteristic.qConstantImpedance
bool assign_LoadResponseCharacteristic_qConstantImpedance(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::LoadModel::LoadResponseCharacteristic* element = dynamic_cast<IEC61970::Base::LoadModel::LoadResponseCharacteristic*>(base_class_ptr))
	{
		buffer >> element->qConstantImpedance;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadResponseCharacteristic.qConstantPower
bool assign_LoadResponseCharacteristic_qConstantPower(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::LoadModel::LoadResponseCharacteristic* element = dynamic_cast<IEC61970::Base::LoadModel::LoadResponseCharacteristic*>(base_class_ptr))
	{
		buffer >> element->qConstantPower;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadResponseCharacteristic.qFrequencyExponent
bool assign_LoadResponseCharacteristic_qFrequencyExponent(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::LoadModel::LoadResponseCharacteristic* element = dynamic_cast<IEC61970::Base::LoadModel::LoadResponseCharacteristic*>(base_class_ptr))
	{
		buffer >> element->qFrequencyExponent;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadResponseCharacteristic.qVoltageExponent
bool assign_LoadResponseCharacteristic_qVoltageExponent(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::LoadModel::LoadResponseCharacteristic* element = dynamic_cast<IEC61970::Base::LoadModel::LoadResponseCharacteristic*>(base_class_ptr))
	{
		buffer >> element->qVoltageExponent;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EnergyConsumerPhase.pfixed
bool assign_EnergyConsumerPhase_pfixed(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::EnergyConsumerPhase* element = dynamic_cast<IEC61970::Base::Wires::EnergyConsumerPhase*>(base_class_ptr))
	{
		buffer >> element->pfixed.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EnergyConsumerPhase.pfixedPct
bool assign_EnergyConsumerPhase_pfixedPct(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::EnergyConsumerPhase* element = dynamic_cast<IEC61970::Base::Wires::EnergyConsumerPhase*>(base_class_ptr))
	{
		buffer >> element->pfixedPct.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EnergyConsumerPhase.phase
bool assign_EnergyConsumerPhase_phase(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::EnergyConsumerPhase* element = dynamic_cast<IEC61970::Base::Wires::EnergyConsumerPhase*>(base_class_ptr))
	{
		buffer >> element->phase;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EnergyConsumerPhase.qfixed
bool assign_EnergyConsumerPhase_qfixed(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::EnergyConsumerPhase* element = dynamic_cast<IEC61970::Base::Wires::EnergyConsumerPhase*>(base_class_ptr))
	{
		buffer >> element->qfixed.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EnergyConsumerPhase.qfixedPct
bool assign_EnergyConsumerPhase_qfixedPct(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::EnergyConsumerPhase* element = dynamic_cast<IEC61970::Base::Wires::EnergyConsumerPhase*>(base_class_ptr))
	{
		buffer >> element->qfixedPct.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EnergyConsumer.customerCount
bool assign_EnergyConsumer_customerCount(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::EnergyConsumer* element = dynamic_cast<IEC61970::Base::Wires::EnergyConsumer*>(base_class_ptr))
	{
		buffer >> element->customerCount;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EnergyConsumer.grounded
bool assign_EnergyConsumer_grounded(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::EnergyConsumer* element = dynamic_cast<IEC61970::Base::Wires::EnergyConsumer*>(base_class_ptr))
	{
		buffer >> element->grounded;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EnergyConsumer.p
bool assign_EnergyConsumer_p(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::EnergyConsumer* element = dynamic_cast<IEC61970::Base::Wires::EnergyConsumer*>(base_class_ptr))
	{
		buffer >> element->p.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EnergyConsumer.pfixed
bool assign_EnergyConsumer_pfixed(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::EnergyConsumer* element = dynamic_cast<IEC61970::Base::Wires::EnergyConsumer*>(base_class_ptr))
	{
		buffer >> element->pfixed.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EnergyConsumer.pfixedPct
bool assign_EnergyConsumer_pfixedPct(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::EnergyConsumer* element = dynamic_cast<IEC61970::Base::Wires::EnergyConsumer*>(base_class_ptr))
	{
		buffer >> element->pfixedPct.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EnergyConsumer.phaseConnection
bool assign_EnergyConsumer_phaseConnection(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::EnergyConsumer* element = dynamic_cast<IEC61970::Base::Wires::EnergyConsumer*>(base_class_ptr))
	{
		buffer >> element->phaseConnection;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EnergyConsumer.q
bool assign_EnergyConsumer_q(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::EnergyConsumer* element = dynamic_cast<IEC61970::Base::Wires::EnergyConsumer*>(base_class_ptr))
	{
		buffer >> element->q.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EnergyConsumer.qfixed
bool assign_EnergyConsumer_qfixed(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::EnergyConsumer* element = dynamic_cast<IEC61970::Base::Wires::EnergyConsumer*>(base_class_ptr))
	{
		buffer >> element->qfixed.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EnergyConsumer.qfixedPct
bool assign_EnergyConsumer_qfixedPct(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::EnergyConsumer* element = dynamic_cast<IEC61970::Base::Wires::EnergyConsumer*>(base_class_ptr))
	{
		buffer >> element->qfixedPct.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PowerCutZone.cutLevel1
bool assign_PowerCutZone_cutLevel1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::LoadModel::PowerCutZone* element = dynamic_cast<IEC61970::Base::LoadModel::PowerCutZone*>(base_class_ptr))
	{
		buffer >> element->cutLevel1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PowerCutZone.cutLevel2
bool assign_PowerCutZone_cutLevel2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::LoadModel::PowerCutZone* element = dynamic_cast<IEC61970::Base::LoadModel::PowerCutZone*>(base_class_ptr))
	{
		buffer >> element->cutLevel2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Season.endDate
bool assign_Season_endDate(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::LoadModel::Season* element = dynamic_cast<IEC61970::Base::LoadModel::Season*>(base_class_ptr))
	{
		element->endDate.value = buffer.str();
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Season.startDate
bool assign_Season_startDate(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::LoadModel::Season* element = dynamic_cast<IEC61970::Base::LoadModel::Season*>(base_class_ptr))
	{
		element->startDate.value = buffer.str();
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:AccumulatorValue.value
bool assign_AccumulatorValue_value(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Meas::AccumulatorValue* element = dynamic_cast<IEC61970::Base::Meas::AccumulatorValue*>(base_class_ptr))
	{
		buffer >> element->value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:AccumulatorLimit.value
bool assign_AccumulatorLimit_value(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Meas::AccumulatorLimit* element = dynamic_cast<IEC61970::Base::Meas::AccumulatorLimit*>(base_class_ptr))
	{
		buffer >> element->value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LimitSet.isPercentageLimits
bool assign_LimitSet_isPercentageLimits(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Meas::LimitSet* element = dynamic_cast<IEC61970::Base::Meas::LimitSet*>(base_class_ptr))
	{
		buffer >> element->isPercentageLimits;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Accumulator.maxValue
bool assign_Accumulator_maxValue(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Meas::Accumulator* element = dynamic_cast<IEC61970::Base::Meas::Accumulator*>(base_class_ptr))
	{
		buffer >> element->maxValue;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:AnalogLimit.value
bool assign_AnalogLimit_value(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Meas::AnalogLimit* element = dynamic_cast<IEC61970::Base::Meas::AnalogLimit*>(base_class_ptr))
	{
		buffer >> element->value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Analog.maxValue
bool assign_Analog_maxValue(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Meas::Analog* element = dynamic_cast<IEC61970::Base::Meas::Analog*>(base_class_ptr))
	{
		buffer >> element->maxValue;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Analog.minValue
bool assign_Analog_minValue(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Meas::Analog* element = dynamic_cast<IEC61970::Base::Meas::Analog*>(base_class_ptr))
	{
		buffer >> element->minValue;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Analog.normalValue
bool assign_Analog_normalValue(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Meas::Analog* element = dynamic_cast<IEC61970::Base::Meas::Analog*>(base_class_ptr))
	{
		buffer >> element->normalValue;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Analog.positiveFlowIn
bool assign_Analog_positiveFlowIn(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Meas::Analog* element = dynamic_cast<IEC61970::Base::Meas::Analog*>(base_class_ptr))
	{
		buffer >> element->positiveFlowIn;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ValueToAlias.value
bool assign_ValueToAlias_value(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Meas::ValueToAlias* element = dynamic_cast<IEC61970::Base::Meas::ValueToAlias*>(base_class_ptr))
	{
		buffer >> element->value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Command.normalValue
bool assign_Command_normalValue(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Meas::Command* element = dynamic_cast<IEC61970::Base::Meas::Command*>(base_class_ptr))
	{
		buffer >> element->normalValue;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Command.value
bool assign_Command_value(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Meas::Command* element = dynamic_cast<IEC61970::Base::Meas::Command*>(base_class_ptr))
	{
		buffer >> element->value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:DiscreteValue.value
bool assign_DiscreteValue_value(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Meas::DiscreteValue* element = dynamic_cast<IEC61970::Base::Meas::DiscreteValue*>(base_class_ptr))
	{
		buffer >> element->value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Discrete.maxValue
bool assign_Discrete_maxValue(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Meas::Discrete* element = dynamic_cast<IEC61970::Base::Meas::Discrete*>(base_class_ptr))
	{
		buffer >> element->maxValue;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Discrete.minValue
bool assign_Discrete_minValue(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Meas::Discrete* element = dynamic_cast<IEC61970::Base::Meas::Discrete*>(base_class_ptr))
	{
		buffer >> element->minValue;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Discrete.normalValue
bool assign_Discrete_normalValue(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Meas::Discrete* element = dynamic_cast<IEC61970::Base::Meas::Discrete*>(base_class_ptr))
	{
		buffer >> element->normalValue;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SetPoint.normalValue
bool assign_SetPoint_normalValue(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Meas::SetPoint* element = dynamic_cast<IEC61970::Base::Meas::SetPoint*>(base_class_ptr))
	{
		buffer >> element->normalValue;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SetPoint.value
bool assign_SetPoint_value(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Meas::SetPoint* element = dynamic_cast<IEC61970::Base::Meas::SetPoint*>(base_class_ptr))
	{
		buffer >> element->value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:StringMeasurementValue.value
bool assign_StringMeasurementValue_value(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Meas::StringMeasurementValue* element = dynamic_cast<IEC61970::Base::Meas::StringMeasurementValue*>(base_class_ptr))
	{
		element->value = buffer.str();
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:OperationalLimitType.acceptableDuration
bool assign_OperationalLimitType_acceptableDuration(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::OperationalLimits::OperationalLimitType* element = dynamic_cast<IEC61970::Base::OperationalLimits::OperationalLimitType*>(base_class_ptr))
	{
		buffer >> element->acceptableDuration.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:OperationalLimitType.direction
bool assign_OperationalLimitType_direction(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::OperationalLimits::OperationalLimitType* element = dynamic_cast<IEC61970::Base::OperationalLimits::OperationalLimitType*>(base_class_ptr))
	{
		buffer >> element->direction;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ActivePowerLimit.value
bool assign_ActivePowerLimit_value(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::OperationalLimits::ActivePowerLimit* element = dynamic_cast<IEC61970::Base::OperationalLimits::ActivePowerLimit*>(base_class_ptr))
	{
		buffer >> element->value.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ApparentPowerLimit.value
bool assign_ApparentPowerLimit_value(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::OperationalLimits::ApparentPowerLimit* element = dynamic_cast<IEC61970::Base::OperationalLimits::ApparentPowerLimit*>(base_class_ptr))
	{
		buffer >> element->value.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:BranchGroupTerminal.positiveFlowIn
bool assign_BranchGroupTerminal_positiveFlowIn(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::OperationalLimits::BranchGroupTerminal* element = dynamic_cast<IEC61970::Base::OperationalLimits::BranchGroupTerminal*>(base_class_ptr))
	{
		buffer >> element->positiveFlowIn;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:BranchGroup.maximumActivePower
bool assign_BranchGroup_maximumActivePower(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::OperationalLimits::BranchGroup* element = dynamic_cast<IEC61970::Base::OperationalLimits::BranchGroup*>(base_class_ptr))
	{
		buffer >> element->maximumActivePower.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:BranchGroup.maximumReactivePower
bool assign_BranchGroup_maximumReactivePower(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::OperationalLimits::BranchGroup* element = dynamic_cast<IEC61970::Base::OperationalLimits::BranchGroup*>(base_class_ptr))
	{
		buffer >> element->maximumReactivePower.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:BranchGroup.minimumActivePower
bool assign_BranchGroup_minimumActivePower(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::OperationalLimits::BranchGroup* element = dynamic_cast<IEC61970::Base::OperationalLimits::BranchGroup*>(base_class_ptr))
	{
		buffer >> element->minimumActivePower.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:BranchGroup.minimumReactivePower
bool assign_BranchGroup_minimumReactivePower(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::OperationalLimits::BranchGroup* element = dynamic_cast<IEC61970::Base::OperationalLimits::BranchGroup*>(base_class_ptr))
	{
		buffer >> element->minimumReactivePower.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:BranchGroup.monitorActivePower
bool assign_BranchGroup_monitorActivePower(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::OperationalLimits::BranchGroup* element = dynamic_cast<IEC61970::Base::OperationalLimits::BranchGroup*>(base_class_ptr))
	{
		buffer >> element->monitorActivePower;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:BranchGroup.monitorReactivePower
bool assign_BranchGroup_monitorReactivePower(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::OperationalLimits::BranchGroup* element = dynamic_cast<IEC61970::Base::OperationalLimits::BranchGroup*>(base_class_ptr))
	{
		buffer >> element->monitorReactivePower;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:CurrentLimit.value
bool assign_CurrentLimit_value(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::OperationalLimits::CurrentLimit* element = dynamic_cast<IEC61970::Base::OperationalLimits::CurrentLimit*>(base_class_ptr))
	{
		buffer >> element->value.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:VoltageLimit.value
bool assign_VoltageLimit_value(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::OperationalLimits::VoltageLimit* element = dynamic_cast<IEC61970::Base::OperationalLimits::VoltageLimit*>(base_class_ptr))
	{
		buffer >> element->value.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:RecloseSequence.recloseDelay
bool assign_RecloseSequence_recloseDelay(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Protection::RecloseSequence* element = dynamic_cast<IEC61970::Base::Protection::RecloseSequence*>(base_class_ptr))
	{
		buffer >> element->recloseDelay.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:RecloseSequence.recloseStep
bool assign_RecloseSequence_recloseStep(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Protection::RecloseSequence* element = dynamic_cast<IEC61970::Base::Protection::RecloseSequence*>(base_class_ptr))
	{
		buffer >> element->recloseStep;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SwitchPhase.closed
bool assign_SwitchPhase_closed(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::SwitchPhase* element = dynamic_cast<IEC61970::Base::Wires::SwitchPhase*>(base_class_ptr))
	{
		buffer >> element->closed;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SwitchPhase.normalOpen
bool assign_SwitchPhase_normalOpen(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::SwitchPhase* element = dynamic_cast<IEC61970::Base::Wires::SwitchPhase*>(base_class_ptr))
	{
		buffer >> element->normalOpen;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SwitchPhase.phaseSide1
bool assign_SwitchPhase_phaseSide1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::SwitchPhase* element = dynamic_cast<IEC61970::Base::Wires::SwitchPhase*>(base_class_ptr))
	{
		buffer >> element->phaseSide1;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SwitchPhase.phaseSide2
bool assign_SwitchPhase_phaseSide2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::SwitchPhase* element = dynamic_cast<IEC61970::Base::Wires::SwitchPhase*>(base_class_ptr))
	{
		buffer >> element->phaseSide2;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Switch.normalOpen
bool assign_Switch_normalOpen(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::Switch* element = dynamic_cast<IEC61970::Base::Wires::Switch*>(base_class_ptr))
	{
		buffer >> element->normalOpen;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Switch.open
bool assign_Switch_open(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::Switch* element = dynamic_cast<IEC61970::Base::Wires::Switch*>(base_class_ptr))
	{
		buffer >> element->open;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Switch.ratedCurrent
bool assign_Switch_ratedCurrent(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::Switch* element = dynamic_cast<IEC61970::Base::Wires::Switch*>(base_class_ptr))
	{
		buffer >> element->ratedCurrent.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Switch.retained
bool assign_Switch_retained(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::Switch* element = dynamic_cast<IEC61970::Base::Wires::Switch*>(base_class_ptr))
	{
		buffer >> element->retained;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Switch.switchOnCount
bool assign_Switch_switchOnCount(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::Switch* element = dynamic_cast<IEC61970::Base::Wires::Switch*>(base_class_ptr))
	{
		buffer >> element->switchOnCount;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Switch.switchOnDate
bool assign_Switch_switchOnDate(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::Switch* element = dynamic_cast<IEC61970::Base::Wires::Switch*>(base_class_ptr))
	{
		element->switchOnDate.value = buffer.str();
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ProtectedSwitch.breakingCapacity
bool assign_ProtectedSwitch_breakingCapacity(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::ProtectedSwitch* element = dynamic_cast<IEC61970::Base::Wires::ProtectedSwitch*>(base_class_ptr))
	{
		buffer >> element->breakingCapacity.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ProtectionEquipment.highLimit
bool assign_ProtectionEquipment_highLimit(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Protection::ProtectionEquipment* element = dynamic_cast<IEC61970::Base::Protection::ProtectionEquipment*>(base_class_ptr))
	{
		buffer >> element->highLimit;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ProtectionEquipment.lowLimit
bool assign_ProtectionEquipment_lowLimit(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Protection::ProtectionEquipment* element = dynamic_cast<IEC61970::Base::Protection::ProtectionEquipment*>(base_class_ptr))
	{
		buffer >> element->lowLimit;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ProtectionEquipment.powerDirectionFlag
bool assign_ProtectionEquipment_powerDirectionFlag(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Protection::ProtectionEquipment* element = dynamic_cast<IEC61970::Base::Protection::ProtectionEquipment*>(base_class_ptr))
	{
		buffer >> element->powerDirectionFlag;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ProtectionEquipment.relayDelayTime
bool assign_ProtectionEquipment_relayDelayTime(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Protection::ProtectionEquipment* element = dynamic_cast<IEC61970::Base::Protection::ProtectionEquipment*>(base_class_ptr))
	{
		buffer >> element->relayDelayTime.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ProtectionEquipment.unitMultiplier
bool assign_ProtectionEquipment_unitMultiplier(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Protection::ProtectionEquipment* element = dynamic_cast<IEC61970::Base::Protection::ProtectionEquipment*>(base_class_ptr))
	{
		buffer >> element->unitMultiplier;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ProtectionEquipment.unitSymbol
bool assign_ProtectionEquipment_unitSymbol(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Protection::ProtectionEquipment* element = dynamic_cast<IEC61970::Base::Protection::ProtectionEquipment*>(base_class_ptr))
	{
		buffer >> element->unitSymbol;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:CurrentRelay.currentLimit1
bool assign_CurrentRelay_currentLimit1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Protection::CurrentRelay* element = dynamic_cast<IEC61970::Base::Protection::CurrentRelay*>(base_class_ptr))
	{
		buffer >> element->currentLimit1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:CurrentRelay.currentLimit2
bool assign_CurrentRelay_currentLimit2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Protection::CurrentRelay* element = dynamic_cast<IEC61970::Base::Protection::CurrentRelay*>(base_class_ptr))
	{
		buffer >> element->currentLimit2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:CurrentRelay.currentLimit3
bool assign_CurrentRelay_currentLimit3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Protection::CurrentRelay* element = dynamic_cast<IEC61970::Base::Protection::CurrentRelay*>(base_class_ptr))
	{
		buffer >> element->currentLimit3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:CurrentRelay.inverseTimeFlag
bool assign_CurrentRelay_inverseTimeFlag(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Protection::CurrentRelay* element = dynamic_cast<IEC61970::Base::Protection::CurrentRelay*>(base_class_ptr))
	{
		buffer >> element->inverseTimeFlag;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:CurrentRelay.timeDelay1
bool assign_CurrentRelay_timeDelay1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Protection::CurrentRelay* element = dynamic_cast<IEC61970::Base::Protection::CurrentRelay*>(base_class_ptr))
	{
		buffer >> element->timeDelay1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:CurrentRelay.timeDelay2
bool assign_CurrentRelay_timeDelay2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Protection::CurrentRelay* element = dynamic_cast<IEC61970::Base::Protection::CurrentRelay*>(base_class_ptr))
	{
		buffer >> element->timeDelay2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:CurrentRelay.timeDelay3
bool assign_CurrentRelay_timeDelay3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Protection::CurrentRelay* element = dynamic_cast<IEC61970::Base::Protection::CurrentRelay*>(base_class_ptr))
	{
		buffer >> element->timeDelay3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchrocheckRelay.maxAngleDiff
bool assign_SynchrocheckRelay_maxAngleDiff(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Protection::SynchrocheckRelay* element = dynamic_cast<IEC61970::Base::Protection::SynchrocheckRelay*>(base_class_ptr))
	{
		buffer >> element->maxAngleDiff.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchrocheckRelay.maxFreqDiff
bool assign_SynchrocheckRelay_maxFreqDiff(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Protection::SynchrocheckRelay* element = dynamic_cast<IEC61970::Base::Protection::SynchrocheckRelay*>(base_class_ptr))
	{
		buffer >> element->maxFreqDiff.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchrocheckRelay.maxVoltDiff
bool assign_SynchrocheckRelay_maxVoltDiff(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Protection::SynchrocheckRelay* element = dynamic_cast<IEC61970::Base::Protection::SynchrocheckRelay*>(base_class_ptr))
	{
		buffer >> element->maxVoltDiff.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:RemoteUnit.remoteUnitType
bool assign_RemoteUnit_remoteUnitType(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::SCADA::RemoteUnit* element = dynamic_cast<IEC61970::Base::SCADA::RemoteUnit*>(base_class_ptr))
	{
		buffer >> element->remoteUnitType;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:RemoteControl.actuatorMaximum
bool assign_RemoteControl_actuatorMaximum(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::SCADA::RemoteControl* element = dynamic_cast<IEC61970::Base::SCADA::RemoteControl*>(base_class_ptr))
	{
		buffer >> element->actuatorMaximum;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:RemoteControl.actuatorMinimum
bool assign_RemoteControl_actuatorMinimum(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::SCADA::RemoteControl* element = dynamic_cast<IEC61970::Base::SCADA::RemoteControl*>(base_class_ptr))
	{
		buffer >> element->actuatorMinimum;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:RemoteControl.remoteControlled
bool assign_RemoteControl_remoteControlled(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::SCADA::RemoteControl* element = dynamic_cast<IEC61970::Base::SCADA::RemoteControl*>(base_class_ptr))
	{
		buffer >> element->remoteControlled;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TopologicalNode.pInjection
bool assign_TopologicalNode_pInjection(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Topology::TopologicalNode* element = dynamic_cast<IEC61970::Base::Topology::TopologicalNode*>(base_class_ptr))
	{
		buffer >> element->pInjection.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TopologicalNode.qInjection
bool assign_TopologicalNode_qInjection(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Topology::TopologicalNode* element = dynamic_cast<IEC61970::Base::Topology::TopologicalNode*>(base_class_ptr))
	{
		buffer >> element->qInjection.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SvInjection.phase
bool assign_SvInjection_phase(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::StateVariables::SvInjection* element = dynamic_cast<IEC61970::Base::StateVariables::SvInjection*>(base_class_ptr))
	{
		buffer >> element->phase;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SvInjection.pInjection
bool assign_SvInjection_pInjection(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::StateVariables::SvInjection* element = dynamic_cast<IEC61970::Base::StateVariables::SvInjection*>(base_class_ptr))
	{
		buffer >> element->pInjection.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SvInjection.qInjection
bool assign_SvInjection_qInjection(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::StateVariables::SvInjection* element = dynamic_cast<IEC61970::Base::StateVariables::SvInjection*>(base_class_ptr))
	{
		buffer >> element->qInjection.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SvPowerFlow.p
bool assign_SvPowerFlow_p(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::StateVariables::SvPowerFlow* element = dynamic_cast<IEC61970::Base::StateVariables::SvPowerFlow*>(base_class_ptr))
	{
		buffer >> element->p.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SvPowerFlow.phase
bool assign_SvPowerFlow_phase(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::StateVariables::SvPowerFlow* element = dynamic_cast<IEC61970::Base::StateVariables::SvPowerFlow*>(base_class_ptr))
	{
		buffer >> element->phase;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SvPowerFlow.q
bool assign_SvPowerFlow_q(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::StateVariables::SvPowerFlow* element = dynamic_cast<IEC61970::Base::StateVariables::SvPowerFlow*>(base_class_ptr))
	{
		buffer >> element->q.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ShuntCompensatorPhase.maximumSections
bool assign_ShuntCompensatorPhase_maximumSections(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::ShuntCompensatorPhase* element = dynamic_cast<IEC61970::Base::Wires::ShuntCompensatorPhase*>(base_class_ptr))
	{
		buffer >> element->maximumSections;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ShuntCompensatorPhase.normalSections
bool assign_ShuntCompensatorPhase_normalSections(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::ShuntCompensatorPhase* element = dynamic_cast<IEC61970::Base::Wires::ShuntCompensatorPhase*>(base_class_ptr))
	{
		buffer >> element->normalSections;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ShuntCompensatorPhase.phase
bool assign_ShuntCompensatorPhase_phase(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::ShuntCompensatorPhase* element = dynamic_cast<IEC61970::Base::Wires::ShuntCompensatorPhase*>(base_class_ptr))
	{
		buffer >> element->phase;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ShuntCompensator.aVRDelay
bool assign_ShuntCompensator_aVRDelay(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::ShuntCompensator* element = dynamic_cast<IEC61970::Base::Wires::ShuntCompensator*>(base_class_ptr))
	{
		buffer >> element->aVRDelay.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ShuntCompensator.grounded
bool assign_ShuntCompensator_grounded(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::ShuntCompensator* element = dynamic_cast<IEC61970::Base::Wires::ShuntCompensator*>(base_class_ptr))
	{
		buffer >> element->grounded;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ShuntCompensator.maximumSections
bool assign_ShuntCompensator_maximumSections(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::ShuntCompensator* element = dynamic_cast<IEC61970::Base::Wires::ShuntCompensator*>(base_class_ptr))
	{
		buffer >> element->maximumSections;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ShuntCompensator.nomU
bool assign_ShuntCompensator_nomU(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::ShuntCompensator* element = dynamic_cast<IEC61970::Base::Wires::ShuntCompensator*>(base_class_ptr))
	{
		buffer >> element->nomU.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ShuntCompensator.normalSections
bool assign_ShuntCompensator_normalSections(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::ShuntCompensator* element = dynamic_cast<IEC61970::Base::Wires::ShuntCompensator*>(base_class_ptr))
	{
		buffer >> element->normalSections;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ShuntCompensator.phaseConnection
bool assign_ShuntCompensator_phaseConnection(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::ShuntCompensator* element = dynamic_cast<IEC61970::Base::Wires::ShuntCompensator*>(base_class_ptr))
	{
		buffer >> element->phaseConnection;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ShuntCompensator.sections
bool assign_ShuntCompensator_sections(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::ShuntCompensator* element = dynamic_cast<IEC61970::Base::Wires::ShuntCompensator*>(base_class_ptr))
	{
		buffer >> element->sections;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ShuntCompensator.switchOnCount
bool assign_ShuntCompensator_switchOnCount(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::ShuntCompensator* element = dynamic_cast<IEC61970::Base::Wires::ShuntCompensator*>(base_class_ptr))
	{
		buffer >> element->switchOnCount;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ShuntCompensator.switchOnDate
bool assign_ShuntCompensator_switchOnDate(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::ShuntCompensator* element = dynamic_cast<IEC61970::Base::Wires::ShuntCompensator*>(base_class_ptr))
	{
		element->switchOnDate.value = buffer.str();
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ShuntCompensator.voltageSensitivity
bool assign_ShuntCompensator_voltageSensitivity(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::ShuntCompensator* element = dynamic_cast<IEC61970::Base::Wires::ShuntCompensator*>(base_class_ptr))
	{
		buffer >> element->voltageSensitivity.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SvShuntCompensatorSections.sections
bool assign_SvShuntCompensatorSections_sections(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::StateVariables::SvShuntCompensatorSections* element = dynamic_cast<IEC61970::Base::StateVariables::SvShuntCompensatorSections*>(base_class_ptr))
	{
		buffer >> element->sections;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SvStatus.inService
bool assign_SvStatus_inService(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::StateVariables::SvStatus* element = dynamic_cast<IEC61970::Base::StateVariables::SvStatus*>(base_class_ptr))
	{
		buffer >> element->inService;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SvStatus.phase
bool assign_SvStatus_phase(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::StateVariables::SvStatus* element = dynamic_cast<IEC61970::Base::StateVariables::SvStatus*>(base_class_ptr))
	{
		buffer >> element->phase;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TapChangerControl.limitVoltage
bool assign_TapChangerControl_limitVoltage(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::TapChangerControl* element = dynamic_cast<IEC61970::Base::Wires::TapChangerControl*>(base_class_ptr))
	{
		buffer >> element->limitVoltage.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TapChangerControl.lineDropCompensation
bool assign_TapChangerControl_lineDropCompensation(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::TapChangerControl* element = dynamic_cast<IEC61970::Base::Wires::TapChangerControl*>(base_class_ptr))
	{
		buffer >> element->lineDropCompensation;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TapChangerControl.lineDropR
bool assign_TapChangerControl_lineDropR(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::TapChangerControl* element = dynamic_cast<IEC61970::Base::Wires::TapChangerControl*>(base_class_ptr))
	{
		buffer >> element->lineDropR.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TapChangerControl.lineDropX
bool assign_TapChangerControl_lineDropX(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::TapChangerControl* element = dynamic_cast<IEC61970::Base::Wires::TapChangerControl*>(base_class_ptr))
	{
		buffer >> element->lineDropX.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TapChangerControl.reverseLineDropR
bool assign_TapChangerControl_reverseLineDropR(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::TapChangerControl* element = dynamic_cast<IEC61970::Base::Wires::TapChangerControl*>(base_class_ptr))
	{
		buffer >> element->reverseLineDropR.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TapChangerControl.reverseLineDropX
bool assign_TapChangerControl_reverseLineDropX(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::TapChangerControl* element = dynamic_cast<IEC61970::Base::Wires::TapChangerControl*>(base_class_ptr))
	{
		buffer >> element->reverseLineDropX.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TapChanger.controlEnabled
bool assign_TapChanger_controlEnabled(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::TapChanger* element = dynamic_cast<IEC61970::Base::Wires::TapChanger*>(base_class_ptr))
	{
		buffer >> element->controlEnabled;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TapChanger.highStep
bool assign_TapChanger_highStep(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::TapChanger* element = dynamic_cast<IEC61970::Base::Wires::TapChanger*>(base_class_ptr))
	{
		buffer >> element->highStep;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TapChanger.initialDelay
bool assign_TapChanger_initialDelay(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::TapChanger* element = dynamic_cast<IEC61970::Base::Wires::TapChanger*>(base_class_ptr))
	{
		buffer >> element->initialDelay.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TapChanger.lowStep
bool assign_TapChanger_lowStep(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::TapChanger* element = dynamic_cast<IEC61970::Base::Wires::TapChanger*>(base_class_ptr))
	{
		buffer >> element->lowStep;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TapChanger.ltcFlag
bool assign_TapChanger_ltcFlag(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::TapChanger* element = dynamic_cast<IEC61970::Base::Wires::TapChanger*>(base_class_ptr))
	{
		buffer >> element->ltcFlag;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TapChanger.neutralStep
bool assign_TapChanger_neutralStep(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::TapChanger* element = dynamic_cast<IEC61970::Base::Wires::TapChanger*>(base_class_ptr))
	{
		buffer >> element->neutralStep;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TapChanger.neutralU
bool assign_TapChanger_neutralU(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::TapChanger* element = dynamic_cast<IEC61970::Base::Wires::TapChanger*>(base_class_ptr))
	{
		buffer >> element->neutralU.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TapChanger.normalStep
bool assign_TapChanger_normalStep(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::TapChanger* element = dynamic_cast<IEC61970::Base::Wires::TapChanger*>(base_class_ptr))
	{
		buffer >> element->normalStep;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TapChanger.step
bool assign_TapChanger_step(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::TapChanger* element = dynamic_cast<IEC61970::Base::Wires::TapChanger*>(base_class_ptr))
	{
		buffer >> element->step;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TapChanger.subsequentDelay
bool assign_TapChanger_subsequentDelay(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::TapChanger* element = dynamic_cast<IEC61970::Base::Wires::TapChanger*>(base_class_ptr))
	{
		buffer >> element->subsequentDelay.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SvTapStep.position
bool assign_SvTapStep_position(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::StateVariables::SvTapStep* element = dynamic_cast<IEC61970::Base::StateVariables::SvTapStep*>(base_class_ptr))
	{
		buffer >> element->position;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SvVoltage.angle
bool assign_SvVoltage_angle(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::StateVariables::SvVoltage* element = dynamic_cast<IEC61970::Base::StateVariables::SvVoltage*>(base_class_ptr))
	{
		buffer >> element->angle.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SvVoltage.phase
bool assign_SvVoltage_phase(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::StateVariables::SvVoltage* element = dynamic_cast<IEC61970::Base::StateVariables::SvVoltage*>(base_class_ptr))
	{
		buffer >> element->phase;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SvVoltage.v
bool assign_SvVoltage_v(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::StateVariables::SvVoltage* element = dynamic_cast<IEC61970::Base::StateVariables::SvVoltage*>(base_class_ptr))
	{
		buffer >> element->v.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:BusNameMarker.priority
bool assign_BusNameMarker_priority(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Topology::BusNameMarker* element = dynamic_cast<IEC61970::Base::Topology::BusNameMarker*>(base_class_ptr))
	{
		buffer >> element->priority;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ACLineSegmentPhase.phase
bool assign_ACLineSegmentPhase_phase(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::ACLineSegmentPhase* element = dynamic_cast<IEC61970::Base::Wires::ACLineSegmentPhase*>(base_class_ptr))
	{
		buffer >> element->phase;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ACLineSegmentPhase.sequenceNumber
bool assign_ACLineSegmentPhase_sequenceNumber(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::ACLineSegmentPhase* element = dynamic_cast<IEC61970::Base::Wires::ACLineSegmentPhase*>(base_class_ptr))
	{
		buffer >> element->sequenceNumber;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:AsynchronousMachine.asynchronousMachineType
bool assign_AsynchronousMachine_asynchronousMachineType(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::AsynchronousMachine* element = dynamic_cast<IEC61970::Base::Wires::AsynchronousMachine*>(base_class_ptr))
	{
		buffer >> element->asynchronousMachineType;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:AsynchronousMachine.converterFedDrive
bool assign_AsynchronousMachine_converterFedDrive(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::AsynchronousMachine* element = dynamic_cast<IEC61970::Base::Wires::AsynchronousMachine*>(base_class_ptr))
	{
		buffer >> element->converterFedDrive;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:AsynchronousMachine.efficiency
bool assign_AsynchronousMachine_efficiency(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::AsynchronousMachine* element = dynamic_cast<IEC61970::Base::Wires::AsynchronousMachine*>(base_class_ptr))
	{
		buffer >> element->efficiency.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:AsynchronousMachine.iaIrRatio
bool assign_AsynchronousMachine_iaIrRatio(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::AsynchronousMachine* element = dynamic_cast<IEC61970::Base::Wires::AsynchronousMachine*>(base_class_ptr))
	{
		buffer >> element->iaIrRatio;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:AsynchronousMachine.nominalFrequency
bool assign_AsynchronousMachine_nominalFrequency(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::AsynchronousMachine* element = dynamic_cast<IEC61970::Base::Wires::AsynchronousMachine*>(base_class_ptr))
	{
		buffer >> element->nominalFrequency.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:AsynchronousMachine.nominalSpeed
bool assign_AsynchronousMachine_nominalSpeed(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::AsynchronousMachine* element = dynamic_cast<IEC61970::Base::Wires::AsynchronousMachine*>(base_class_ptr))
	{
		buffer >> element->nominalSpeed.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:AsynchronousMachine.polePairNumber
bool assign_AsynchronousMachine_polePairNumber(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::AsynchronousMachine* element = dynamic_cast<IEC61970::Base::Wires::AsynchronousMachine*>(base_class_ptr))
	{
		buffer >> element->polePairNumber;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:AsynchronousMachine.ratedMechanicalPower
bool assign_AsynchronousMachine_ratedMechanicalPower(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::AsynchronousMachine* element = dynamic_cast<IEC61970::Base::Wires::AsynchronousMachine*>(base_class_ptr))
	{
		buffer >> element->ratedMechanicalPower.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:AsynchronousMachine.reversible
bool assign_AsynchronousMachine_reversible(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::AsynchronousMachine* element = dynamic_cast<IEC61970::Base::Wires::AsynchronousMachine*>(base_class_ptr))
	{
		buffer >> element->reversible;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:AsynchronousMachine.rr1
bool assign_AsynchronousMachine_rr1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::AsynchronousMachine* element = dynamic_cast<IEC61970::Base::Wires::AsynchronousMachine*>(base_class_ptr))
	{
		buffer >> element->rr1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:AsynchronousMachine.rr2
bool assign_AsynchronousMachine_rr2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::AsynchronousMachine* element = dynamic_cast<IEC61970::Base::Wires::AsynchronousMachine*>(base_class_ptr))
	{
		buffer >> element->rr2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:AsynchronousMachine.rxLockedRotorRatio
bool assign_AsynchronousMachine_rxLockedRotorRatio(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::AsynchronousMachine* element = dynamic_cast<IEC61970::Base::Wires::AsynchronousMachine*>(base_class_ptr))
	{
		buffer >> element->rxLockedRotorRatio;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:AsynchronousMachine.tpo
bool assign_AsynchronousMachine_tpo(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::AsynchronousMachine* element = dynamic_cast<IEC61970::Base::Wires::AsynchronousMachine*>(base_class_ptr))
	{
		buffer >> element->tpo.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:AsynchronousMachine.tppo
bool assign_AsynchronousMachine_tppo(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::AsynchronousMachine* element = dynamic_cast<IEC61970::Base::Wires::AsynchronousMachine*>(base_class_ptr))
	{
		buffer >> element->tppo.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:AsynchronousMachine.xlr1
bool assign_AsynchronousMachine_xlr1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::AsynchronousMachine* element = dynamic_cast<IEC61970::Base::Wires::AsynchronousMachine*>(base_class_ptr))
	{
		buffer >> element->xlr1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:AsynchronousMachine.xlr2
bool assign_AsynchronousMachine_xlr2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::AsynchronousMachine* element = dynamic_cast<IEC61970::Base::Wires::AsynchronousMachine*>(base_class_ptr))
	{
		buffer >> element->xlr2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:AsynchronousMachine.xm
bool assign_AsynchronousMachine_xm(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::AsynchronousMachine* element = dynamic_cast<IEC61970::Base::Wires::AsynchronousMachine*>(base_class_ptr))
	{
		buffer >> element->xm.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:AsynchronousMachine.xp
bool assign_AsynchronousMachine_xp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::AsynchronousMachine* element = dynamic_cast<IEC61970::Base::Wires::AsynchronousMachine*>(base_class_ptr))
	{
		buffer >> element->xp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:AsynchronousMachine.xpp
bool assign_AsynchronousMachine_xpp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::AsynchronousMachine* element = dynamic_cast<IEC61970::Base::Wires::AsynchronousMachine*>(base_class_ptr))
	{
		buffer >> element->xpp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:AsynchronousMachine.xs
bool assign_AsynchronousMachine_xs(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::AsynchronousMachine* element = dynamic_cast<IEC61970::Base::Wires::AsynchronousMachine*>(base_class_ptr))
	{
		buffer >> element->xs.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Breaker.inTransitTime
bool assign_Breaker_inTransitTime(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::Breaker* element = dynamic_cast<IEC61970::Base::Wires::Breaker*>(base_class_ptr))
	{
		buffer >> element->inTransitTime.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:BusbarSection.ipMax
bool assign_BusbarSection_ipMax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::BusbarSection* element = dynamic_cast<IEC61970::Base::Wires::BusbarSection*>(base_class_ptr))
	{
		buffer >> element->ipMax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:CompositeSwitch.compositeSwitchType
bool assign_CompositeSwitch_compositeSwitchType(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::CompositeSwitch* element = dynamic_cast<IEC61970::Base::Wires::CompositeSwitch*>(base_class_ptr))
	{
		element->compositeSwitchType = buffer.str();
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Cut.lengthFromTerminal1
bool assign_Cut_lengthFromTerminal1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::Cut* element = dynamic_cast<IEC61970::Base::Wires::Cut*>(base_class_ptr))
	{
		buffer >> element->lengthFromTerminal1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EarthFaultCompensator.r
bool assign_EarthFaultCompensator_r(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::EarthFaultCompensator* element = dynamic_cast<IEC61970::Base::Wires::EarthFaultCompensator*>(base_class_ptr))
	{
		buffer >> element->r.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EnergySource.activePower
bool assign_EnergySource_activePower(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::EnergySource* element = dynamic_cast<IEC61970::Base::Wires::EnergySource*>(base_class_ptr))
	{
		buffer >> element->activePower.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EnergySource.nominalVoltage
bool assign_EnergySource_nominalVoltage(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::EnergySource* element = dynamic_cast<IEC61970::Base::Wires::EnergySource*>(base_class_ptr))
	{
		buffer >> element->nominalVoltage.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EnergySource.r
bool assign_EnergySource_r(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::EnergySource* element = dynamic_cast<IEC61970::Base::Wires::EnergySource*>(base_class_ptr))
	{
		buffer >> element->r.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EnergySource.r0
bool assign_EnergySource_r0(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::EnergySource* element = dynamic_cast<IEC61970::Base::Wires::EnergySource*>(base_class_ptr))
	{
		buffer >> element->r0.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EnergySource.reactivePower
bool assign_EnergySource_reactivePower(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::EnergySource* element = dynamic_cast<IEC61970::Base::Wires::EnergySource*>(base_class_ptr))
	{
		buffer >> element->reactivePower.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EnergySource.rn
bool assign_EnergySource_rn(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::EnergySource* element = dynamic_cast<IEC61970::Base::Wires::EnergySource*>(base_class_ptr))
	{
		buffer >> element->rn.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EnergySource.voltageAngle
bool assign_EnergySource_voltageAngle(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::EnergySource* element = dynamic_cast<IEC61970::Base::Wires::EnergySource*>(base_class_ptr))
	{
		buffer >> element->voltageAngle.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EnergySource.voltageMagnitude
bool assign_EnergySource_voltageMagnitude(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::EnergySource* element = dynamic_cast<IEC61970::Base::Wires::EnergySource*>(base_class_ptr))
	{
		buffer >> element->voltageMagnitude.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EnergySource.x
bool assign_EnergySource_x(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::EnergySource* element = dynamic_cast<IEC61970::Base::Wires::EnergySource*>(base_class_ptr))
	{
		buffer >> element->x.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EnergySource.x0
bool assign_EnergySource_x0(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::EnergySource* element = dynamic_cast<IEC61970::Base::Wires::EnergySource*>(base_class_ptr))
	{
		buffer >> element->x0.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EnergySource.xn
bool assign_EnergySource_xn(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::EnergySource* element = dynamic_cast<IEC61970::Base::Wires::EnergySource*>(base_class_ptr))
	{
		buffer >> element->xn.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:EnergySourcePhase.phase
bool assign_EnergySourcePhase_phase(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::EnergySourcePhase* element = dynamic_cast<IEC61970::Base::Wires::EnergySourcePhase*>(base_class_ptr))
	{
		buffer >> element->phase;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExternalNetworkInjection.governorSCD
bool assign_ExternalNetworkInjection_governorSCD(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::ExternalNetworkInjection* element = dynamic_cast<IEC61970::Base::Wires::ExternalNetworkInjection*>(base_class_ptr))
	{
		buffer >> element->governorSCD.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExternalNetworkInjection.ikSecond
bool assign_ExternalNetworkInjection_ikSecond(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::ExternalNetworkInjection* element = dynamic_cast<IEC61970::Base::Wires::ExternalNetworkInjection*>(base_class_ptr))
	{
		buffer >> element->ikSecond;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExternalNetworkInjection.maxInitialSymShCCurrent
bool assign_ExternalNetworkInjection_maxInitialSymShCCurrent(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::ExternalNetworkInjection* element = dynamic_cast<IEC61970::Base::Wires::ExternalNetworkInjection*>(base_class_ptr))
	{
		buffer >> element->maxInitialSymShCCurrent.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExternalNetworkInjection.maxP
bool assign_ExternalNetworkInjection_maxP(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::ExternalNetworkInjection* element = dynamic_cast<IEC61970::Base::Wires::ExternalNetworkInjection*>(base_class_ptr))
	{
		buffer >> element->maxP.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExternalNetworkInjection.maxQ
bool assign_ExternalNetworkInjection_maxQ(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::ExternalNetworkInjection* element = dynamic_cast<IEC61970::Base::Wires::ExternalNetworkInjection*>(base_class_ptr))
	{
		buffer >> element->maxQ.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExternalNetworkInjection.maxR0ToX0Ratio
bool assign_ExternalNetworkInjection_maxR0ToX0Ratio(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::ExternalNetworkInjection* element = dynamic_cast<IEC61970::Base::Wires::ExternalNetworkInjection*>(base_class_ptr))
	{
		buffer >> element->maxR0ToX0Ratio;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExternalNetworkInjection.maxR1ToX1Ratio
bool assign_ExternalNetworkInjection_maxR1ToX1Ratio(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::ExternalNetworkInjection* element = dynamic_cast<IEC61970::Base::Wires::ExternalNetworkInjection*>(base_class_ptr))
	{
		buffer >> element->maxR1ToX1Ratio;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExternalNetworkInjection.maxZ0ToZ1Ratio
bool assign_ExternalNetworkInjection_maxZ0ToZ1Ratio(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::ExternalNetworkInjection* element = dynamic_cast<IEC61970::Base::Wires::ExternalNetworkInjection*>(base_class_ptr))
	{
		buffer >> element->maxZ0ToZ1Ratio;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExternalNetworkInjection.minInitialSymShCCurrent
bool assign_ExternalNetworkInjection_minInitialSymShCCurrent(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::ExternalNetworkInjection* element = dynamic_cast<IEC61970::Base::Wires::ExternalNetworkInjection*>(base_class_ptr))
	{
		buffer >> element->minInitialSymShCCurrent.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExternalNetworkInjection.minP
bool assign_ExternalNetworkInjection_minP(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::ExternalNetworkInjection* element = dynamic_cast<IEC61970::Base::Wires::ExternalNetworkInjection*>(base_class_ptr))
	{
		buffer >> element->minP.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExternalNetworkInjection.minQ
bool assign_ExternalNetworkInjection_minQ(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::ExternalNetworkInjection* element = dynamic_cast<IEC61970::Base::Wires::ExternalNetworkInjection*>(base_class_ptr))
	{
		buffer >> element->minQ.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExternalNetworkInjection.minR0ToX0Ratio
bool assign_ExternalNetworkInjection_minR0ToX0Ratio(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::ExternalNetworkInjection* element = dynamic_cast<IEC61970::Base::Wires::ExternalNetworkInjection*>(base_class_ptr))
	{
		buffer >> element->minR0ToX0Ratio;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExternalNetworkInjection.minR1ToX1Ratio
bool assign_ExternalNetworkInjection_minR1ToX1Ratio(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::ExternalNetworkInjection* element = dynamic_cast<IEC61970::Base::Wires::ExternalNetworkInjection*>(base_class_ptr))
	{
		buffer >> element->minR1ToX1Ratio;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExternalNetworkInjection.minZ0ToZ1Ratio
bool assign_ExternalNetworkInjection_minZ0ToZ1Ratio(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::ExternalNetworkInjection* element = dynamic_cast<IEC61970::Base::Wires::ExternalNetworkInjection*>(base_class_ptr))
	{
		buffer >> element->minZ0ToZ1Ratio;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExternalNetworkInjection.p
bool assign_ExternalNetworkInjection_p(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::ExternalNetworkInjection* element = dynamic_cast<IEC61970::Base::Wires::ExternalNetworkInjection*>(base_class_ptr))
	{
		buffer >> element->p.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExternalNetworkInjection.q
bool assign_ExternalNetworkInjection_q(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::ExternalNetworkInjection* element = dynamic_cast<IEC61970::Base::Wires::ExternalNetworkInjection*>(base_class_ptr))
	{
		buffer >> element->q.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExternalNetworkInjection.referencePriority
bool assign_ExternalNetworkInjection_referencePriority(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::ExternalNetworkInjection* element = dynamic_cast<IEC61970::Base::Wires::ExternalNetworkInjection*>(base_class_ptr))
	{
		buffer >> element->referencePriority;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExternalNetworkInjection.voltageFactor
bool assign_ExternalNetworkInjection_voltageFactor(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::ExternalNetworkInjection* element = dynamic_cast<IEC61970::Base::Wires::ExternalNetworkInjection*>(base_class_ptr))
	{
		buffer >> element->voltageFactor.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:FrequencyConverter.frequency
bool assign_FrequencyConverter_frequency(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::FrequencyConverter* element = dynamic_cast<IEC61970::Base::Wires::FrequencyConverter*>(base_class_ptr))
	{
		buffer >> element->frequency.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:FrequencyConverter.maxP
bool assign_FrequencyConverter_maxP(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::FrequencyConverter* element = dynamic_cast<IEC61970::Base::Wires::FrequencyConverter*>(base_class_ptr))
	{
		buffer >> element->maxP.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:FrequencyConverter.maxU
bool assign_FrequencyConverter_maxU(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::FrequencyConverter* element = dynamic_cast<IEC61970::Base::Wires::FrequencyConverter*>(base_class_ptr))
	{
		buffer >> element->maxU.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:FrequencyConverter.minP
bool assign_FrequencyConverter_minP(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::FrequencyConverter* element = dynamic_cast<IEC61970::Base::Wires::FrequencyConverter*>(base_class_ptr))
	{
		buffer >> element->minP.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:FrequencyConverter.minU
bool assign_FrequencyConverter_minU(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::FrequencyConverter* element = dynamic_cast<IEC61970::Base::Wires::FrequencyConverter*>(base_class_ptr))
	{
		buffer >> element->minU.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GroundingImpedance.x
bool assign_GroundingImpedance_x(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::GroundingImpedance* element = dynamic_cast<IEC61970::Base::Wires::GroundingImpedance*>(base_class_ptr))
	{
		buffer >> element->x.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LinearShuntCompensator.b0PerSection
bool assign_LinearShuntCompensator_b0PerSection(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::LinearShuntCompensator* element = dynamic_cast<IEC61970::Base::Wires::LinearShuntCompensator*>(base_class_ptr))
	{
		buffer >> element->b0PerSection.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LinearShuntCompensator.bPerSection
bool assign_LinearShuntCompensator_bPerSection(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::LinearShuntCompensator* element = dynamic_cast<IEC61970::Base::Wires::LinearShuntCompensator*>(base_class_ptr))
	{
		buffer >> element->bPerSection.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LinearShuntCompensator.g0PerSection
bool assign_LinearShuntCompensator_g0PerSection(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::LinearShuntCompensator* element = dynamic_cast<IEC61970::Base::Wires::LinearShuntCompensator*>(base_class_ptr))
	{
		buffer >> element->g0PerSection.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LinearShuntCompensator.gPerSection
bool assign_LinearShuntCompensator_gPerSection(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::LinearShuntCompensator* element = dynamic_cast<IEC61970::Base::Wires::LinearShuntCompensator*>(base_class_ptr))
	{
		buffer >> element->gPerSection.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LinearShuntCompensatorPhase.bPerSection
bool assign_LinearShuntCompensatorPhase_bPerSection(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::LinearShuntCompensatorPhase* element = dynamic_cast<IEC61970::Base::Wires::LinearShuntCompensatorPhase*>(base_class_ptr))
	{
		buffer >> element->bPerSection.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LinearShuntCompensatorPhase.gPerSection
bool assign_LinearShuntCompensatorPhase_gPerSection(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::LinearShuntCompensatorPhase* element = dynamic_cast<IEC61970::Base::Wires::LinearShuntCompensatorPhase*>(base_class_ptr))
	{
		buffer >> element->gPerSection.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:MutualCoupling.b0ch
bool assign_MutualCoupling_b0ch(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::MutualCoupling* element = dynamic_cast<IEC61970::Base::Wires::MutualCoupling*>(base_class_ptr))
	{
		buffer >> element->b0ch.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:MutualCoupling.distance11
bool assign_MutualCoupling_distance11(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::MutualCoupling* element = dynamic_cast<IEC61970::Base::Wires::MutualCoupling*>(base_class_ptr))
	{
		buffer >> element->distance11.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:MutualCoupling.distance12
bool assign_MutualCoupling_distance12(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::MutualCoupling* element = dynamic_cast<IEC61970::Base::Wires::MutualCoupling*>(base_class_ptr))
	{
		buffer >> element->distance12.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:MutualCoupling.distance21
bool assign_MutualCoupling_distance21(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::MutualCoupling* element = dynamic_cast<IEC61970::Base::Wires::MutualCoupling*>(base_class_ptr))
	{
		buffer >> element->distance21.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:MutualCoupling.distance22
bool assign_MutualCoupling_distance22(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::MutualCoupling* element = dynamic_cast<IEC61970::Base::Wires::MutualCoupling*>(base_class_ptr))
	{
		buffer >> element->distance22.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:MutualCoupling.g0ch
bool assign_MutualCoupling_g0ch(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::MutualCoupling* element = dynamic_cast<IEC61970::Base::Wires::MutualCoupling*>(base_class_ptr))
	{
		buffer >> element->g0ch.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:MutualCoupling.r0
bool assign_MutualCoupling_r0(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::MutualCoupling* element = dynamic_cast<IEC61970::Base::Wires::MutualCoupling*>(base_class_ptr))
	{
		buffer >> element->r0.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:MutualCoupling.x0
bool assign_MutualCoupling_x0(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::MutualCoupling* element = dynamic_cast<IEC61970::Base::Wires::MutualCoupling*>(base_class_ptr))
	{
		buffer >> element->x0.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:NonlinearShuntCompensatorPoint.b
bool assign_NonlinearShuntCompensatorPoint_b(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::NonlinearShuntCompensatorPoint* element = dynamic_cast<IEC61970::Base::Wires::NonlinearShuntCompensatorPoint*>(base_class_ptr))
	{
		buffer >> element->b.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:NonlinearShuntCompensatorPoint.b0
bool assign_NonlinearShuntCompensatorPoint_b0(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::NonlinearShuntCompensatorPoint* element = dynamic_cast<IEC61970::Base::Wires::NonlinearShuntCompensatorPoint*>(base_class_ptr))
	{
		buffer >> element->b0.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:NonlinearShuntCompensatorPoint.g
bool assign_NonlinearShuntCompensatorPoint_g(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::NonlinearShuntCompensatorPoint* element = dynamic_cast<IEC61970::Base::Wires::NonlinearShuntCompensatorPoint*>(base_class_ptr))
	{
		buffer >> element->g.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:NonlinearShuntCompensatorPoint.g0
bool assign_NonlinearShuntCompensatorPoint_g0(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::NonlinearShuntCompensatorPoint* element = dynamic_cast<IEC61970::Base::Wires::NonlinearShuntCompensatorPoint*>(base_class_ptr))
	{
		buffer >> element->g0.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:NonlinearShuntCompensatorPoint.sectionNumber
bool assign_NonlinearShuntCompensatorPoint_sectionNumber(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::NonlinearShuntCompensatorPoint* element = dynamic_cast<IEC61970::Base::Wires::NonlinearShuntCompensatorPoint*>(base_class_ptr))
	{
		buffer >> element->sectionNumber;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:NonlinearShuntCompensatorPhasePoint.b
bool assign_NonlinearShuntCompensatorPhasePoint_b(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::NonlinearShuntCompensatorPhasePoint* element = dynamic_cast<IEC61970::Base::Wires::NonlinearShuntCompensatorPhasePoint*>(base_class_ptr))
	{
		buffer >> element->b.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:NonlinearShuntCompensatorPhasePoint.g
bool assign_NonlinearShuntCompensatorPhasePoint_g(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::NonlinearShuntCompensatorPhasePoint* element = dynamic_cast<IEC61970::Base::Wires::NonlinearShuntCompensatorPhasePoint*>(base_class_ptr))
	{
		buffer >> element->g.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:NonlinearShuntCompensatorPhasePoint.sectionNumber
bool assign_NonlinearShuntCompensatorPhasePoint_sectionNumber(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::NonlinearShuntCompensatorPhasePoint* element = dynamic_cast<IEC61970::Base::Wires::NonlinearShuntCompensatorPhasePoint*>(base_class_ptr))
	{
		buffer >> element->sectionNumber;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:NonRotatingEnergy.maxP
bool assign_NonRotatingEnergy_maxP(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::NonRotatingEnergy* element = dynamic_cast<IEC61970::Base::Wires::NonRotatingEnergy*>(base_class_ptr))
	{
		buffer >> element->maxP.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:NonRotatingEnergy.maxQ
bool assign_NonRotatingEnergy_maxQ(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::NonRotatingEnergy* element = dynamic_cast<IEC61970::Base::Wires::NonRotatingEnergy*>(base_class_ptr))
	{
		buffer >> element->maxQ.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:NonRotatingEnergy.minP
bool assign_NonRotatingEnergy_minP(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::NonRotatingEnergy* element = dynamic_cast<IEC61970::Base::Wires::NonRotatingEnergy*>(base_class_ptr))
	{
		buffer >> element->minP.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:NonRotatingEnergy.minQ
bool assign_NonRotatingEnergy_minQ(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::NonRotatingEnergy* element = dynamic_cast<IEC61970::Base::Wires::NonRotatingEnergy*>(base_class_ptr))
	{
		buffer >> element->minQ.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:NonRotatingEnergy.p
bool assign_NonRotatingEnergy_p(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::NonRotatingEnergy* element = dynamic_cast<IEC61970::Base::Wires::NonRotatingEnergy*>(base_class_ptr))
	{
		buffer >> element->p.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:NonRotatingEnergy.q
bool assign_NonRotatingEnergy_q(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::NonRotatingEnergy* element = dynamic_cast<IEC61970::Base::Wires::NonRotatingEnergy*>(base_class_ptr))
	{
		buffer >> element->q.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:NonRotatingEnergy.r
bool assign_NonRotatingEnergy_r(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::NonRotatingEnergy* element = dynamic_cast<IEC61970::Base::Wires::NonRotatingEnergy*>(base_class_ptr))
	{
		buffer >> element->r.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:NonRotatingEnergy.r0
bool assign_NonRotatingEnergy_r0(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::NonRotatingEnergy* element = dynamic_cast<IEC61970::Base::Wires::NonRotatingEnergy*>(base_class_ptr))
	{
		buffer >> element->r0.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:NonRotatingEnergy.rn
bool assign_NonRotatingEnergy_rn(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::NonRotatingEnergy* element = dynamic_cast<IEC61970::Base::Wires::NonRotatingEnergy*>(base_class_ptr))
	{
		buffer >> element->rn.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:NonRotatingEnergy.x
bool assign_NonRotatingEnergy_x(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::NonRotatingEnergy* element = dynamic_cast<IEC61970::Base::Wires::NonRotatingEnergy*>(base_class_ptr))
	{
		buffer >> element->x.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:NonRotatingEnergy.x0
bool assign_NonRotatingEnergy_x0(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::NonRotatingEnergy* element = dynamic_cast<IEC61970::Base::Wires::NonRotatingEnergy*>(base_class_ptr))
	{
		buffer >> element->x0.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:NonRotatingEnergy.xn
bool assign_NonRotatingEnergy_xn(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::NonRotatingEnergy* element = dynamic_cast<IEC61970::Base::Wires::NonRotatingEnergy*>(base_class_ptr))
	{
		buffer >> element->xn.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PhaseImpedanceData.b
bool assign_PhaseImpedanceData_b(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::PhaseImpedanceData* element = dynamic_cast<IEC61970::Base::Wires::PhaseImpedanceData*>(base_class_ptr))
	{
		buffer >> element->b.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PhaseImpedanceData.r
bool assign_PhaseImpedanceData_r(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::PhaseImpedanceData* element = dynamic_cast<IEC61970::Base::Wires::PhaseImpedanceData*>(base_class_ptr))
	{
		buffer >> element->r.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PhaseImpedanceData.sequenceNumber
bool assign_PhaseImpedanceData_sequenceNumber(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::PhaseImpedanceData* element = dynamic_cast<IEC61970::Base::Wires::PhaseImpedanceData*>(base_class_ptr))
	{
		buffer >> element->sequenceNumber;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PhaseImpedanceData.x
bool assign_PhaseImpedanceData_x(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::PhaseImpedanceData* element = dynamic_cast<IEC61970::Base::Wires::PhaseImpedanceData*>(base_class_ptr))
	{
		buffer >> element->x.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PerLengthPhaseImpedance.conductorCount
bool assign_PerLengthPhaseImpedance_conductorCount(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::PerLengthPhaseImpedance* element = dynamic_cast<IEC61970::Base::Wires::PerLengthPhaseImpedance*>(base_class_ptr))
	{
		buffer >> element->conductorCount;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PerLengthSequenceImpedance.b0ch
bool assign_PerLengthSequenceImpedance_b0ch(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::PerLengthSequenceImpedance* element = dynamic_cast<IEC61970::Base::Wires::PerLengthSequenceImpedance*>(base_class_ptr))
	{
		buffer >> element->b0ch.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PerLengthSequenceImpedance.bch
bool assign_PerLengthSequenceImpedance_bch(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::PerLengthSequenceImpedance* element = dynamic_cast<IEC61970::Base::Wires::PerLengthSequenceImpedance*>(base_class_ptr))
	{
		buffer >> element->bch.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PerLengthSequenceImpedance.g0ch
bool assign_PerLengthSequenceImpedance_g0ch(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::PerLengthSequenceImpedance* element = dynamic_cast<IEC61970::Base::Wires::PerLengthSequenceImpedance*>(base_class_ptr))
	{
		buffer >> element->g0ch.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PerLengthSequenceImpedance.gch
bool assign_PerLengthSequenceImpedance_gch(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::PerLengthSequenceImpedance* element = dynamic_cast<IEC61970::Base::Wires::PerLengthSequenceImpedance*>(base_class_ptr))
	{
		buffer >> element->gch.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PerLengthSequenceImpedance.r
bool assign_PerLengthSequenceImpedance_r(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::PerLengthSequenceImpedance* element = dynamic_cast<IEC61970::Base::Wires::PerLengthSequenceImpedance*>(base_class_ptr))
	{
		buffer >> element->r.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PerLengthSequenceImpedance.r0
bool assign_PerLengthSequenceImpedance_r0(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::PerLengthSequenceImpedance* element = dynamic_cast<IEC61970::Base::Wires::PerLengthSequenceImpedance*>(base_class_ptr))
	{
		buffer >> element->r0.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PerLengthSequenceImpedance.x
bool assign_PerLengthSequenceImpedance_x(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::PerLengthSequenceImpedance* element = dynamic_cast<IEC61970::Base::Wires::PerLengthSequenceImpedance*>(base_class_ptr))
	{
		buffer >> element->x.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PerLengthSequenceImpedance.x0
bool assign_PerLengthSequenceImpedance_x0(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::PerLengthSequenceImpedance* element = dynamic_cast<IEC61970::Base::Wires::PerLengthSequenceImpedance*>(base_class_ptr))
	{
		buffer >> element->x0.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PetersenCoil.mode
bool assign_PetersenCoil_mode(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::PetersenCoil* element = dynamic_cast<IEC61970::Base::Wires::PetersenCoil*>(base_class_ptr))
	{
		buffer >> element->mode;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PetersenCoil.nominalU
bool assign_PetersenCoil_nominalU(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::PetersenCoil* element = dynamic_cast<IEC61970::Base::Wires::PetersenCoil*>(base_class_ptr))
	{
		buffer >> element->nominalU.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PetersenCoil.offsetCurrent
bool assign_PetersenCoil_offsetCurrent(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::PetersenCoil* element = dynamic_cast<IEC61970::Base::Wires::PetersenCoil*>(base_class_ptr))
	{
		buffer >> element->offsetCurrent.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PetersenCoil.positionCurrent
bool assign_PetersenCoil_positionCurrent(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::PetersenCoil* element = dynamic_cast<IEC61970::Base::Wires::PetersenCoil*>(base_class_ptr))
	{
		buffer >> element->positionCurrent.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PetersenCoil.xGroundMax
bool assign_PetersenCoil_xGroundMax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::PetersenCoil* element = dynamic_cast<IEC61970::Base::Wires::PetersenCoil*>(base_class_ptr))
	{
		buffer >> element->xGroundMax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PetersenCoil.xGroundMin
bool assign_PetersenCoil_xGroundMin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::PetersenCoil* element = dynamic_cast<IEC61970::Base::Wires::PetersenCoil*>(base_class_ptr))
	{
		buffer >> element->xGroundMin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PetersenCoil.xGroundNominal
bool assign_PetersenCoil_xGroundNominal(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::PetersenCoil* element = dynamic_cast<IEC61970::Base::Wires::PetersenCoil*>(base_class_ptr))
	{
		buffer >> element->xGroundNominal.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PhaseTapChangerNonLinear.voltageStepIncrement
bool assign_PhaseTapChangerNonLinear_voltageStepIncrement(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::PhaseTapChangerNonLinear* element = dynamic_cast<IEC61970::Base::Wires::PhaseTapChangerNonLinear*>(base_class_ptr))
	{
		buffer >> element->voltageStepIncrement.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PhaseTapChangerNonLinear.xMax
bool assign_PhaseTapChangerNonLinear_xMax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::PhaseTapChangerNonLinear* element = dynamic_cast<IEC61970::Base::Wires::PhaseTapChangerNonLinear*>(base_class_ptr))
	{
		buffer >> element->xMax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PhaseTapChangerNonLinear.xMin
bool assign_PhaseTapChangerNonLinear_xMin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::PhaseTapChangerNonLinear* element = dynamic_cast<IEC61970::Base::Wires::PhaseTapChangerNonLinear*>(base_class_ptr))
	{
		buffer >> element->xMin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PhaseTapChangerAsymmetrical.windingConnectionAngle
bool assign_PhaseTapChangerAsymmetrical_windingConnectionAngle(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::PhaseTapChangerAsymmetrical* element = dynamic_cast<IEC61970::Base::Wires::PhaseTapChangerAsymmetrical*>(base_class_ptr))
	{
		buffer >> element->windingConnectionAngle.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PhaseTapChangerLinear.stepPhaseShiftIncrement
bool assign_PhaseTapChangerLinear_stepPhaseShiftIncrement(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::PhaseTapChangerLinear* element = dynamic_cast<IEC61970::Base::Wires::PhaseTapChangerLinear*>(base_class_ptr))
	{
		buffer >> element->stepPhaseShiftIncrement.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PhaseTapChangerLinear.xMax
bool assign_PhaseTapChangerLinear_xMax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::PhaseTapChangerLinear* element = dynamic_cast<IEC61970::Base::Wires::PhaseTapChangerLinear*>(base_class_ptr))
	{
		buffer >> element->xMax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PhaseTapChangerLinear.xMin
bool assign_PhaseTapChangerLinear_xMin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::PhaseTapChangerLinear* element = dynamic_cast<IEC61970::Base::Wires::PhaseTapChangerLinear*>(base_class_ptr))
	{
		buffer >> element->xMin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TapChangerTablePoint.b
bool assign_TapChangerTablePoint_b(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::TapChangerTablePoint* element = dynamic_cast<IEC61970::Base::Wires::TapChangerTablePoint*>(base_class_ptr))
	{
		buffer >> element->b.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TapChangerTablePoint.g
bool assign_TapChangerTablePoint_g(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::TapChangerTablePoint* element = dynamic_cast<IEC61970::Base::Wires::TapChangerTablePoint*>(base_class_ptr))
	{
		buffer >> element->g.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TapChangerTablePoint.r
bool assign_TapChangerTablePoint_r(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::TapChangerTablePoint* element = dynamic_cast<IEC61970::Base::Wires::TapChangerTablePoint*>(base_class_ptr))
	{
		buffer >> element->r.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TapChangerTablePoint.ratio
bool assign_TapChangerTablePoint_ratio(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::TapChangerTablePoint* element = dynamic_cast<IEC61970::Base::Wires::TapChangerTablePoint*>(base_class_ptr))
	{
		buffer >> element->ratio;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TapChangerTablePoint.step
bool assign_TapChangerTablePoint_step(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::TapChangerTablePoint* element = dynamic_cast<IEC61970::Base::Wires::TapChangerTablePoint*>(base_class_ptr))
	{
		buffer >> element->step;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TapChangerTablePoint.x
bool assign_TapChangerTablePoint_x(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::TapChangerTablePoint* element = dynamic_cast<IEC61970::Base::Wires::TapChangerTablePoint*>(base_class_ptr))
	{
		buffer >> element->x.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PhaseTapChangerTablePoint.angle
bool assign_PhaseTapChangerTablePoint_angle(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::PhaseTapChangerTablePoint* element = dynamic_cast<IEC61970::Base::Wires::PhaseTapChangerTablePoint*>(base_class_ptr))
	{
		buffer >> element->angle.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TransformerStarImpedance.r
bool assign_TransformerStarImpedance_r(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::TransformerStarImpedance* element = dynamic_cast<IEC61970::Base::Wires::TransformerStarImpedance*>(base_class_ptr))
	{
		buffer >> element->r.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TransformerStarImpedance.r0
bool assign_TransformerStarImpedance_r0(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::TransformerStarImpedance* element = dynamic_cast<IEC61970::Base::Wires::TransformerStarImpedance*>(base_class_ptr))
	{
		buffer >> element->r0.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TransformerStarImpedance.x
bool assign_TransformerStarImpedance_x(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::TransformerStarImpedance* element = dynamic_cast<IEC61970::Base::Wires::TransformerStarImpedance*>(base_class_ptr))
	{
		buffer >> element->x.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TransformerStarImpedance.x0
bool assign_TransformerStarImpedance_x0(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::TransformerStarImpedance* element = dynamic_cast<IEC61970::Base::Wires::TransformerStarImpedance*>(base_class_ptr))
	{
		buffer >> element->x0.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:RatioTapChanger.stepVoltageIncrement
bool assign_RatioTapChanger_stepVoltageIncrement(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::RatioTapChanger* element = dynamic_cast<IEC61970::Base::Wires::RatioTapChanger*>(base_class_ptr))
	{
		buffer >> element->stepVoltageIncrement.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:RatioTapChanger.tculControlMode
bool assign_RatioTapChanger_tculControlMode(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::RatioTapChanger* element = dynamic_cast<IEC61970::Base::Wires::RatioTapChanger*>(base_class_ptr))
	{
		buffer >> element->tculControlMode;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TransformerEnd.bmagSat
bool assign_TransformerEnd_bmagSat(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::TransformerEnd* element = dynamic_cast<IEC61970::Base::Wires::TransformerEnd*>(base_class_ptr))
	{
		buffer >> element->bmagSat.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TransformerEnd.endNumber
bool assign_TransformerEnd_endNumber(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::TransformerEnd* element = dynamic_cast<IEC61970::Base::Wires::TransformerEnd*>(base_class_ptr))
	{
		buffer >> element->endNumber;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TransformerEnd.grounded
bool assign_TransformerEnd_grounded(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::TransformerEnd* element = dynamic_cast<IEC61970::Base::Wires::TransformerEnd*>(base_class_ptr))
	{
		buffer >> element->grounded;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TransformerEnd.magBaseU
bool assign_TransformerEnd_magBaseU(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::TransformerEnd* element = dynamic_cast<IEC61970::Base::Wires::TransformerEnd*>(base_class_ptr))
	{
		buffer >> element->magBaseU.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TransformerEnd.magSatFlux
bool assign_TransformerEnd_magSatFlux(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::TransformerEnd* element = dynamic_cast<IEC61970::Base::Wires::TransformerEnd*>(base_class_ptr))
	{
		buffer >> element->magSatFlux.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TransformerEnd.rground
bool assign_TransformerEnd_rground(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::TransformerEnd* element = dynamic_cast<IEC61970::Base::Wires::TransformerEnd*>(base_class_ptr))
	{
		buffer >> element->rground.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TransformerEnd.xground
bool assign_TransformerEnd_xground(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::TransformerEnd* element = dynamic_cast<IEC61970::Base::Wires::TransformerEnd*>(base_class_ptr))
	{
		buffer >> element->xground.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PowerTransformerEnd.b
bool assign_PowerTransformerEnd_b(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::PowerTransformerEnd* element = dynamic_cast<IEC61970::Base::Wires::PowerTransformerEnd*>(base_class_ptr))
	{
		buffer >> element->b.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PowerTransformerEnd.b0
bool assign_PowerTransformerEnd_b0(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::PowerTransformerEnd* element = dynamic_cast<IEC61970::Base::Wires::PowerTransformerEnd*>(base_class_ptr))
	{
		buffer >> element->b0.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PowerTransformerEnd.connectionKind
bool assign_PowerTransformerEnd_connectionKind(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::PowerTransformerEnd* element = dynamic_cast<IEC61970::Base::Wires::PowerTransformerEnd*>(base_class_ptr))
	{
		buffer >> element->connectionKind;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PowerTransformerEnd.g
bool assign_PowerTransformerEnd_g(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::PowerTransformerEnd* element = dynamic_cast<IEC61970::Base::Wires::PowerTransformerEnd*>(base_class_ptr))
	{
		buffer >> element->g.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PowerTransformerEnd.g0
bool assign_PowerTransformerEnd_g0(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::PowerTransformerEnd* element = dynamic_cast<IEC61970::Base::Wires::PowerTransformerEnd*>(base_class_ptr))
	{
		buffer >> element->g0.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PowerTransformerEnd.phaseAngleClock
bool assign_PowerTransformerEnd_phaseAngleClock(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::PowerTransformerEnd* element = dynamic_cast<IEC61970::Base::Wires::PowerTransformerEnd*>(base_class_ptr))
	{
		buffer >> element->phaseAngleClock;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PowerTransformerEnd.r
bool assign_PowerTransformerEnd_r(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::PowerTransformerEnd* element = dynamic_cast<IEC61970::Base::Wires::PowerTransformerEnd*>(base_class_ptr))
	{
		buffer >> element->r.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PowerTransformerEnd.r0
bool assign_PowerTransformerEnd_r0(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::PowerTransformerEnd* element = dynamic_cast<IEC61970::Base::Wires::PowerTransformerEnd*>(base_class_ptr))
	{
		buffer >> element->r0.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PowerTransformerEnd.ratedS
bool assign_PowerTransformerEnd_ratedS(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::PowerTransformerEnd* element = dynamic_cast<IEC61970::Base::Wires::PowerTransformerEnd*>(base_class_ptr))
	{
		buffer >> element->ratedS.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PowerTransformerEnd.ratedU
bool assign_PowerTransformerEnd_ratedU(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::PowerTransformerEnd* element = dynamic_cast<IEC61970::Base::Wires::PowerTransformerEnd*>(base_class_ptr))
	{
		buffer >> element->ratedU.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PowerTransformerEnd.x
bool assign_PowerTransformerEnd_x(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::PowerTransformerEnd* element = dynamic_cast<IEC61970::Base::Wires::PowerTransformerEnd*>(base_class_ptr))
	{
		buffer >> element->x.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PowerTransformerEnd.x0
bool assign_PowerTransformerEnd_x0(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::PowerTransformerEnd* element = dynamic_cast<IEC61970::Base::Wires::PowerTransformerEnd*>(base_class_ptr))
	{
		buffer >> element->x0.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PowerTransformer.beforeShCircuitHighestOperatingCurrent
bool assign_PowerTransformer_beforeShCircuitHighestOperatingCurrent(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::PowerTransformer* element = dynamic_cast<IEC61970::Base::Wires::PowerTransformer*>(base_class_ptr))
	{
		buffer >> element->beforeShCircuitHighestOperatingCurrent.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PowerTransformer.beforeShCircuitHighestOperatingVoltage
bool assign_PowerTransformer_beforeShCircuitHighestOperatingVoltage(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::PowerTransformer* element = dynamic_cast<IEC61970::Base::Wires::PowerTransformer*>(base_class_ptr))
	{
		buffer >> element->beforeShCircuitHighestOperatingVoltage.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PowerTransformer.beforeShortCircuitAnglePf
bool assign_PowerTransformer_beforeShortCircuitAnglePf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::PowerTransformer* element = dynamic_cast<IEC61970::Base::Wires::PowerTransformer*>(base_class_ptr))
	{
		buffer >> element->beforeShortCircuitAnglePf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PowerTransformer.highSideMinOperatingU
bool assign_PowerTransformer_highSideMinOperatingU(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::PowerTransformer* element = dynamic_cast<IEC61970::Base::Wires::PowerTransformer*>(base_class_ptr))
	{
		buffer >> element->highSideMinOperatingU.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PowerTransformer.isPartOfGeneratorUnit
bool assign_PowerTransformer_isPartOfGeneratorUnit(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::PowerTransformer* element = dynamic_cast<IEC61970::Base::Wires::PowerTransformer*>(base_class_ptr))
	{
		buffer >> element->isPartOfGeneratorUnit;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PowerTransformer.operationalValuesConsidered
bool assign_PowerTransformer_operationalValuesConsidered(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::PowerTransformer* element = dynamic_cast<IEC61970::Base::Wires::PowerTransformer*>(base_class_ptr))
	{
		buffer >> element->operationalValuesConsidered;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PowerTransformer.vectorGroup
bool assign_PowerTransformer_vectorGroup(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::PowerTransformer* element = dynamic_cast<IEC61970::Base::Wires::PowerTransformer*>(base_class_ptr))
	{
		element->vectorGroup = buffer.str();
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ReactiveCapabilityCurve.coolantTemperature
bool assign_ReactiveCapabilityCurve_coolantTemperature(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::ReactiveCapabilityCurve* element = dynamic_cast<IEC61970::Base::Wires::ReactiveCapabilityCurve*>(base_class_ptr))
	{
		buffer >> element->coolantTemperature.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ReactiveCapabilityCurve.hydrogenPressure
bool assign_ReactiveCapabilityCurve_hydrogenPressure(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::ReactiveCapabilityCurve* element = dynamic_cast<IEC61970::Base::Wires::ReactiveCapabilityCurve*>(base_class_ptr))
	{
		buffer >> element->hydrogenPressure.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SeriesCompensator.r
bool assign_SeriesCompensator_r(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::SeriesCompensator* element = dynamic_cast<IEC61970::Base::Wires::SeriesCompensator*>(base_class_ptr))
	{
		buffer >> element->r.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SeriesCompensator.r0
bool assign_SeriesCompensator_r0(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::SeriesCompensator* element = dynamic_cast<IEC61970::Base::Wires::SeriesCompensator*>(base_class_ptr))
	{
		buffer >> element->r0.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SeriesCompensator.varistorPresent
bool assign_SeriesCompensator_varistorPresent(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::SeriesCompensator* element = dynamic_cast<IEC61970::Base::Wires::SeriesCompensator*>(base_class_ptr))
	{
		buffer >> element->varistorPresent;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SeriesCompensator.varistorRatedCurrent
bool assign_SeriesCompensator_varistorRatedCurrent(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::SeriesCompensator* element = dynamic_cast<IEC61970::Base::Wires::SeriesCompensator*>(base_class_ptr))
	{
		buffer >> element->varistorRatedCurrent.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SeriesCompensator.varistorVoltageThreshold
bool assign_SeriesCompensator_varistorVoltageThreshold(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::SeriesCompensator* element = dynamic_cast<IEC61970::Base::Wires::SeriesCompensator*>(base_class_ptr))
	{
		buffer >> element->varistorVoltageThreshold.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SeriesCompensator.x
bool assign_SeriesCompensator_x(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::SeriesCompensator* element = dynamic_cast<IEC61970::Base::Wires::SeriesCompensator*>(base_class_ptr))
	{
		buffer >> element->x.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SeriesCompensator.x0
bool assign_SeriesCompensator_x0(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::SeriesCompensator* element = dynamic_cast<IEC61970::Base::Wires::SeriesCompensator*>(base_class_ptr))
	{
		buffer >> element->x0.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:StaticVarCompensator.capacitiveRating
bool assign_StaticVarCompensator_capacitiveRating(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::StaticVarCompensator* element = dynamic_cast<IEC61970::Base::Wires::StaticVarCompensator*>(base_class_ptr))
	{
		buffer >> element->capacitiveRating.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:StaticVarCompensator.inductiveRating
bool assign_StaticVarCompensator_inductiveRating(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::StaticVarCompensator* element = dynamic_cast<IEC61970::Base::Wires::StaticVarCompensator*>(base_class_ptr))
	{
		buffer >> element->inductiveRating.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:StaticVarCompensator.q
bool assign_StaticVarCompensator_q(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::StaticVarCompensator* element = dynamic_cast<IEC61970::Base::Wires::StaticVarCompensator*>(base_class_ptr))
	{
		buffer >> element->q.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:StaticVarCompensator.slope
bool assign_StaticVarCompensator_slope(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::StaticVarCompensator* element = dynamic_cast<IEC61970::Base::Wires::StaticVarCompensator*>(base_class_ptr))
	{
		buffer >> element->slope.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:StaticVarCompensator.sVCControlMode
bool assign_StaticVarCompensator_sVCControlMode(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::StaticVarCompensator* element = dynamic_cast<IEC61970::Base::Wires::StaticVarCompensator*>(base_class_ptr))
	{
		buffer >> element->sVCControlMode;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:StaticVarCompensator.voltageSetPoint
bool assign_StaticVarCompensator_voltageSetPoint(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::StaticVarCompensator* element = dynamic_cast<IEC61970::Base::Wires::StaticVarCompensator*>(base_class_ptr))
	{
		buffer >> element->voltageSetPoint.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TransformerCoreAdmittance.b
bool assign_TransformerCoreAdmittance_b(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::TransformerCoreAdmittance* element = dynamic_cast<IEC61970::Base::Wires::TransformerCoreAdmittance*>(base_class_ptr))
	{
		buffer >> element->b.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TransformerCoreAdmittance.b0
bool assign_TransformerCoreAdmittance_b0(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::TransformerCoreAdmittance* element = dynamic_cast<IEC61970::Base::Wires::TransformerCoreAdmittance*>(base_class_ptr))
	{
		buffer >> element->b0.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TransformerCoreAdmittance.g
bool assign_TransformerCoreAdmittance_g(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::TransformerCoreAdmittance* element = dynamic_cast<IEC61970::Base::Wires::TransformerCoreAdmittance*>(base_class_ptr))
	{
		buffer >> element->g.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TransformerCoreAdmittance.g0
bool assign_TransformerCoreAdmittance_g0(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::TransformerCoreAdmittance* element = dynamic_cast<IEC61970::Base::Wires::TransformerCoreAdmittance*>(base_class_ptr))
	{
		buffer >> element->g0.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TransformerMeshImpedance.r
bool assign_TransformerMeshImpedance_r(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::TransformerMeshImpedance* element = dynamic_cast<IEC61970::Base::Wires::TransformerMeshImpedance*>(base_class_ptr))
	{
		buffer >> element->r.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TransformerMeshImpedance.r0
bool assign_TransformerMeshImpedance_r0(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::TransformerMeshImpedance* element = dynamic_cast<IEC61970::Base::Wires::TransformerMeshImpedance*>(base_class_ptr))
	{
		buffer >> element->r0.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TransformerMeshImpedance.x
bool assign_TransformerMeshImpedance_x(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::TransformerMeshImpedance* element = dynamic_cast<IEC61970::Base::Wires::TransformerMeshImpedance*>(base_class_ptr))
	{
		buffer >> element->x.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TransformerMeshImpedance.x0
bool assign_TransformerMeshImpedance_x0(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::TransformerMeshImpedance* element = dynamic_cast<IEC61970::Base::Wires::TransformerMeshImpedance*>(base_class_ptr))
	{
		buffer >> element->x0.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TransformerTankEnd.phases
bool assign_TransformerTankEnd_phases(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Base::Wires::TransformerTankEnd* element = dynamic_cast<IEC61970::Base::Wires::TransformerTankEnd*>(base_class_ptr))
	{
		buffer >> element->phases;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:RemoteInputSignal.remoteSignalType
bool assign_RemoteInputSignal_remoteSignalType(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardInterconnections::RemoteInputSignal* element = dynamic_cast<IEC61970::Dynamics::StandardInterconnections::RemoteInputSignal*>(base_class_ptr))
	{
		buffer >> element->remoteSignalType;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:DynamicsFunctionBlock.enabled
bool assign_DynamicsFunctionBlock_enabled(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::DynamicsFunctionBlock* element = dynamic_cast<IEC61970::Dynamics::StandardModels::DynamicsFunctionBlock*>(base_class_ptr))
	{
		buffer >> element->enabled;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:RotatingMachineDynamics.damping
bool assign_RotatingMachineDynamics_damping(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::RotatingMachineDynamics* element = dynamic_cast<IEC61970::Dynamics::StandardModels::RotatingMachineDynamics*>(base_class_ptr))
	{
		buffer >> element->damping;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:RotatingMachineDynamics.inertia
bool assign_RotatingMachineDynamics_inertia(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::RotatingMachineDynamics* element = dynamic_cast<IEC61970::Dynamics::StandardModels::RotatingMachineDynamics*>(base_class_ptr))
	{
		buffer >> element->inertia.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:RotatingMachineDynamics.saturationFactor
bool assign_RotatingMachineDynamics_saturationFactor(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::RotatingMachineDynamics* element = dynamic_cast<IEC61970::Dynamics::StandardModels::RotatingMachineDynamics*>(base_class_ptr))
	{
		buffer >> element->saturationFactor;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:RotatingMachineDynamics.saturationFactor120
bool assign_RotatingMachineDynamics_saturationFactor120(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::RotatingMachineDynamics* element = dynamic_cast<IEC61970::Dynamics::StandardModels::RotatingMachineDynamics*>(base_class_ptr))
	{
		buffer >> element->saturationFactor120;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:RotatingMachineDynamics.statorLeakageReactance
bool assign_RotatingMachineDynamics_statorLeakageReactance(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::RotatingMachineDynamics* element = dynamic_cast<IEC61970::Dynamics::StandardModels::RotatingMachineDynamics*>(base_class_ptr))
	{
		buffer >> element->statorLeakageReactance.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:RotatingMachineDynamics.statorResistance
bool assign_RotatingMachineDynamics_statorResistance(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::RotatingMachineDynamics* element = dynamic_cast<IEC61970::Dynamics::StandardModels::RotatingMachineDynamics*>(base_class_ptr))
	{
		buffer >> element->statorResistance.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:AsynchronousMachineEquivalentCircuit.rr1
bool assign_AsynchronousMachineEquivalentCircuit_rr1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::AsynchronousMachineDynamics::AsynchronousMachineEquivalentCircuit* element = dynamic_cast<IEC61970::Dynamics::StandardModels::AsynchronousMachineDynamics::AsynchronousMachineEquivalentCircuit*>(base_class_ptr))
	{
		buffer >> element->rr1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:AsynchronousMachineEquivalentCircuit.rr2
bool assign_AsynchronousMachineEquivalentCircuit_rr2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::AsynchronousMachineDynamics::AsynchronousMachineEquivalentCircuit* element = dynamic_cast<IEC61970::Dynamics::StandardModels::AsynchronousMachineDynamics::AsynchronousMachineEquivalentCircuit*>(base_class_ptr))
	{
		buffer >> element->rr2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:AsynchronousMachineEquivalentCircuit.xlr1
bool assign_AsynchronousMachineEquivalentCircuit_xlr1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::AsynchronousMachineDynamics::AsynchronousMachineEquivalentCircuit* element = dynamic_cast<IEC61970::Dynamics::StandardModels::AsynchronousMachineDynamics::AsynchronousMachineEquivalentCircuit*>(base_class_ptr))
	{
		buffer >> element->xlr1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:AsynchronousMachineEquivalentCircuit.xlr2
bool assign_AsynchronousMachineEquivalentCircuit_xlr2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::AsynchronousMachineDynamics::AsynchronousMachineEquivalentCircuit* element = dynamic_cast<IEC61970::Dynamics::StandardModels::AsynchronousMachineDynamics::AsynchronousMachineEquivalentCircuit*>(base_class_ptr))
	{
		buffer >> element->xlr2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:AsynchronousMachineEquivalentCircuit.xm
bool assign_AsynchronousMachineEquivalentCircuit_xm(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::AsynchronousMachineDynamics::AsynchronousMachineEquivalentCircuit* element = dynamic_cast<IEC61970::Dynamics::StandardModels::AsynchronousMachineDynamics::AsynchronousMachineEquivalentCircuit*>(base_class_ptr))
	{
		buffer >> element->xm.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:AsynchronousMachineTimeConstantReactance.tpo
bool assign_AsynchronousMachineTimeConstantReactance_tpo(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::AsynchronousMachineDynamics::AsynchronousMachineTimeConstantReactance* element = dynamic_cast<IEC61970::Dynamics::StandardModels::AsynchronousMachineDynamics::AsynchronousMachineTimeConstantReactance*>(base_class_ptr))
	{
		buffer >> element->tpo.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:AsynchronousMachineTimeConstantReactance.tppo
bool assign_AsynchronousMachineTimeConstantReactance_tppo(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::AsynchronousMachineDynamics::AsynchronousMachineTimeConstantReactance* element = dynamic_cast<IEC61970::Dynamics::StandardModels::AsynchronousMachineDynamics::AsynchronousMachineTimeConstantReactance*>(base_class_ptr))
	{
		buffer >> element->tppo.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:AsynchronousMachineTimeConstantReactance.xp
bool assign_AsynchronousMachineTimeConstantReactance_xp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::AsynchronousMachineDynamics::AsynchronousMachineTimeConstantReactance* element = dynamic_cast<IEC61970::Dynamics::StandardModels::AsynchronousMachineDynamics::AsynchronousMachineTimeConstantReactance*>(base_class_ptr))
	{
		buffer >> element->xp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:AsynchronousMachineTimeConstantReactance.xpp
bool assign_AsynchronousMachineTimeConstantReactance_xpp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::AsynchronousMachineDynamics::AsynchronousMachineTimeConstantReactance* element = dynamic_cast<IEC61970::Dynamics::StandardModels::AsynchronousMachineDynamics::AsynchronousMachineTimeConstantReactance*>(base_class_ptr))
	{
		buffer >> element->xpp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:AsynchronousMachineTimeConstantReactance.xs
bool assign_AsynchronousMachineTimeConstantReactance_xs(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::AsynchronousMachineDynamics::AsynchronousMachineTimeConstantReactance* element = dynamic_cast<IEC61970::Dynamics::StandardModels::AsynchronousMachineDynamics::AsynchronousMachineTimeConstantReactance*>(base_class_ptr))
	{
		buffer >> element->xs.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:DiscExcContIEEEDEC1A.esc
bool assign_DiscExcContIEEEDEC1A_esc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::DiscontinuousExcitationControlDynamics::DiscExcContIEEEDEC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::DiscontinuousExcitationControlDynamics::DiscExcContIEEEDEC1A*>(base_class_ptr))
	{
		buffer >> element->esc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:DiscExcContIEEEDEC1A.kan
bool assign_DiscExcContIEEEDEC1A_kan(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::DiscontinuousExcitationControlDynamics::DiscExcContIEEEDEC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::DiscontinuousExcitationControlDynamics::DiscExcContIEEEDEC1A*>(base_class_ptr))
	{
		buffer >> element->kan.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:DiscExcContIEEEDEC1A.ketl
bool assign_DiscExcContIEEEDEC1A_ketl(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::DiscontinuousExcitationControlDynamics::DiscExcContIEEEDEC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::DiscontinuousExcitationControlDynamics::DiscExcContIEEEDEC1A*>(base_class_ptr))
	{
		buffer >> element->ketl.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:DiscExcContIEEEDEC1A.tan
bool assign_DiscExcContIEEEDEC1A_tan(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::DiscontinuousExcitationControlDynamics::DiscExcContIEEEDEC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::DiscontinuousExcitationControlDynamics::DiscExcContIEEEDEC1A*>(base_class_ptr))
	{
		buffer >> element->tan.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:DiscExcContIEEEDEC1A.td
bool assign_DiscExcContIEEEDEC1A_td(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::DiscontinuousExcitationControlDynamics::DiscExcContIEEEDEC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::DiscontinuousExcitationControlDynamics::DiscExcContIEEEDEC1A*>(base_class_ptr))
	{
		buffer >> element->td.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:DiscExcContIEEEDEC1A.tl1
bool assign_DiscExcContIEEEDEC1A_tl1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::DiscontinuousExcitationControlDynamics::DiscExcContIEEEDEC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::DiscontinuousExcitationControlDynamics::DiscExcContIEEEDEC1A*>(base_class_ptr))
	{
		buffer >> element->tl1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:DiscExcContIEEEDEC1A.tl2
bool assign_DiscExcContIEEEDEC1A_tl2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::DiscontinuousExcitationControlDynamics::DiscExcContIEEEDEC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::DiscontinuousExcitationControlDynamics::DiscExcContIEEEDEC1A*>(base_class_ptr))
	{
		buffer >> element->tl2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:DiscExcContIEEEDEC1A.tw5
bool assign_DiscExcContIEEEDEC1A_tw5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::DiscontinuousExcitationControlDynamics::DiscExcContIEEEDEC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::DiscontinuousExcitationControlDynamics::DiscExcContIEEEDEC1A*>(base_class_ptr))
	{
		buffer >> element->tw5.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:DiscExcContIEEEDEC1A.val
bool assign_DiscExcContIEEEDEC1A_val(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::DiscontinuousExcitationControlDynamics::DiscExcContIEEEDEC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::DiscontinuousExcitationControlDynamics::DiscExcContIEEEDEC1A*>(base_class_ptr))
	{
		buffer >> element->val.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:DiscExcContIEEEDEC1A.vanmax
bool assign_DiscExcContIEEEDEC1A_vanmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::DiscontinuousExcitationControlDynamics::DiscExcContIEEEDEC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::DiscontinuousExcitationControlDynamics::DiscExcContIEEEDEC1A*>(base_class_ptr))
	{
		buffer >> element->vanmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:DiscExcContIEEEDEC1A.vomax
bool assign_DiscExcContIEEEDEC1A_vomax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::DiscontinuousExcitationControlDynamics::DiscExcContIEEEDEC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::DiscontinuousExcitationControlDynamics::DiscExcContIEEEDEC1A*>(base_class_ptr))
	{
		buffer >> element->vomax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:DiscExcContIEEEDEC1A.vomin
bool assign_DiscExcContIEEEDEC1A_vomin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::DiscontinuousExcitationControlDynamics::DiscExcContIEEEDEC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::DiscontinuousExcitationControlDynamics::DiscExcContIEEEDEC1A*>(base_class_ptr))
	{
		buffer >> element->vomin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:DiscExcContIEEEDEC1A.vsmax
bool assign_DiscExcContIEEEDEC1A_vsmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::DiscontinuousExcitationControlDynamics::DiscExcContIEEEDEC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::DiscontinuousExcitationControlDynamics::DiscExcContIEEEDEC1A*>(base_class_ptr))
	{
		buffer >> element->vsmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:DiscExcContIEEEDEC1A.vsmin
bool assign_DiscExcContIEEEDEC1A_vsmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::DiscontinuousExcitationControlDynamics::DiscExcContIEEEDEC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::DiscontinuousExcitationControlDynamics::DiscExcContIEEEDEC1A*>(base_class_ptr))
	{
		buffer >> element->vsmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:DiscExcContIEEEDEC1A.vtc
bool assign_DiscExcContIEEEDEC1A_vtc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::DiscontinuousExcitationControlDynamics::DiscExcContIEEEDEC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::DiscontinuousExcitationControlDynamics::DiscExcContIEEEDEC1A*>(base_class_ptr))
	{
		buffer >> element->vtc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:DiscExcContIEEEDEC1A.vtlmt
bool assign_DiscExcContIEEEDEC1A_vtlmt(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::DiscontinuousExcitationControlDynamics::DiscExcContIEEEDEC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::DiscontinuousExcitationControlDynamics::DiscExcContIEEEDEC1A*>(base_class_ptr))
	{
		buffer >> element->vtlmt.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:DiscExcContIEEEDEC1A.vtm
bool assign_DiscExcContIEEEDEC1A_vtm(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::DiscontinuousExcitationControlDynamics::DiscExcContIEEEDEC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::DiscontinuousExcitationControlDynamics::DiscExcContIEEEDEC1A*>(base_class_ptr))
	{
		buffer >> element->vtm.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:DiscExcContIEEEDEC1A.vtn
bool assign_DiscExcContIEEEDEC1A_vtn(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::DiscontinuousExcitationControlDynamics::DiscExcContIEEEDEC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::DiscontinuousExcitationControlDynamics::DiscExcContIEEEDEC1A*>(base_class_ptr))
	{
		buffer >> element->vtn.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:DiscExcContIEEEDEC2A.td1
bool assign_DiscExcContIEEEDEC2A_td1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::DiscontinuousExcitationControlDynamics::DiscExcContIEEEDEC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::DiscontinuousExcitationControlDynamics::DiscExcContIEEEDEC2A*>(base_class_ptr))
	{
		buffer >> element->td1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:DiscExcContIEEEDEC2A.td2
bool assign_DiscExcContIEEEDEC2A_td2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::DiscontinuousExcitationControlDynamics::DiscExcContIEEEDEC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::DiscontinuousExcitationControlDynamics::DiscExcContIEEEDEC2A*>(base_class_ptr))
	{
		buffer >> element->td2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:DiscExcContIEEEDEC2A.vdmax
bool assign_DiscExcContIEEEDEC2A_vdmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::DiscontinuousExcitationControlDynamics::DiscExcContIEEEDEC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::DiscontinuousExcitationControlDynamics::DiscExcContIEEEDEC2A*>(base_class_ptr))
	{
		buffer >> element->vdmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:DiscExcContIEEEDEC2A.vdmin
bool assign_DiscExcContIEEEDEC2A_vdmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::DiscontinuousExcitationControlDynamics::DiscExcContIEEEDEC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::DiscontinuousExcitationControlDynamics::DiscExcContIEEEDEC2A*>(base_class_ptr))
	{
		buffer >> element->vdmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:DiscExcContIEEEDEC2A.vk
bool assign_DiscExcContIEEEDEC2A_vk(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::DiscontinuousExcitationControlDynamics::DiscExcContIEEEDEC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::DiscontinuousExcitationControlDynamics::DiscExcContIEEEDEC2A*>(base_class_ptr))
	{
		buffer >> element->vk.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:DiscExcContIEEEDEC3A.tdr
bool assign_DiscExcContIEEEDEC3A_tdr(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::DiscontinuousExcitationControlDynamics::DiscExcContIEEEDEC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::DiscontinuousExcitationControlDynamics::DiscExcContIEEEDEC3A*>(base_class_ptr))
	{
		buffer >> element->tdr.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:DiscExcContIEEEDEC3A.vtmin
bool assign_DiscExcContIEEEDEC3A_vtmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::DiscontinuousExcitationControlDynamics::DiscExcContIEEEDEC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::DiscontinuousExcitationControlDynamics::DiscExcContIEEEDEC3A*>(base_class_ptr))
	{
		buffer >> element->vtmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC1A.hvlvgates
bool assign_ExcAC1A_hvlvgates(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC1A*>(base_class_ptr))
	{
		buffer >> element->hvlvgates;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC1A.ka
bool assign_ExcAC1A_ka(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC1A*>(base_class_ptr))
	{
		buffer >> element->ka.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC1A.kc
bool assign_ExcAC1A_kc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC1A*>(base_class_ptr))
	{
		buffer >> element->kc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC1A.kd
bool assign_ExcAC1A_kd(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC1A*>(base_class_ptr))
	{
		buffer >> element->kd.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC1A.ke
bool assign_ExcAC1A_ke(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC1A*>(base_class_ptr))
	{
		buffer >> element->ke.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC1A.kf
bool assign_ExcAC1A_kf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC1A*>(base_class_ptr))
	{
		buffer >> element->kf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC1A.kf1
bool assign_ExcAC1A_kf1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC1A*>(base_class_ptr))
	{
		buffer >> element->kf1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC1A.kf2
bool assign_ExcAC1A_kf2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC1A*>(base_class_ptr))
	{
		buffer >> element->kf2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC1A.ks
bool assign_ExcAC1A_ks(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC1A*>(base_class_ptr))
	{
		buffer >> element->ks.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC1A.seve1
bool assign_ExcAC1A_seve1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC1A*>(base_class_ptr))
	{
		buffer >> element->seve1;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC1A.seve2
bool assign_ExcAC1A_seve2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC1A*>(base_class_ptr))
	{
		buffer >> element->seve2;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC1A.ta
bool assign_ExcAC1A_ta(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC1A*>(base_class_ptr))
	{
		buffer >> element->ta.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC1A.tb
bool assign_ExcAC1A_tb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC1A*>(base_class_ptr))
	{
		buffer >> element->tb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC1A.tc
bool assign_ExcAC1A_tc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC1A*>(base_class_ptr))
	{
		buffer >> element->tc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC1A.te
bool assign_ExcAC1A_te(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC1A*>(base_class_ptr))
	{
		buffer >> element->te.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC1A.tf
bool assign_ExcAC1A_tf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC1A*>(base_class_ptr))
	{
		buffer >> element->tf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC1A.vamax
bool assign_ExcAC1A_vamax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC1A*>(base_class_ptr))
	{
		buffer >> element->vamax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC1A.vamin
bool assign_ExcAC1A_vamin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC1A*>(base_class_ptr))
	{
		buffer >> element->vamin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC1A.ve1
bool assign_ExcAC1A_ve1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC1A*>(base_class_ptr))
	{
		buffer >> element->ve1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC1A.ve2
bool assign_ExcAC1A_ve2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC1A*>(base_class_ptr))
	{
		buffer >> element->ve2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC1A.vrmax
bool assign_ExcAC1A_vrmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC1A*>(base_class_ptr))
	{
		buffer >> element->vrmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC1A.vrmin
bool assign_ExcAC1A_vrmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC1A*>(base_class_ptr))
	{
		buffer >> element->vrmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC2A.hvgate
bool assign_ExcAC2A_hvgate(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC2A*>(base_class_ptr))
	{
		buffer >> element->hvgate;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC2A.ka
bool assign_ExcAC2A_ka(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC2A*>(base_class_ptr))
	{
		buffer >> element->ka.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC2A.kb
bool assign_ExcAC2A_kb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC2A*>(base_class_ptr))
	{
		buffer >> element->kb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC2A.kb1
bool assign_ExcAC2A_kb1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC2A*>(base_class_ptr))
	{
		buffer >> element->kb1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC2A.kc
bool assign_ExcAC2A_kc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC2A*>(base_class_ptr))
	{
		buffer >> element->kc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC2A.kd
bool assign_ExcAC2A_kd(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC2A*>(base_class_ptr))
	{
		buffer >> element->kd.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC2A.ke
bool assign_ExcAC2A_ke(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC2A*>(base_class_ptr))
	{
		buffer >> element->ke.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC2A.kf
bool assign_ExcAC2A_kf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC2A*>(base_class_ptr))
	{
		buffer >> element->kf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC2A.kh
bool assign_ExcAC2A_kh(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC2A*>(base_class_ptr))
	{
		buffer >> element->kh.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC2A.kl
bool assign_ExcAC2A_kl(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC2A*>(base_class_ptr))
	{
		buffer >> element->kl.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC2A.kl1
bool assign_ExcAC2A_kl1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC2A*>(base_class_ptr))
	{
		buffer >> element->kl1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC2A.ks
bool assign_ExcAC2A_ks(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC2A*>(base_class_ptr))
	{
		buffer >> element->ks.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC2A.lvgate
bool assign_ExcAC2A_lvgate(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC2A*>(base_class_ptr))
	{
		buffer >> element->lvgate;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC2A.seve1
bool assign_ExcAC2A_seve1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC2A*>(base_class_ptr))
	{
		buffer >> element->seve1;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC2A.seve2
bool assign_ExcAC2A_seve2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC2A*>(base_class_ptr))
	{
		buffer >> element->seve2;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC2A.ta
bool assign_ExcAC2A_ta(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC2A*>(base_class_ptr))
	{
		buffer >> element->ta.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC2A.tb
bool assign_ExcAC2A_tb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC2A*>(base_class_ptr))
	{
		buffer >> element->tb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC2A.tc
bool assign_ExcAC2A_tc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC2A*>(base_class_ptr))
	{
		buffer >> element->tc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC2A.te
bool assign_ExcAC2A_te(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC2A*>(base_class_ptr))
	{
		buffer >> element->te.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC2A.tf
bool assign_ExcAC2A_tf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC2A*>(base_class_ptr))
	{
		buffer >> element->tf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC2A.vamax
bool assign_ExcAC2A_vamax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC2A*>(base_class_ptr))
	{
		buffer >> element->vamax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC2A.vamin
bool assign_ExcAC2A_vamin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC2A*>(base_class_ptr))
	{
		buffer >> element->vamin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC2A.ve1
bool assign_ExcAC2A_ve1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC2A*>(base_class_ptr))
	{
		buffer >> element->ve1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC2A.ve2
bool assign_ExcAC2A_ve2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC2A*>(base_class_ptr))
	{
		buffer >> element->ve2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC2A.vfemax
bool assign_ExcAC2A_vfemax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC2A*>(base_class_ptr))
	{
		buffer >> element->vfemax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC2A.vlr
bool assign_ExcAC2A_vlr(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC2A*>(base_class_ptr))
	{
		buffer >> element->vlr.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC2A.vrmax
bool assign_ExcAC2A_vrmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC2A*>(base_class_ptr))
	{
		buffer >> element->vrmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC2A.vrmin
bool assign_ExcAC2A_vrmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC2A*>(base_class_ptr))
	{
		buffer >> element->vrmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC3A.efdn
bool assign_ExcAC3A_efdn(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC3A*>(base_class_ptr))
	{
		buffer >> element->efdn.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC3A.ka
bool assign_ExcAC3A_ka(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC3A*>(base_class_ptr))
	{
		buffer >> element->ka.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC3A.kc
bool assign_ExcAC3A_kc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC3A*>(base_class_ptr))
	{
		buffer >> element->kc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC3A.kd
bool assign_ExcAC3A_kd(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC3A*>(base_class_ptr))
	{
		buffer >> element->kd.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC3A.ke
bool assign_ExcAC3A_ke(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC3A*>(base_class_ptr))
	{
		buffer >> element->ke.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC3A.kf
bool assign_ExcAC3A_kf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC3A*>(base_class_ptr))
	{
		buffer >> element->kf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC3A.kf1
bool assign_ExcAC3A_kf1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC3A*>(base_class_ptr))
	{
		buffer >> element->kf1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC3A.kf2
bool assign_ExcAC3A_kf2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC3A*>(base_class_ptr))
	{
		buffer >> element->kf2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC3A.klv
bool assign_ExcAC3A_klv(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC3A*>(base_class_ptr))
	{
		buffer >> element->klv.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC3A.kn
bool assign_ExcAC3A_kn(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC3A*>(base_class_ptr))
	{
		buffer >> element->kn.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC3A.kr
bool assign_ExcAC3A_kr(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC3A*>(base_class_ptr))
	{
		buffer >> element->kr.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC3A.ks
bool assign_ExcAC3A_ks(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC3A*>(base_class_ptr))
	{
		buffer >> element->ks.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC3A.seve1
bool assign_ExcAC3A_seve1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC3A*>(base_class_ptr))
	{
		buffer >> element->seve1;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC3A.seve2
bool assign_ExcAC3A_seve2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC3A*>(base_class_ptr))
	{
		buffer >> element->seve2;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC3A.ta
bool assign_ExcAC3A_ta(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC3A*>(base_class_ptr))
	{
		buffer >> element->ta.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC3A.tb
bool assign_ExcAC3A_tb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC3A*>(base_class_ptr))
	{
		buffer >> element->tb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC3A.tc
bool assign_ExcAC3A_tc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC3A*>(base_class_ptr))
	{
		buffer >> element->tc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC3A.te
bool assign_ExcAC3A_te(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC3A*>(base_class_ptr))
	{
		buffer >> element->te.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC3A.tf
bool assign_ExcAC3A_tf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC3A*>(base_class_ptr))
	{
		buffer >> element->tf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC3A.vamax
bool assign_ExcAC3A_vamax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC3A*>(base_class_ptr))
	{
		buffer >> element->vamax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC3A.vamin
bool assign_ExcAC3A_vamin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC3A*>(base_class_ptr))
	{
		buffer >> element->vamin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC3A.ve1
bool assign_ExcAC3A_ve1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC3A*>(base_class_ptr))
	{
		buffer >> element->ve1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC3A.ve2
bool assign_ExcAC3A_ve2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC3A*>(base_class_ptr))
	{
		buffer >> element->ve2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC3A.vemin
bool assign_ExcAC3A_vemin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC3A*>(base_class_ptr))
	{
		buffer >> element->vemin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC3A.vfemax
bool assign_ExcAC3A_vfemax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC3A*>(base_class_ptr))
	{
		buffer >> element->vfemax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC3A.vlv
bool assign_ExcAC3A_vlv(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC3A*>(base_class_ptr))
	{
		buffer >> element->vlv.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC4A.ka
bool assign_ExcAC4A_ka(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC4A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC4A*>(base_class_ptr))
	{
		buffer >> element->ka.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC4A.kc
bool assign_ExcAC4A_kc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC4A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC4A*>(base_class_ptr))
	{
		buffer >> element->kc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC4A.ta
bool assign_ExcAC4A_ta(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC4A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC4A*>(base_class_ptr))
	{
		buffer >> element->ta.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC4A.tb
bool assign_ExcAC4A_tb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC4A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC4A*>(base_class_ptr))
	{
		buffer >> element->tb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC4A.tc
bool assign_ExcAC4A_tc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC4A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC4A*>(base_class_ptr))
	{
		buffer >> element->tc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC4A.vimax
bool assign_ExcAC4A_vimax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC4A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC4A*>(base_class_ptr))
	{
		buffer >> element->vimax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC4A.vimin
bool assign_ExcAC4A_vimin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC4A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC4A*>(base_class_ptr))
	{
		buffer >> element->vimin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC4A.vrmax
bool assign_ExcAC4A_vrmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC4A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC4A*>(base_class_ptr))
	{
		buffer >> element->vrmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC4A.vrmin
bool assign_ExcAC4A_vrmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC4A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC4A*>(base_class_ptr))
	{
		buffer >> element->vrmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC5A.a
bool assign_ExcAC5A_a(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC5A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC5A*>(base_class_ptr))
	{
		buffer >> element->a;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC5A.efd1
bool assign_ExcAC5A_efd1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC5A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC5A*>(base_class_ptr))
	{
		buffer >> element->efd1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC5A.efd2
bool assign_ExcAC5A_efd2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC5A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC5A*>(base_class_ptr))
	{
		buffer >> element->efd2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC5A.ka
bool assign_ExcAC5A_ka(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC5A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC5A*>(base_class_ptr))
	{
		buffer >> element->ka.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC5A.ke
bool assign_ExcAC5A_ke(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC5A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC5A*>(base_class_ptr))
	{
		buffer >> element->ke.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC5A.kf
bool assign_ExcAC5A_kf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC5A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC5A*>(base_class_ptr))
	{
		buffer >> element->kf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC5A.ks
bool assign_ExcAC5A_ks(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC5A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC5A*>(base_class_ptr))
	{
		buffer >> element->ks.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC5A.seefd1
bool assign_ExcAC5A_seefd1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC5A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC5A*>(base_class_ptr))
	{
		buffer >> element->seefd1;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC5A.seefd2
bool assign_ExcAC5A_seefd2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC5A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC5A*>(base_class_ptr))
	{
		buffer >> element->seefd2;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC5A.ta
bool assign_ExcAC5A_ta(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC5A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC5A*>(base_class_ptr))
	{
		buffer >> element->ta.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC5A.tb
bool assign_ExcAC5A_tb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC5A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC5A*>(base_class_ptr))
	{
		buffer >> element->tb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC5A.tc
bool assign_ExcAC5A_tc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC5A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC5A*>(base_class_ptr))
	{
		buffer >> element->tc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC5A.te
bool assign_ExcAC5A_te(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC5A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC5A*>(base_class_ptr))
	{
		buffer >> element->te.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC5A.tf1
bool assign_ExcAC5A_tf1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC5A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC5A*>(base_class_ptr))
	{
		buffer >> element->tf1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC5A.tf2
bool assign_ExcAC5A_tf2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC5A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC5A*>(base_class_ptr))
	{
		buffer >> element->tf2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC5A.tf3
bool assign_ExcAC5A_tf3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC5A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC5A*>(base_class_ptr))
	{
		buffer >> element->tf3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC5A.vrmax
bool assign_ExcAC5A_vrmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC5A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC5A*>(base_class_ptr))
	{
		buffer >> element->vrmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC5A.vrmin
bool assign_ExcAC5A_vrmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC5A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC5A*>(base_class_ptr))
	{
		buffer >> element->vrmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC6A.ka
bool assign_ExcAC6A_ka(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC6A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC6A*>(base_class_ptr))
	{
		buffer >> element->ka.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC6A.kc
bool assign_ExcAC6A_kc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC6A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC6A*>(base_class_ptr))
	{
		buffer >> element->kc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC6A.kd
bool assign_ExcAC6A_kd(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC6A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC6A*>(base_class_ptr))
	{
		buffer >> element->kd.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC6A.ke
bool assign_ExcAC6A_ke(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC6A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC6A*>(base_class_ptr))
	{
		buffer >> element->ke.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC6A.kh
bool assign_ExcAC6A_kh(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC6A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC6A*>(base_class_ptr))
	{
		buffer >> element->kh.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC6A.ks
bool assign_ExcAC6A_ks(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC6A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC6A*>(base_class_ptr))
	{
		buffer >> element->ks.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC6A.seve1
bool assign_ExcAC6A_seve1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC6A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC6A*>(base_class_ptr))
	{
		buffer >> element->seve1;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC6A.seve2
bool assign_ExcAC6A_seve2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC6A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC6A*>(base_class_ptr))
	{
		buffer >> element->seve2;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC6A.ta
bool assign_ExcAC6A_ta(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC6A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC6A*>(base_class_ptr))
	{
		buffer >> element->ta.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC6A.tb
bool assign_ExcAC6A_tb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC6A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC6A*>(base_class_ptr))
	{
		buffer >> element->tb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC6A.tc
bool assign_ExcAC6A_tc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC6A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC6A*>(base_class_ptr))
	{
		buffer >> element->tc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC6A.te
bool assign_ExcAC6A_te(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC6A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC6A*>(base_class_ptr))
	{
		buffer >> element->te.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC6A.th
bool assign_ExcAC6A_th(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC6A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC6A*>(base_class_ptr))
	{
		buffer >> element->th.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC6A.tj
bool assign_ExcAC6A_tj(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC6A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC6A*>(base_class_ptr))
	{
		buffer >> element->tj.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC6A.tk
bool assign_ExcAC6A_tk(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC6A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC6A*>(base_class_ptr))
	{
		buffer >> element->tk.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC6A.vamax
bool assign_ExcAC6A_vamax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC6A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC6A*>(base_class_ptr))
	{
		buffer >> element->vamax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC6A.vamin
bool assign_ExcAC6A_vamin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC6A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC6A*>(base_class_ptr))
	{
		buffer >> element->vamin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC6A.ve1
bool assign_ExcAC6A_ve1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC6A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC6A*>(base_class_ptr))
	{
		buffer >> element->ve1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC6A.ve2
bool assign_ExcAC6A_ve2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC6A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC6A*>(base_class_ptr))
	{
		buffer >> element->ve2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC6A.vfelim
bool assign_ExcAC6A_vfelim(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC6A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC6A*>(base_class_ptr))
	{
		buffer >> element->vfelim.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC6A.vhmax
bool assign_ExcAC6A_vhmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC6A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC6A*>(base_class_ptr))
	{
		buffer >> element->vhmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC6A.vrmax
bool assign_ExcAC6A_vrmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC6A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC6A*>(base_class_ptr))
	{
		buffer >> element->vrmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC6A.vrmin
bool assign_ExcAC6A_vrmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC6A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC6A*>(base_class_ptr))
	{
		buffer >> element->vrmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC8B.inlim
bool assign_ExcAC8B_inlim(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC8B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC8B*>(base_class_ptr))
	{
		buffer >> element->inlim;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC8B.ka
bool assign_ExcAC8B_ka(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC8B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC8B*>(base_class_ptr))
	{
		buffer >> element->ka.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC8B.kc
bool assign_ExcAC8B_kc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC8B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC8B*>(base_class_ptr))
	{
		buffer >> element->kc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC8B.kd
bool assign_ExcAC8B_kd(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC8B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC8B*>(base_class_ptr))
	{
		buffer >> element->kd.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC8B.kdr
bool assign_ExcAC8B_kdr(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC8B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC8B*>(base_class_ptr))
	{
		buffer >> element->kdr.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC8B.ke
bool assign_ExcAC8B_ke(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC8B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC8B*>(base_class_ptr))
	{
		buffer >> element->ke.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC8B.kir
bool assign_ExcAC8B_kir(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC8B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC8B*>(base_class_ptr))
	{
		buffer >> element->kir.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC8B.kpr
bool assign_ExcAC8B_kpr(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC8B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC8B*>(base_class_ptr))
	{
		buffer >> element->kpr.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC8B.ks
bool assign_ExcAC8B_ks(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC8B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC8B*>(base_class_ptr))
	{
		buffer >> element->ks.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC8B.pidlim
bool assign_ExcAC8B_pidlim(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC8B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC8B*>(base_class_ptr))
	{
		buffer >> element->pidlim;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC8B.seve1
bool assign_ExcAC8B_seve1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC8B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC8B*>(base_class_ptr))
	{
		buffer >> element->seve1;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC8B.seve2
bool assign_ExcAC8B_seve2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC8B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC8B*>(base_class_ptr))
	{
		buffer >> element->seve2;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC8B.ta
bool assign_ExcAC8B_ta(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC8B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC8B*>(base_class_ptr))
	{
		buffer >> element->ta.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC8B.tdr
bool assign_ExcAC8B_tdr(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC8B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC8B*>(base_class_ptr))
	{
		buffer >> element->tdr.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC8B.te
bool assign_ExcAC8B_te(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC8B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC8B*>(base_class_ptr))
	{
		buffer >> element->te.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC8B.telim
bool assign_ExcAC8B_telim(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC8B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC8B*>(base_class_ptr))
	{
		buffer >> element->telim;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC8B.ve1
bool assign_ExcAC8B_ve1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC8B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC8B*>(base_class_ptr))
	{
		buffer >> element->ve1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC8B.ve2
bool assign_ExcAC8B_ve2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC8B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC8B*>(base_class_ptr))
	{
		buffer >> element->ve2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC8B.vemin
bool assign_ExcAC8B_vemin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC8B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC8B*>(base_class_ptr))
	{
		buffer >> element->vemin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC8B.vfemax
bool assign_ExcAC8B_vfemax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC8B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC8B*>(base_class_ptr))
	{
		buffer >> element->vfemax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC8B.vimax
bool assign_ExcAC8B_vimax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC8B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC8B*>(base_class_ptr))
	{
		buffer >> element->vimax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC8B.vimin
bool assign_ExcAC8B_vimin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC8B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC8B*>(base_class_ptr))
	{
		buffer >> element->vimin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC8B.vpidmax
bool assign_ExcAC8B_vpidmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC8B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC8B*>(base_class_ptr))
	{
		buffer >> element->vpidmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC8B.vpidmin
bool assign_ExcAC8B_vpidmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC8B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC8B*>(base_class_ptr))
	{
		buffer >> element->vpidmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC8B.vrmax
bool assign_ExcAC8B_vrmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC8B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC8B*>(base_class_ptr))
	{
		buffer >> element->vrmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC8B.vrmin
bool assign_ExcAC8B_vrmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC8B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC8B*>(base_class_ptr))
	{
		buffer >> element->vrmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAC8B.vtmult
bool assign_ExcAC8B_vtmult(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC8B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAC8B*>(base_class_ptr))
	{
		buffer >> element->vtmult;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcANS.blint
bool assign_ExcANS_blint(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcANS* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcANS*>(base_class_ptr))
	{
		buffer >> element->blint;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcANS.ifmn
bool assign_ExcANS_ifmn(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcANS* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcANS*>(base_class_ptr))
	{
		buffer >> element->ifmn.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcANS.ifmx
bool assign_ExcANS_ifmx(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcANS* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcANS*>(base_class_ptr))
	{
		buffer >> element->ifmx.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcANS.k2
bool assign_ExcANS_k2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcANS* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcANS*>(base_class_ptr))
	{
		buffer >> element->k2;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcANS.k3
bool assign_ExcANS_k3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcANS* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcANS*>(base_class_ptr))
	{
		buffer >> element->k3;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcANS.kce
bool assign_ExcANS_kce(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcANS* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcANS*>(base_class_ptr))
	{
		buffer >> element->kce;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcANS.krvecc
bool assign_ExcANS_krvecc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcANS* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcANS*>(base_class_ptr))
	{
		buffer >> element->krvecc;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcANS.kvfif
bool assign_ExcANS_kvfif(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcANS* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcANS*>(base_class_ptr))
	{
		buffer >> element->kvfif;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcANS.t1
bool assign_ExcANS_t1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcANS* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcANS*>(base_class_ptr))
	{
		buffer >> element->t1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcANS.t2
bool assign_ExcANS_t2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcANS* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcANS*>(base_class_ptr))
	{
		buffer >> element->t2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcANS.t3
bool assign_ExcANS_t3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcANS* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcANS*>(base_class_ptr))
	{
		buffer >> element->t3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcANS.tb
bool assign_ExcANS_tb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcANS* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcANS*>(base_class_ptr))
	{
		buffer >> element->tb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcANS.vrmn
bool assign_ExcANS_vrmn(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcANS* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcANS*>(base_class_ptr))
	{
		buffer >> element->vrmn.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcANS.vrmx
bool assign_ExcANS_vrmx(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcANS* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcANS*>(base_class_ptr))
	{
		buffer >> element->vrmx.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR1.e1
bool assign_ExcAVR1_e1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR1*>(base_class_ptr))
	{
		buffer >> element->e1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR1.e2
bool assign_ExcAVR1_e2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR1*>(base_class_ptr))
	{
		buffer >> element->e2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR1.ka
bool assign_ExcAVR1_ka(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR1*>(base_class_ptr))
	{
		buffer >> element->ka;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR1.kf
bool assign_ExcAVR1_kf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR1*>(base_class_ptr))
	{
		buffer >> element->kf;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR1.se1
bool assign_ExcAVR1_se1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR1*>(base_class_ptr))
	{
		buffer >> element->se1;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR1.se2
bool assign_ExcAVR1_se2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR1*>(base_class_ptr))
	{
		buffer >> element->se2;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR1.ta
bool assign_ExcAVR1_ta(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR1*>(base_class_ptr))
	{
		buffer >> element->ta.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR1.tb
bool assign_ExcAVR1_tb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR1*>(base_class_ptr))
	{
		buffer >> element->tb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR1.te
bool assign_ExcAVR1_te(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR1*>(base_class_ptr))
	{
		buffer >> element->te.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR1.tf
bool assign_ExcAVR1_tf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR1*>(base_class_ptr))
	{
		buffer >> element->tf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR1.vrmn
bool assign_ExcAVR1_vrmn(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR1*>(base_class_ptr))
	{
		buffer >> element->vrmn.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR1.vrmx
bool assign_ExcAVR1_vrmx(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR1*>(base_class_ptr))
	{
		buffer >> element->vrmx.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR2.e1
bool assign_ExcAVR2_e1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR2*>(base_class_ptr))
	{
		buffer >> element->e1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR2.e2
bool assign_ExcAVR2_e2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR2*>(base_class_ptr))
	{
		buffer >> element->e2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR2.ka
bool assign_ExcAVR2_ka(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR2*>(base_class_ptr))
	{
		buffer >> element->ka;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR2.kf
bool assign_ExcAVR2_kf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR2*>(base_class_ptr))
	{
		buffer >> element->kf;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR2.se1
bool assign_ExcAVR2_se1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR2*>(base_class_ptr))
	{
		buffer >> element->se1;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR2.se2
bool assign_ExcAVR2_se2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR2*>(base_class_ptr))
	{
		buffer >> element->se2;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR2.ta
bool assign_ExcAVR2_ta(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR2*>(base_class_ptr))
	{
		buffer >> element->ta.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR2.tb
bool assign_ExcAVR2_tb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR2*>(base_class_ptr))
	{
		buffer >> element->tb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR2.te
bool assign_ExcAVR2_te(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR2*>(base_class_ptr))
	{
		buffer >> element->te.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR2.tf1
bool assign_ExcAVR2_tf1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR2*>(base_class_ptr))
	{
		buffer >> element->tf1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR2.tf2
bool assign_ExcAVR2_tf2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR2*>(base_class_ptr))
	{
		buffer >> element->tf2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR2.vrmn
bool assign_ExcAVR2_vrmn(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR2*>(base_class_ptr))
	{
		buffer >> element->vrmn.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR2.vrmx
bool assign_ExcAVR2_vrmx(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR2*>(base_class_ptr))
	{
		buffer >> element->vrmx.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR3.e1
bool assign_ExcAVR3_e1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR3*>(base_class_ptr))
	{
		buffer >> element->e1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR3.e2
bool assign_ExcAVR3_e2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR3*>(base_class_ptr))
	{
		buffer >> element->e2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR3.ka
bool assign_ExcAVR3_ka(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR3*>(base_class_ptr))
	{
		buffer >> element->ka;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR3.se1
bool assign_ExcAVR3_se1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR3*>(base_class_ptr))
	{
		buffer >> element->se1;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR3.se2
bool assign_ExcAVR3_se2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR3*>(base_class_ptr))
	{
		buffer >> element->se2;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR3.t1
bool assign_ExcAVR3_t1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR3*>(base_class_ptr))
	{
		buffer >> element->t1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR3.t2
bool assign_ExcAVR3_t2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR3*>(base_class_ptr))
	{
		buffer >> element->t2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR3.t3
bool assign_ExcAVR3_t3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR3*>(base_class_ptr))
	{
		buffer >> element->t3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR3.t4
bool assign_ExcAVR3_t4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR3*>(base_class_ptr))
	{
		buffer >> element->t4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR3.te
bool assign_ExcAVR3_te(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR3*>(base_class_ptr))
	{
		buffer >> element->te.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR3.vrmn
bool assign_ExcAVR3_vrmn(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR3*>(base_class_ptr))
	{
		buffer >> element->vrmn.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR3.vrmx
bool assign_ExcAVR3_vrmx(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR3*>(base_class_ptr))
	{
		buffer >> element->vrmx.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR4.imul
bool assign_ExcAVR4_imul(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR4*>(base_class_ptr))
	{
		buffer >> element->imul;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR4.ka
bool assign_ExcAVR4_ka(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR4*>(base_class_ptr))
	{
		buffer >> element->ka;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR4.ke
bool assign_ExcAVR4_ke(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR4*>(base_class_ptr))
	{
		buffer >> element->ke;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR4.kif
bool assign_ExcAVR4_kif(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR4*>(base_class_ptr))
	{
		buffer >> element->kif;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR4.t1
bool assign_ExcAVR4_t1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR4*>(base_class_ptr))
	{
		buffer >> element->t1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR4.t1if
bool assign_ExcAVR4_t1if(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR4*>(base_class_ptr))
	{
		buffer >> element->t1if.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR4.t2
bool assign_ExcAVR4_t2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR4*>(base_class_ptr))
	{
		buffer >> element->t2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR4.t3
bool assign_ExcAVR4_t3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR4*>(base_class_ptr))
	{
		buffer >> element->t3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR4.t4
bool assign_ExcAVR4_t4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR4*>(base_class_ptr))
	{
		buffer >> element->t4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR4.tif
bool assign_ExcAVR4_tif(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR4*>(base_class_ptr))
	{
		buffer >> element->tif.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR4.vfmn
bool assign_ExcAVR4_vfmn(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR4*>(base_class_ptr))
	{
		buffer >> element->vfmn.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR4.vfmx
bool assign_ExcAVR4_vfmx(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR4*>(base_class_ptr))
	{
		buffer >> element->vfmx.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR4.vrmn
bool assign_ExcAVR4_vrmn(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR4*>(base_class_ptr))
	{
		buffer >> element->vrmn.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR4.vrmx
bool assign_ExcAVR4_vrmx(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR4*>(base_class_ptr))
	{
		buffer >> element->vrmx.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR5.ka
bool assign_ExcAVR5_ka(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR5* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR5*>(base_class_ptr))
	{
		buffer >> element->ka.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR5.rex
bool assign_ExcAVR5_rex(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR5* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR5*>(base_class_ptr))
	{
		buffer >> element->rex.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR5.ta
bool assign_ExcAVR5_ta(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR5* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR5*>(base_class_ptr))
	{
		buffer >> element->ta.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR7.a1
bool assign_ExcAVR7_a1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR7* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR7*>(base_class_ptr))
	{
		buffer >> element->a1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR7.a2
bool assign_ExcAVR7_a2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR7* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR7*>(base_class_ptr))
	{
		buffer >> element->a2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR7.a3
bool assign_ExcAVR7_a3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR7* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR7*>(base_class_ptr))
	{
		buffer >> element->a3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR7.a4
bool assign_ExcAVR7_a4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR7* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR7*>(base_class_ptr))
	{
		buffer >> element->a4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR7.a5
bool assign_ExcAVR7_a5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR7* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR7*>(base_class_ptr))
	{
		buffer >> element->a5.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR7.a6
bool assign_ExcAVR7_a6(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR7* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR7*>(base_class_ptr))
	{
		buffer >> element->a6.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR7.k1
bool assign_ExcAVR7_k1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR7* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR7*>(base_class_ptr))
	{
		buffer >> element->k1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR7.k3
bool assign_ExcAVR7_k3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR7* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR7*>(base_class_ptr))
	{
		buffer >> element->k3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR7.k5
bool assign_ExcAVR7_k5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR7* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR7*>(base_class_ptr))
	{
		buffer >> element->k5.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR7.t1
bool assign_ExcAVR7_t1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR7* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR7*>(base_class_ptr))
	{
		buffer >> element->t1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR7.t2
bool assign_ExcAVR7_t2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR7* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR7*>(base_class_ptr))
	{
		buffer >> element->t2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR7.t3
bool assign_ExcAVR7_t3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR7* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR7*>(base_class_ptr))
	{
		buffer >> element->t3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR7.t4
bool assign_ExcAVR7_t4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR7* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR7*>(base_class_ptr))
	{
		buffer >> element->t4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR7.t5
bool assign_ExcAVR7_t5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR7* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR7*>(base_class_ptr))
	{
		buffer >> element->t5.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR7.t6
bool assign_ExcAVR7_t6(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR7* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR7*>(base_class_ptr))
	{
		buffer >> element->t6.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR7.vmax1
bool assign_ExcAVR7_vmax1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR7* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR7*>(base_class_ptr))
	{
		buffer >> element->vmax1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR7.vmax3
bool assign_ExcAVR7_vmax3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR7* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR7*>(base_class_ptr))
	{
		buffer >> element->vmax3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR7.vmax5
bool assign_ExcAVR7_vmax5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR7* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR7*>(base_class_ptr))
	{
		buffer >> element->vmax5.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR7.vmin1
bool assign_ExcAVR7_vmin1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR7* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR7*>(base_class_ptr))
	{
		buffer >> element->vmin1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR7.vmin3
bool assign_ExcAVR7_vmin3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR7* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR7*>(base_class_ptr))
	{
		buffer >> element->vmin3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcAVR7.vmin5
bool assign_ExcAVR7_vmin5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR7* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcAVR7*>(base_class_ptr))
	{
		buffer >> element->vmin5.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcBBC.efdmax
bool assign_ExcBBC_efdmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcBBC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcBBC*>(base_class_ptr))
	{
		buffer >> element->efdmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcBBC.efdmin
bool assign_ExcBBC_efdmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcBBC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcBBC*>(base_class_ptr))
	{
		buffer >> element->efdmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcBBC.k
bool assign_ExcBBC_k(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcBBC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcBBC*>(base_class_ptr))
	{
		buffer >> element->k.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcBBC.routing_selector
bool assign_ExcBBC_routing_selector(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcBBC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcBBC*>(base_class_ptr))
	{
		buffer >> element->routing_selector;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcBBC.t1
bool assign_ExcBBC_t1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcBBC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcBBC*>(base_class_ptr))
	{
		buffer >> element->t1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcBBC.t2
bool assign_ExcBBC_t2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcBBC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcBBC*>(base_class_ptr))
	{
		buffer >> element->t2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcBBC.t3
bool assign_ExcBBC_t3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcBBC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcBBC*>(base_class_ptr))
	{
		buffer >> element->t3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcBBC.t4
bool assign_ExcBBC_t4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcBBC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcBBC*>(base_class_ptr))
	{
		buffer >> element->t4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcBBC.vrmax
bool assign_ExcBBC_vrmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcBBC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcBBC*>(base_class_ptr))
	{
		buffer >> element->vrmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcBBC.vrmin
bool assign_ExcBBC_vrmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcBBC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcBBC*>(base_class_ptr))
	{
		buffer >> element->vrmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcBBC.xe
bool assign_ExcBBC_xe(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcBBC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcBBC*>(base_class_ptr))
	{
		buffer >> element->xe.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcCZ.efdmax
bool assign_ExcCZ_efdmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcCZ* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcCZ*>(base_class_ptr))
	{
		buffer >> element->efdmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcCZ.efdmin
bool assign_ExcCZ_efdmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcCZ* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcCZ*>(base_class_ptr))
	{
		buffer >> element->efdmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcCZ.ka
bool assign_ExcCZ_ka(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcCZ* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcCZ*>(base_class_ptr))
	{
		buffer >> element->ka.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcCZ.ke
bool assign_ExcCZ_ke(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcCZ* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcCZ*>(base_class_ptr))
	{
		buffer >> element->ke.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcCZ.kp
bool assign_ExcCZ_kp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcCZ* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcCZ*>(base_class_ptr))
	{
		buffer >> element->kp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcCZ.ta
bool assign_ExcCZ_ta(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcCZ* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcCZ*>(base_class_ptr))
	{
		buffer >> element->ta.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcCZ.tc
bool assign_ExcCZ_tc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcCZ* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcCZ*>(base_class_ptr))
	{
		buffer >> element->tc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcCZ.te
bool assign_ExcCZ_te(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcCZ* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcCZ*>(base_class_ptr))
	{
		buffer >> element->te.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcCZ.vrmax
bool assign_ExcCZ_vrmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcCZ* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcCZ*>(base_class_ptr))
	{
		buffer >> element->vrmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcCZ.vrmin
bool assign_ExcCZ_vrmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcCZ* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcCZ*>(base_class_ptr))
	{
		buffer >> element->vrmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC1A.edfmax
bool assign_ExcDC1A_edfmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC1A*>(base_class_ptr))
	{
		buffer >> element->edfmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC1A.efd1
bool assign_ExcDC1A_efd1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC1A*>(base_class_ptr))
	{
		buffer >> element->efd1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC1A.efd2
bool assign_ExcDC1A_efd2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC1A*>(base_class_ptr))
	{
		buffer >> element->efd2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC1A.efdmin
bool assign_ExcDC1A_efdmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC1A*>(base_class_ptr))
	{
		buffer >> element->efdmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC1A.exclim
bool assign_ExcDC1A_exclim(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC1A*>(base_class_ptr))
	{
		buffer >> element->exclim;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC1A.ka
bool assign_ExcDC1A_ka(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC1A*>(base_class_ptr))
	{
		buffer >> element->ka.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC1A.ke
bool assign_ExcDC1A_ke(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC1A*>(base_class_ptr))
	{
		buffer >> element->ke.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC1A.kf
bool assign_ExcDC1A_kf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC1A*>(base_class_ptr))
	{
		buffer >> element->kf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC1A.ks
bool assign_ExcDC1A_ks(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC1A*>(base_class_ptr))
	{
		buffer >> element->ks.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC1A.seefd1
bool assign_ExcDC1A_seefd1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC1A*>(base_class_ptr))
	{
		buffer >> element->seefd1;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC1A.seefd2
bool assign_ExcDC1A_seefd2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC1A*>(base_class_ptr))
	{
		buffer >> element->seefd2;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC1A.ta
bool assign_ExcDC1A_ta(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC1A*>(base_class_ptr))
	{
		buffer >> element->ta.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC1A.tb
bool assign_ExcDC1A_tb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC1A*>(base_class_ptr))
	{
		buffer >> element->tb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC1A.tc
bool assign_ExcDC1A_tc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC1A*>(base_class_ptr))
	{
		buffer >> element->tc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC1A.te
bool assign_ExcDC1A_te(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC1A*>(base_class_ptr))
	{
		buffer >> element->te.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC1A.tf
bool assign_ExcDC1A_tf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC1A*>(base_class_ptr))
	{
		buffer >> element->tf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC1A.vrmax
bool assign_ExcDC1A_vrmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC1A*>(base_class_ptr))
	{
		buffer >> element->vrmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC1A.vrmin
bool assign_ExcDC1A_vrmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC1A*>(base_class_ptr))
	{
		buffer >> element->vrmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC2A.efd1
bool assign_ExcDC2A_efd1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC2A*>(base_class_ptr))
	{
		buffer >> element->efd1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC2A.efd2
bool assign_ExcDC2A_efd2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC2A*>(base_class_ptr))
	{
		buffer >> element->efd2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC2A.exclim
bool assign_ExcDC2A_exclim(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC2A*>(base_class_ptr))
	{
		buffer >> element->exclim;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC2A.ka
bool assign_ExcDC2A_ka(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC2A*>(base_class_ptr))
	{
		buffer >> element->ka.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC2A.ke
bool assign_ExcDC2A_ke(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC2A*>(base_class_ptr))
	{
		buffer >> element->ke.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC2A.kf
bool assign_ExcDC2A_kf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC2A*>(base_class_ptr))
	{
		buffer >> element->kf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC2A.ks
bool assign_ExcDC2A_ks(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC2A*>(base_class_ptr))
	{
		buffer >> element->ks.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC2A.seefd1
bool assign_ExcDC2A_seefd1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC2A*>(base_class_ptr))
	{
		buffer >> element->seefd1;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC2A.seefd2
bool assign_ExcDC2A_seefd2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC2A*>(base_class_ptr))
	{
		buffer >> element->seefd2;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC2A.ta
bool assign_ExcDC2A_ta(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC2A*>(base_class_ptr))
	{
		buffer >> element->ta.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC2A.tb
bool assign_ExcDC2A_tb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC2A*>(base_class_ptr))
	{
		buffer >> element->tb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC2A.tc
bool assign_ExcDC2A_tc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC2A*>(base_class_ptr))
	{
		buffer >> element->tc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC2A.te
bool assign_ExcDC2A_te(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC2A*>(base_class_ptr))
	{
		buffer >> element->te.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC2A.tf
bool assign_ExcDC2A_tf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC2A*>(base_class_ptr))
	{
		buffer >> element->tf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC2A.tf1
bool assign_ExcDC2A_tf1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC2A*>(base_class_ptr))
	{
		buffer >> element->tf1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC2A.vrmax
bool assign_ExcDC2A_vrmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC2A*>(base_class_ptr))
	{
		buffer >> element->vrmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC2A.vrmin
bool assign_ExcDC2A_vrmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC2A*>(base_class_ptr))
	{
		buffer >> element->vrmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC2A.vtlim
bool assign_ExcDC2A_vtlim(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC2A*>(base_class_ptr))
	{
		buffer >> element->vtlim;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC3A.edfmax
bool assign_ExcDC3A_edfmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC3A*>(base_class_ptr))
	{
		buffer >> element->edfmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC3A.efd1
bool assign_ExcDC3A_efd1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC3A*>(base_class_ptr))
	{
		buffer >> element->efd1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC3A.efd2
bool assign_ExcDC3A_efd2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC3A*>(base_class_ptr))
	{
		buffer >> element->efd2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC3A.efdlim
bool assign_ExcDC3A_efdlim(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC3A*>(base_class_ptr))
	{
		buffer >> element->efdlim;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC3A.efdmin
bool assign_ExcDC3A_efdmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC3A*>(base_class_ptr))
	{
		buffer >> element->efdmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC3A.exclim
bool assign_ExcDC3A_exclim(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC3A*>(base_class_ptr))
	{
		buffer >> element->exclim;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC3A.ke
bool assign_ExcDC3A_ke(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC3A*>(base_class_ptr))
	{
		buffer >> element->ke.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC3A.kr
bool assign_ExcDC3A_kr(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC3A*>(base_class_ptr))
	{
		buffer >> element->kr.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC3A.ks
bool assign_ExcDC3A_ks(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC3A*>(base_class_ptr))
	{
		buffer >> element->ks.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC3A.kv
bool assign_ExcDC3A_kv(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC3A*>(base_class_ptr))
	{
		buffer >> element->kv.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC3A.seefd1
bool assign_ExcDC3A_seefd1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC3A*>(base_class_ptr))
	{
		buffer >> element->seefd1;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC3A.seefd2
bool assign_ExcDC3A_seefd2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC3A*>(base_class_ptr))
	{
		buffer >> element->seefd2;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC3A.te
bool assign_ExcDC3A_te(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC3A*>(base_class_ptr))
	{
		buffer >> element->te.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC3A.trh
bool assign_ExcDC3A_trh(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC3A*>(base_class_ptr))
	{
		buffer >> element->trh.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC3A.vrmax
bool assign_ExcDC3A_vrmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC3A*>(base_class_ptr))
	{
		buffer >> element->vrmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC3A.vrmin
bool assign_ExcDC3A_vrmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC3A*>(base_class_ptr))
	{
		buffer >> element->vrmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC3A1.exclim
bool assign_ExcDC3A1_exclim(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC3A1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC3A1*>(base_class_ptr))
	{
		buffer >> element->exclim;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC3A1.ka
bool assign_ExcDC3A1_ka(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC3A1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC3A1*>(base_class_ptr))
	{
		buffer >> element->ka.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC3A1.ke
bool assign_ExcDC3A1_ke(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC3A1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC3A1*>(base_class_ptr))
	{
		buffer >> element->ke.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC3A1.kf
bool assign_ExcDC3A1_kf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC3A1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC3A1*>(base_class_ptr))
	{
		buffer >> element->kf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC3A1.ki
bool assign_ExcDC3A1_ki(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC3A1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC3A1*>(base_class_ptr))
	{
		buffer >> element->ki.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC3A1.kp
bool assign_ExcDC3A1_kp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC3A1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC3A1*>(base_class_ptr))
	{
		buffer >> element->kp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC3A1.ta
bool assign_ExcDC3A1_ta(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC3A1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC3A1*>(base_class_ptr))
	{
		buffer >> element->ta.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC3A1.te
bool assign_ExcDC3A1_te(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC3A1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC3A1*>(base_class_ptr))
	{
		buffer >> element->te.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC3A1.tf
bool assign_ExcDC3A1_tf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC3A1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC3A1*>(base_class_ptr))
	{
		buffer >> element->tf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC3A1.vb1max
bool assign_ExcDC3A1_vb1max(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC3A1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC3A1*>(base_class_ptr))
	{
		buffer >> element->vb1max.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC3A1.vblim
bool assign_ExcDC3A1_vblim(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC3A1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC3A1*>(base_class_ptr))
	{
		buffer >> element->vblim;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC3A1.vbmax
bool assign_ExcDC3A1_vbmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC3A1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC3A1*>(base_class_ptr))
	{
		buffer >> element->vbmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC3A1.vrmax
bool assign_ExcDC3A1_vrmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC3A1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC3A1*>(base_class_ptr))
	{
		buffer >> element->vrmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcDC3A1.vrmin
bool assign_ExcDC3A1_vrmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC3A1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcDC3A1*>(base_class_ptr))
	{
		buffer >> element->vrmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcELIN1.dpnf
bool assign_ExcELIN1_dpnf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN1*>(base_class_ptr))
	{
		buffer >> element->dpnf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcELIN1.efmax
bool assign_ExcELIN1_efmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN1*>(base_class_ptr))
	{
		buffer >> element->efmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcELIN1.efmin
bool assign_ExcELIN1_efmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN1*>(base_class_ptr))
	{
		buffer >> element->efmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcELIN1.ks1
bool assign_ExcELIN1_ks1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN1*>(base_class_ptr))
	{
		buffer >> element->ks1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcELIN1.ks2
bool assign_ExcELIN1_ks2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN1*>(base_class_ptr))
	{
		buffer >> element->ks2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcELIN1.smax
bool assign_ExcELIN1_smax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN1*>(base_class_ptr))
	{
		buffer >> element->smax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcELIN1.tfi
bool assign_ExcELIN1_tfi(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN1*>(base_class_ptr))
	{
		buffer >> element->tfi.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcELIN1.tnu
bool assign_ExcELIN1_tnu(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN1*>(base_class_ptr))
	{
		buffer >> element->tnu.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcELIN1.ts1
bool assign_ExcELIN1_ts1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN1*>(base_class_ptr))
	{
		buffer >> element->ts1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcELIN1.ts2
bool assign_ExcELIN1_ts2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN1*>(base_class_ptr))
	{
		buffer >> element->ts2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcELIN1.tsw
bool assign_ExcELIN1_tsw(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN1*>(base_class_ptr))
	{
		buffer >> element->tsw.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcELIN1.vpi
bool assign_ExcELIN1_vpi(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN1*>(base_class_ptr))
	{
		buffer >> element->vpi.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcELIN1.vpnf
bool assign_ExcELIN1_vpnf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN1*>(base_class_ptr))
	{
		buffer >> element->vpnf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcELIN1.vpu
bool assign_ExcELIN1_vpu(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN1*>(base_class_ptr))
	{
		buffer >> element->vpu.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcELIN1.xe
bool assign_ExcELIN1_xe(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN1*>(base_class_ptr))
	{
		buffer >> element->xe.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcELIN2.efdbas
bool assign_ExcELIN2_efdbas(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN2*>(base_class_ptr))
	{
		buffer >> element->efdbas.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcELIN2.iefmax
bool assign_ExcELIN2_iefmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN2*>(base_class_ptr))
	{
		buffer >> element->iefmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcELIN2.iefmax2
bool assign_ExcELIN2_iefmax2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN2*>(base_class_ptr))
	{
		buffer >> element->iefmax2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcELIN2.iefmin
bool assign_ExcELIN2_iefmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN2*>(base_class_ptr))
	{
		buffer >> element->iefmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcELIN2.k1
bool assign_ExcELIN2_k1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN2*>(base_class_ptr))
	{
		buffer >> element->k1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcELIN2.k1ec
bool assign_ExcELIN2_k1ec(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN2*>(base_class_ptr))
	{
		buffer >> element->k1ec.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcELIN2.k2
bool assign_ExcELIN2_k2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN2*>(base_class_ptr))
	{
		buffer >> element->k2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcELIN2.k3
bool assign_ExcELIN2_k3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN2*>(base_class_ptr))
	{
		buffer >> element->k3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcELIN2.k4
bool assign_ExcELIN2_k4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN2*>(base_class_ptr))
	{
		buffer >> element->k4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcELIN2.kd1
bool assign_ExcELIN2_kd1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN2*>(base_class_ptr))
	{
		buffer >> element->kd1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcELIN2.ke2
bool assign_ExcELIN2_ke2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN2*>(base_class_ptr))
	{
		buffer >> element->ke2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcELIN2.ketb
bool assign_ExcELIN2_ketb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN2*>(base_class_ptr))
	{
		buffer >> element->ketb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcELIN2.pid1max
bool assign_ExcELIN2_pid1max(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN2*>(base_class_ptr))
	{
		buffer >> element->pid1max.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcELIN2.seve1
bool assign_ExcELIN2_seve1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN2*>(base_class_ptr))
	{
		buffer >> element->seve1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcELIN2.seve2
bool assign_ExcELIN2_seve2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN2*>(base_class_ptr))
	{
		buffer >> element->seve2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcELIN2.tb1
bool assign_ExcELIN2_tb1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN2*>(base_class_ptr))
	{
		buffer >> element->tb1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcELIN2.te
bool assign_ExcELIN2_te(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN2*>(base_class_ptr))
	{
		buffer >> element->te.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcELIN2.te2
bool assign_ExcELIN2_te2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN2*>(base_class_ptr))
	{
		buffer >> element->te2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcELIN2.ti1
bool assign_ExcELIN2_ti1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN2*>(base_class_ptr))
	{
		buffer >> element->ti1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcELIN2.ti3
bool assign_ExcELIN2_ti3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN2*>(base_class_ptr))
	{
		buffer >> element->ti3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcELIN2.ti4
bool assign_ExcELIN2_ti4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN2*>(base_class_ptr))
	{
		buffer >> element->ti4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcELIN2.tr4
bool assign_ExcELIN2_tr4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN2*>(base_class_ptr))
	{
		buffer >> element->tr4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcELIN2.upmax
bool assign_ExcELIN2_upmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN2*>(base_class_ptr))
	{
		buffer >> element->upmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcELIN2.upmin
bool assign_ExcELIN2_upmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN2*>(base_class_ptr))
	{
		buffer >> element->upmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcELIN2.ve1
bool assign_ExcELIN2_ve1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN2*>(base_class_ptr))
	{
		buffer >> element->ve1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcELIN2.ve2
bool assign_ExcELIN2_ve2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN2*>(base_class_ptr))
	{
		buffer >> element->ve2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcELIN2.xp
bool assign_ExcELIN2_xp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcELIN2*>(base_class_ptr))
	{
		buffer >> element->xp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcHU.ae
bool assign_ExcHU_ae(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcHU* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcHU*>(base_class_ptr))
	{
		buffer >> element->ae.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcHU.ai
bool assign_ExcHU_ai(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcHU* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcHU*>(base_class_ptr))
	{
		buffer >> element->ai.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcHU.atr
bool assign_ExcHU_atr(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcHU* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcHU*>(base_class_ptr))
	{
		buffer >> element->atr.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcHU.emax
bool assign_ExcHU_emax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcHU* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcHU*>(base_class_ptr))
	{
		buffer >> element->emax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcHU.emin
bool assign_ExcHU_emin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcHU* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcHU*>(base_class_ptr))
	{
		buffer >> element->emin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcHU.imax
bool assign_ExcHU_imax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcHU* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcHU*>(base_class_ptr))
	{
		buffer >> element->imax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcHU.imin
bool assign_ExcHU_imin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcHU* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcHU*>(base_class_ptr))
	{
		buffer >> element->imin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcHU.ke
bool assign_ExcHU_ke(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcHU* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcHU*>(base_class_ptr))
	{
		buffer >> element->ke;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcHU.ki
bool assign_ExcHU_ki(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcHU* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcHU*>(base_class_ptr))
	{
		buffer >> element->ki;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcHU.te
bool assign_ExcHU_te(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcHU* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcHU*>(base_class_ptr))
	{
		buffer >> element->te.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcHU.ti
bool assign_ExcHU_ti(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcHU* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcHU*>(base_class_ptr))
	{
		buffer >> element->ti.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcHU.tr
bool assign_ExcHU_tr(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcHU* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcHU*>(base_class_ptr))
	{
		buffer >> element->tr.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC1A.ka
bool assign_ExcIEEEAC1A_ka(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC1A*>(base_class_ptr))
	{
		buffer >> element->ka.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC1A.kc
bool assign_ExcIEEEAC1A_kc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC1A*>(base_class_ptr))
	{
		buffer >> element->kc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC1A.kd
bool assign_ExcIEEEAC1A_kd(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC1A*>(base_class_ptr))
	{
		buffer >> element->kd.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC1A.ke
bool assign_ExcIEEEAC1A_ke(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC1A*>(base_class_ptr))
	{
		buffer >> element->ke.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC1A.kf
bool assign_ExcIEEEAC1A_kf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC1A*>(base_class_ptr))
	{
		buffer >> element->kf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC1A.seve1
bool assign_ExcIEEEAC1A_seve1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC1A*>(base_class_ptr))
	{
		buffer >> element->seve1;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC1A.seve2
bool assign_ExcIEEEAC1A_seve2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC1A*>(base_class_ptr))
	{
		buffer >> element->seve2;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC1A.ta
bool assign_ExcIEEEAC1A_ta(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC1A*>(base_class_ptr))
	{
		buffer >> element->ta.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC1A.tb
bool assign_ExcIEEEAC1A_tb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC1A*>(base_class_ptr))
	{
		buffer >> element->tb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC1A.tc
bool assign_ExcIEEEAC1A_tc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC1A*>(base_class_ptr))
	{
		buffer >> element->tc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC1A.te
bool assign_ExcIEEEAC1A_te(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC1A*>(base_class_ptr))
	{
		buffer >> element->te.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC1A.tf
bool assign_ExcIEEEAC1A_tf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC1A*>(base_class_ptr))
	{
		buffer >> element->tf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC1A.vamax
bool assign_ExcIEEEAC1A_vamax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC1A*>(base_class_ptr))
	{
		buffer >> element->vamax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC1A.vamin
bool assign_ExcIEEEAC1A_vamin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC1A*>(base_class_ptr))
	{
		buffer >> element->vamin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC1A.ve1
bool assign_ExcIEEEAC1A_ve1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC1A*>(base_class_ptr))
	{
		buffer >> element->ve1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC1A.ve2
bool assign_ExcIEEEAC1A_ve2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC1A*>(base_class_ptr))
	{
		buffer >> element->ve2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC1A.vrmax
bool assign_ExcIEEEAC1A_vrmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC1A*>(base_class_ptr))
	{
		buffer >> element->vrmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC1A.vrmin
bool assign_ExcIEEEAC1A_vrmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC1A*>(base_class_ptr))
	{
		buffer >> element->vrmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC2A.ka
bool assign_ExcIEEEAC2A_ka(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC2A*>(base_class_ptr))
	{
		buffer >> element->ka.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC2A.kb
bool assign_ExcIEEEAC2A_kb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC2A*>(base_class_ptr))
	{
		buffer >> element->kb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC2A.kc
bool assign_ExcIEEEAC2A_kc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC2A*>(base_class_ptr))
	{
		buffer >> element->kc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC2A.kd
bool assign_ExcIEEEAC2A_kd(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC2A*>(base_class_ptr))
	{
		buffer >> element->kd.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC2A.ke
bool assign_ExcIEEEAC2A_ke(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC2A*>(base_class_ptr))
	{
		buffer >> element->ke.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC2A.kf
bool assign_ExcIEEEAC2A_kf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC2A*>(base_class_ptr))
	{
		buffer >> element->kf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC2A.kh
bool assign_ExcIEEEAC2A_kh(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC2A*>(base_class_ptr))
	{
		buffer >> element->kh.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC2A.seve1
bool assign_ExcIEEEAC2A_seve1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC2A*>(base_class_ptr))
	{
		buffer >> element->seve1;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC2A.seve2
bool assign_ExcIEEEAC2A_seve2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC2A*>(base_class_ptr))
	{
		buffer >> element->seve2;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC2A.ta
bool assign_ExcIEEEAC2A_ta(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC2A*>(base_class_ptr))
	{
		buffer >> element->ta.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC2A.tb
bool assign_ExcIEEEAC2A_tb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC2A*>(base_class_ptr))
	{
		buffer >> element->tb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC2A.tc
bool assign_ExcIEEEAC2A_tc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC2A*>(base_class_ptr))
	{
		buffer >> element->tc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC2A.te
bool assign_ExcIEEEAC2A_te(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC2A*>(base_class_ptr))
	{
		buffer >> element->te.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC2A.tf
bool assign_ExcIEEEAC2A_tf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC2A*>(base_class_ptr))
	{
		buffer >> element->tf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC2A.vamax
bool assign_ExcIEEEAC2A_vamax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC2A*>(base_class_ptr))
	{
		buffer >> element->vamax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC2A.vamin
bool assign_ExcIEEEAC2A_vamin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC2A*>(base_class_ptr))
	{
		buffer >> element->vamin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC2A.ve1
bool assign_ExcIEEEAC2A_ve1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC2A*>(base_class_ptr))
	{
		buffer >> element->ve1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC2A.ve2
bool assign_ExcIEEEAC2A_ve2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC2A*>(base_class_ptr))
	{
		buffer >> element->ve2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC2A.vfemax
bool assign_ExcIEEEAC2A_vfemax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC2A*>(base_class_ptr))
	{
		buffer >> element->vfemax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC2A.vrmax
bool assign_ExcIEEEAC2A_vrmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC2A*>(base_class_ptr))
	{
		buffer >> element->vrmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC2A.vrmin
bool assign_ExcIEEEAC2A_vrmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC2A*>(base_class_ptr))
	{
		buffer >> element->vrmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC3A.efdn
bool assign_ExcIEEEAC3A_efdn(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC3A*>(base_class_ptr))
	{
		buffer >> element->efdn.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC3A.ka
bool assign_ExcIEEEAC3A_ka(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC3A*>(base_class_ptr))
	{
		buffer >> element->ka.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC3A.kc
bool assign_ExcIEEEAC3A_kc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC3A*>(base_class_ptr))
	{
		buffer >> element->kc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC3A.kd
bool assign_ExcIEEEAC3A_kd(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC3A*>(base_class_ptr))
	{
		buffer >> element->kd.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC3A.ke
bool assign_ExcIEEEAC3A_ke(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC3A*>(base_class_ptr))
	{
		buffer >> element->ke.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC3A.kf
bool assign_ExcIEEEAC3A_kf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC3A*>(base_class_ptr))
	{
		buffer >> element->kf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC3A.kn
bool assign_ExcIEEEAC3A_kn(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC3A*>(base_class_ptr))
	{
		buffer >> element->kn.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC3A.kr
bool assign_ExcIEEEAC3A_kr(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC3A*>(base_class_ptr))
	{
		buffer >> element->kr.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC3A.seve1
bool assign_ExcIEEEAC3A_seve1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC3A*>(base_class_ptr))
	{
		buffer >> element->seve1;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC3A.seve2
bool assign_ExcIEEEAC3A_seve2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC3A*>(base_class_ptr))
	{
		buffer >> element->seve2;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC3A.ta
bool assign_ExcIEEEAC3A_ta(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC3A*>(base_class_ptr))
	{
		buffer >> element->ta.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC3A.tb
bool assign_ExcIEEEAC3A_tb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC3A*>(base_class_ptr))
	{
		buffer >> element->tb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC3A.tc
bool assign_ExcIEEEAC3A_tc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC3A*>(base_class_ptr))
	{
		buffer >> element->tc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC3A.te
bool assign_ExcIEEEAC3A_te(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC3A*>(base_class_ptr))
	{
		buffer >> element->te.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC3A.tf
bool assign_ExcIEEEAC3A_tf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC3A*>(base_class_ptr))
	{
		buffer >> element->tf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC3A.vamax
bool assign_ExcIEEEAC3A_vamax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC3A*>(base_class_ptr))
	{
		buffer >> element->vamax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC3A.vamin
bool assign_ExcIEEEAC3A_vamin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC3A*>(base_class_ptr))
	{
		buffer >> element->vamin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC3A.ve1
bool assign_ExcIEEEAC3A_ve1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC3A*>(base_class_ptr))
	{
		buffer >> element->ve1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC3A.ve2
bool assign_ExcIEEEAC3A_ve2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC3A*>(base_class_ptr))
	{
		buffer >> element->ve2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC3A.vemin
bool assign_ExcIEEEAC3A_vemin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC3A*>(base_class_ptr))
	{
		buffer >> element->vemin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC3A.vfemax
bool assign_ExcIEEEAC3A_vfemax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC3A*>(base_class_ptr))
	{
		buffer >> element->vfemax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC4A.ka
bool assign_ExcIEEEAC4A_ka(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC4A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC4A*>(base_class_ptr))
	{
		buffer >> element->ka.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC4A.kc
bool assign_ExcIEEEAC4A_kc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC4A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC4A*>(base_class_ptr))
	{
		buffer >> element->kc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC4A.ta
bool assign_ExcIEEEAC4A_ta(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC4A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC4A*>(base_class_ptr))
	{
		buffer >> element->ta.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC4A.tb
bool assign_ExcIEEEAC4A_tb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC4A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC4A*>(base_class_ptr))
	{
		buffer >> element->tb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC4A.tc
bool assign_ExcIEEEAC4A_tc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC4A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC4A*>(base_class_ptr))
	{
		buffer >> element->tc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC4A.vimax
bool assign_ExcIEEEAC4A_vimax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC4A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC4A*>(base_class_ptr))
	{
		buffer >> element->vimax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC4A.vimin
bool assign_ExcIEEEAC4A_vimin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC4A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC4A*>(base_class_ptr))
	{
		buffer >> element->vimin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC4A.vrmax
bool assign_ExcIEEEAC4A_vrmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC4A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC4A*>(base_class_ptr))
	{
		buffer >> element->vrmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC4A.vrmin
bool assign_ExcIEEEAC4A_vrmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC4A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC4A*>(base_class_ptr))
	{
		buffer >> element->vrmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC5A.efd1
bool assign_ExcIEEEAC5A_efd1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC5A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC5A*>(base_class_ptr))
	{
		buffer >> element->efd1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC5A.efd2
bool assign_ExcIEEEAC5A_efd2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC5A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC5A*>(base_class_ptr))
	{
		buffer >> element->efd2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC5A.ka
bool assign_ExcIEEEAC5A_ka(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC5A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC5A*>(base_class_ptr))
	{
		buffer >> element->ka.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC5A.ke
bool assign_ExcIEEEAC5A_ke(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC5A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC5A*>(base_class_ptr))
	{
		buffer >> element->ke.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC5A.kf
bool assign_ExcIEEEAC5A_kf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC5A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC5A*>(base_class_ptr))
	{
		buffer >> element->kf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC5A.seefd1
bool assign_ExcIEEEAC5A_seefd1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC5A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC5A*>(base_class_ptr))
	{
		buffer >> element->seefd1;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC5A.seefd2
bool assign_ExcIEEEAC5A_seefd2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC5A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC5A*>(base_class_ptr))
	{
		buffer >> element->seefd2;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC5A.ta
bool assign_ExcIEEEAC5A_ta(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC5A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC5A*>(base_class_ptr))
	{
		buffer >> element->ta.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC5A.te
bool assign_ExcIEEEAC5A_te(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC5A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC5A*>(base_class_ptr))
	{
		buffer >> element->te.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC5A.tf1
bool assign_ExcIEEEAC5A_tf1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC5A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC5A*>(base_class_ptr))
	{
		buffer >> element->tf1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC5A.tf2
bool assign_ExcIEEEAC5A_tf2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC5A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC5A*>(base_class_ptr))
	{
		buffer >> element->tf2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC5A.tf3
bool assign_ExcIEEEAC5A_tf3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC5A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC5A*>(base_class_ptr))
	{
		buffer >> element->tf3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC5A.vrmax
bool assign_ExcIEEEAC5A_vrmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC5A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC5A*>(base_class_ptr))
	{
		buffer >> element->vrmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC5A.vrmin
bool assign_ExcIEEEAC5A_vrmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC5A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC5A*>(base_class_ptr))
	{
		buffer >> element->vrmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC6A.ka
bool assign_ExcIEEEAC6A_ka(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC6A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC6A*>(base_class_ptr))
	{
		buffer >> element->ka.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC6A.kc
bool assign_ExcIEEEAC6A_kc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC6A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC6A*>(base_class_ptr))
	{
		buffer >> element->kc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC6A.kd
bool assign_ExcIEEEAC6A_kd(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC6A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC6A*>(base_class_ptr))
	{
		buffer >> element->kd.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC6A.ke
bool assign_ExcIEEEAC6A_ke(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC6A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC6A*>(base_class_ptr))
	{
		buffer >> element->ke.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC6A.kh
bool assign_ExcIEEEAC6A_kh(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC6A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC6A*>(base_class_ptr))
	{
		buffer >> element->kh.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC6A.seve1
bool assign_ExcIEEEAC6A_seve1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC6A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC6A*>(base_class_ptr))
	{
		buffer >> element->seve1;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC6A.seve2
bool assign_ExcIEEEAC6A_seve2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC6A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC6A*>(base_class_ptr))
	{
		buffer >> element->seve2;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC6A.ta
bool assign_ExcIEEEAC6A_ta(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC6A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC6A*>(base_class_ptr))
	{
		buffer >> element->ta.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC6A.tb
bool assign_ExcIEEEAC6A_tb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC6A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC6A*>(base_class_ptr))
	{
		buffer >> element->tb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC6A.tc
bool assign_ExcIEEEAC6A_tc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC6A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC6A*>(base_class_ptr))
	{
		buffer >> element->tc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC6A.te
bool assign_ExcIEEEAC6A_te(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC6A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC6A*>(base_class_ptr))
	{
		buffer >> element->te.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC6A.th
bool assign_ExcIEEEAC6A_th(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC6A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC6A*>(base_class_ptr))
	{
		buffer >> element->th.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC6A.tj
bool assign_ExcIEEEAC6A_tj(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC6A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC6A*>(base_class_ptr))
	{
		buffer >> element->tj.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC6A.tk
bool assign_ExcIEEEAC6A_tk(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC6A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC6A*>(base_class_ptr))
	{
		buffer >> element->tk.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC6A.vamax
bool assign_ExcIEEEAC6A_vamax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC6A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC6A*>(base_class_ptr))
	{
		buffer >> element->vamax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC6A.vamin
bool assign_ExcIEEEAC6A_vamin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC6A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC6A*>(base_class_ptr))
	{
		buffer >> element->vamin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC6A.ve1
bool assign_ExcIEEEAC6A_ve1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC6A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC6A*>(base_class_ptr))
	{
		buffer >> element->ve1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC6A.ve2
bool assign_ExcIEEEAC6A_ve2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC6A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC6A*>(base_class_ptr))
	{
		buffer >> element->ve2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC6A.vfelim
bool assign_ExcIEEEAC6A_vfelim(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC6A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC6A*>(base_class_ptr))
	{
		buffer >> element->vfelim.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC6A.vhmax
bool assign_ExcIEEEAC6A_vhmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC6A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC6A*>(base_class_ptr))
	{
		buffer >> element->vhmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC6A.vrmax
bool assign_ExcIEEEAC6A_vrmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC6A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC6A*>(base_class_ptr))
	{
		buffer >> element->vrmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC6A.vrmin
bool assign_ExcIEEEAC6A_vrmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC6A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC6A*>(base_class_ptr))
	{
		buffer >> element->vrmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC7B.kc
bool assign_ExcIEEEAC7B_kc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC7B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC7B*>(base_class_ptr))
	{
		buffer >> element->kc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC7B.kd
bool assign_ExcIEEEAC7B_kd(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC7B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC7B*>(base_class_ptr))
	{
		buffer >> element->kd.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC7B.kdr
bool assign_ExcIEEEAC7B_kdr(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC7B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC7B*>(base_class_ptr))
	{
		buffer >> element->kdr.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC7B.ke
bool assign_ExcIEEEAC7B_ke(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC7B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC7B*>(base_class_ptr))
	{
		buffer >> element->ke.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC7B.kf1
bool assign_ExcIEEEAC7B_kf1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC7B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC7B*>(base_class_ptr))
	{
		buffer >> element->kf1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC7B.kf2
bool assign_ExcIEEEAC7B_kf2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC7B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC7B*>(base_class_ptr))
	{
		buffer >> element->kf2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC7B.kf3
bool assign_ExcIEEEAC7B_kf3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC7B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC7B*>(base_class_ptr))
	{
		buffer >> element->kf3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC7B.kia
bool assign_ExcIEEEAC7B_kia(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC7B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC7B*>(base_class_ptr))
	{
		buffer >> element->kia.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC7B.kir
bool assign_ExcIEEEAC7B_kir(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC7B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC7B*>(base_class_ptr))
	{
		buffer >> element->kir.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC7B.kl
bool assign_ExcIEEEAC7B_kl(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC7B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC7B*>(base_class_ptr))
	{
		buffer >> element->kl.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC7B.kp
bool assign_ExcIEEEAC7B_kp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC7B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC7B*>(base_class_ptr))
	{
		buffer >> element->kp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC7B.kpa
bool assign_ExcIEEEAC7B_kpa(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC7B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC7B*>(base_class_ptr))
	{
		buffer >> element->kpa.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC7B.kpr
bool assign_ExcIEEEAC7B_kpr(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC7B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC7B*>(base_class_ptr))
	{
		buffer >> element->kpr.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC7B.seve1
bool assign_ExcIEEEAC7B_seve1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC7B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC7B*>(base_class_ptr))
	{
		buffer >> element->seve1;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC7B.seve2
bool assign_ExcIEEEAC7B_seve2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC7B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC7B*>(base_class_ptr))
	{
		buffer >> element->seve2;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC7B.tdr
bool assign_ExcIEEEAC7B_tdr(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC7B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC7B*>(base_class_ptr))
	{
		buffer >> element->tdr.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC7B.te
bool assign_ExcIEEEAC7B_te(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC7B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC7B*>(base_class_ptr))
	{
		buffer >> element->te.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC7B.tf
bool assign_ExcIEEEAC7B_tf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC7B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC7B*>(base_class_ptr))
	{
		buffer >> element->tf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC7B.vamax
bool assign_ExcIEEEAC7B_vamax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC7B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC7B*>(base_class_ptr))
	{
		buffer >> element->vamax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC7B.vamin
bool assign_ExcIEEEAC7B_vamin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC7B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC7B*>(base_class_ptr))
	{
		buffer >> element->vamin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC7B.ve1
bool assign_ExcIEEEAC7B_ve1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC7B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC7B*>(base_class_ptr))
	{
		buffer >> element->ve1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC7B.ve2
bool assign_ExcIEEEAC7B_ve2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC7B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC7B*>(base_class_ptr))
	{
		buffer >> element->ve2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC7B.vemin
bool assign_ExcIEEEAC7B_vemin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC7B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC7B*>(base_class_ptr))
	{
		buffer >> element->vemin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC7B.vfemax
bool assign_ExcIEEEAC7B_vfemax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC7B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC7B*>(base_class_ptr))
	{
		buffer >> element->vfemax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC7B.vrmax
bool assign_ExcIEEEAC7B_vrmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC7B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC7B*>(base_class_ptr))
	{
		buffer >> element->vrmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC7B.vrmin
bool assign_ExcIEEEAC7B_vrmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC7B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC7B*>(base_class_ptr))
	{
		buffer >> element->vrmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC8B.ka
bool assign_ExcIEEEAC8B_ka(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC8B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC8B*>(base_class_ptr))
	{
		buffer >> element->ka.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC8B.kc
bool assign_ExcIEEEAC8B_kc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC8B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC8B*>(base_class_ptr))
	{
		buffer >> element->kc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC8B.kd
bool assign_ExcIEEEAC8B_kd(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC8B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC8B*>(base_class_ptr))
	{
		buffer >> element->kd.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC8B.kdr
bool assign_ExcIEEEAC8B_kdr(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC8B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC8B*>(base_class_ptr))
	{
		buffer >> element->kdr.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC8B.ke
bool assign_ExcIEEEAC8B_ke(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC8B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC8B*>(base_class_ptr))
	{
		buffer >> element->ke.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC8B.kir
bool assign_ExcIEEEAC8B_kir(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC8B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC8B*>(base_class_ptr))
	{
		buffer >> element->kir.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC8B.kpr
bool assign_ExcIEEEAC8B_kpr(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC8B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC8B*>(base_class_ptr))
	{
		buffer >> element->kpr.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC8B.seve1
bool assign_ExcIEEEAC8B_seve1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC8B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC8B*>(base_class_ptr))
	{
		buffer >> element->seve1;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC8B.seve2
bool assign_ExcIEEEAC8B_seve2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC8B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC8B*>(base_class_ptr))
	{
		buffer >> element->seve2;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC8B.ta
bool assign_ExcIEEEAC8B_ta(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC8B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC8B*>(base_class_ptr))
	{
		buffer >> element->ta.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC8B.tdr
bool assign_ExcIEEEAC8B_tdr(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC8B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC8B*>(base_class_ptr))
	{
		buffer >> element->tdr.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC8B.te
bool assign_ExcIEEEAC8B_te(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC8B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC8B*>(base_class_ptr))
	{
		buffer >> element->te.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC8B.ve1
bool assign_ExcIEEEAC8B_ve1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC8B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC8B*>(base_class_ptr))
	{
		buffer >> element->ve1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC8B.ve2
bool assign_ExcIEEEAC8B_ve2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC8B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC8B*>(base_class_ptr))
	{
		buffer >> element->ve2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC8B.vemin
bool assign_ExcIEEEAC8B_vemin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC8B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC8B*>(base_class_ptr))
	{
		buffer >> element->vemin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC8B.vfemax
bool assign_ExcIEEEAC8B_vfemax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC8B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC8B*>(base_class_ptr))
	{
		buffer >> element->vfemax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC8B.vrmax
bool assign_ExcIEEEAC8B_vrmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC8B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC8B*>(base_class_ptr))
	{
		buffer >> element->vrmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEAC8B.vrmin
bool assign_ExcIEEEAC8B_vrmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC8B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEAC8B*>(base_class_ptr))
	{
		buffer >> element->vrmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC1A.efd1
bool assign_ExcIEEEDC1A_efd1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC1A*>(base_class_ptr))
	{
		buffer >> element->efd1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC1A.efd2
bool assign_ExcIEEEDC1A_efd2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC1A*>(base_class_ptr))
	{
		buffer >> element->efd2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC1A.exclim
bool assign_ExcIEEEDC1A_exclim(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC1A*>(base_class_ptr))
	{
		buffer >> element->exclim;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC1A.ka
bool assign_ExcIEEEDC1A_ka(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC1A*>(base_class_ptr))
	{
		buffer >> element->ka.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC1A.ke
bool assign_ExcIEEEDC1A_ke(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC1A*>(base_class_ptr))
	{
		buffer >> element->ke.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC1A.kf
bool assign_ExcIEEEDC1A_kf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC1A*>(base_class_ptr))
	{
		buffer >> element->kf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC1A.seefd1
bool assign_ExcIEEEDC1A_seefd1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC1A*>(base_class_ptr))
	{
		buffer >> element->seefd1;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC1A.seefd2
bool assign_ExcIEEEDC1A_seefd2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC1A*>(base_class_ptr))
	{
		buffer >> element->seefd2;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC1A.ta
bool assign_ExcIEEEDC1A_ta(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC1A*>(base_class_ptr))
	{
		buffer >> element->ta.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC1A.tb
bool assign_ExcIEEEDC1A_tb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC1A*>(base_class_ptr))
	{
		buffer >> element->tb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC1A.tc
bool assign_ExcIEEEDC1A_tc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC1A*>(base_class_ptr))
	{
		buffer >> element->tc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC1A.te
bool assign_ExcIEEEDC1A_te(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC1A*>(base_class_ptr))
	{
		buffer >> element->te.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC1A.tf
bool assign_ExcIEEEDC1A_tf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC1A*>(base_class_ptr))
	{
		buffer >> element->tf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC1A.uelin
bool assign_ExcIEEEDC1A_uelin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC1A*>(base_class_ptr))
	{
		buffer >> element->uelin;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC1A.vrmax
bool assign_ExcIEEEDC1A_vrmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC1A*>(base_class_ptr))
	{
		buffer >> element->vrmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC1A.vrmin
bool assign_ExcIEEEDC1A_vrmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC1A*>(base_class_ptr))
	{
		buffer >> element->vrmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC2A.efd1
bool assign_ExcIEEEDC2A_efd1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC2A*>(base_class_ptr))
	{
		buffer >> element->efd1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC2A.efd2
bool assign_ExcIEEEDC2A_efd2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC2A*>(base_class_ptr))
	{
		buffer >> element->efd2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC2A.exclim
bool assign_ExcIEEEDC2A_exclim(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC2A*>(base_class_ptr))
	{
		buffer >> element->exclim.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC2A.ka
bool assign_ExcIEEEDC2A_ka(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC2A*>(base_class_ptr))
	{
		buffer >> element->ka.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC2A.ke
bool assign_ExcIEEEDC2A_ke(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC2A*>(base_class_ptr))
	{
		buffer >> element->ke.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC2A.kf
bool assign_ExcIEEEDC2A_kf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC2A*>(base_class_ptr))
	{
		buffer >> element->kf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC2A.seefd1
bool assign_ExcIEEEDC2A_seefd1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC2A*>(base_class_ptr))
	{
		buffer >> element->seefd1;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC2A.seefd2
bool assign_ExcIEEEDC2A_seefd2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC2A*>(base_class_ptr))
	{
		buffer >> element->seefd2;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC2A.ta
bool assign_ExcIEEEDC2A_ta(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC2A*>(base_class_ptr))
	{
		buffer >> element->ta.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC2A.tb
bool assign_ExcIEEEDC2A_tb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC2A*>(base_class_ptr))
	{
		buffer >> element->tb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC2A.tc
bool assign_ExcIEEEDC2A_tc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC2A*>(base_class_ptr))
	{
		buffer >> element->tc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC2A.te
bool assign_ExcIEEEDC2A_te(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC2A*>(base_class_ptr))
	{
		buffer >> element->te.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC2A.tf
bool assign_ExcIEEEDC2A_tf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC2A*>(base_class_ptr))
	{
		buffer >> element->tf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC2A.uelin
bool assign_ExcIEEEDC2A_uelin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC2A*>(base_class_ptr))
	{
		buffer >> element->uelin;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC2A.vrmax
bool assign_ExcIEEEDC2A_vrmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC2A*>(base_class_ptr))
	{
		buffer >> element->vrmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC2A.vrmin
bool assign_ExcIEEEDC2A_vrmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC2A*>(base_class_ptr))
	{
		buffer >> element->vrmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC3A.efd1
bool assign_ExcIEEEDC3A_efd1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC3A*>(base_class_ptr))
	{
		buffer >> element->efd1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC3A.efd2
bool assign_ExcIEEEDC3A_efd2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC3A*>(base_class_ptr))
	{
		buffer >> element->efd2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC3A.exclim
bool assign_ExcIEEEDC3A_exclim(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC3A*>(base_class_ptr))
	{
		buffer >> element->exclim;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC3A.ke
bool assign_ExcIEEEDC3A_ke(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC3A*>(base_class_ptr))
	{
		buffer >> element->ke.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC3A.kv
bool assign_ExcIEEEDC3A_kv(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC3A*>(base_class_ptr))
	{
		buffer >> element->kv.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC3A.seefd1
bool assign_ExcIEEEDC3A_seefd1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC3A*>(base_class_ptr))
	{
		buffer >> element->seefd1;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC3A.seefd2
bool assign_ExcIEEEDC3A_seefd2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC3A*>(base_class_ptr))
	{
		buffer >> element->seefd2;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC3A.te
bool assign_ExcIEEEDC3A_te(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC3A*>(base_class_ptr))
	{
		buffer >> element->te.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC3A.trh
bool assign_ExcIEEEDC3A_trh(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC3A*>(base_class_ptr))
	{
		buffer >> element->trh.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC3A.vrmax
bool assign_ExcIEEEDC3A_vrmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC3A*>(base_class_ptr))
	{
		buffer >> element->vrmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC3A.vrmin
bool assign_ExcIEEEDC3A_vrmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC3A*>(base_class_ptr))
	{
		buffer >> element->vrmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC4B.efd1
bool assign_ExcIEEEDC4B_efd1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC4B*>(base_class_ptr))
	{
		buffer >> element->efd1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC4B.efd2
bool assign_ExcIEEEDC4B_efd2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC4B*>(base_class_ptr))
	{
		buffer >> element->efd2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC4B.ka
bool assign_ExcIEEEDC4B_ka(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC4B*>(base_class_ptr))
	{
		buffer >> element->ka.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC4B.kd
bool assign_ExcIEEEDC4B_kd(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC4B*>(base_class_ptr))
	{
		buffer >> element->kd.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC4B.ke
bool assign_ExcIEEEDC4B_ke(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC4B*>(base_class_ptr))
	{
		buffer >> element->ke.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC4B.kf
bool assign_ExcIEEEDC4B_kf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC4B*>(base_class_ptr))
	{
		buffer >> element->kf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC4B.ki
bool assign_ExcIEEEDC4B_ki(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC4B*>(base_class_ptr))
	{
		buffer >> element->ki.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC4B.kp
bool assign_ExcIEEEDC4B_kp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC4B*>(base_class_ptr))
	{
		buffer >> element->kp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC4B.oelin
bool assign_ExcIEEEDC4B_oelin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC4B*>(base_class_ptr))
	{
		buffer >> element->oelin;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC4B.seefd1
bool assign_ExcIEEEDC4B_seefd1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC4B*>(base_class_ptr))
	{
		buffer >> element->seefd1;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC4B.seefd2
bool assign_ExcIEEEDC4B_seefd2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC4B*>(base_class_ptr))
	{
		buffer >> element->seefd2;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC4B.ta
bool assign_ExcIEEEDC4B_ta(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC4B*>(base_class_ptr))
	{
		buffer >> element->ta.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC4B.td
bool assign_ExcIEEEDC4B_td(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC4B*>(base_class_ptr))
	{
		buffer >> element->td.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC4B.te
bool assign_ExcIEEEDC4B_te(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC4B*>(base_class_ptr))
	{
		buffer >> element->te.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC4B.tf
bool assign_ExcIEEEDC4B_tf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC4B*>(base_class_ptr))
	{
		buffer >> element->tf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC4B.uelin
bool assign_ExcIEEEDC4B_uelin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC4B*>(base_class_ptr))
	{
		buffer >> element->uelin;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC4B.vemin
bool assign_ExcIEEEDC4B_vemin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC4B*>(base_class_ptr))
	{
		buffer >> element->vemin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC4B.vrmax
bool assign_ExcIEEEDC4B_vrmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC4B*>(base_class_ptr))
	{
		buffer >> element->vrmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEDC4B.vrmin
bool assign_ExcIEEEDC4B_vrmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEDC4B*>(base_class_ptr))
	{
		buffer >> element->vrmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST1A.ilr
bool assign_ExcIEEEST1A_ilr(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST1A*>(base_class_ptr))
	{
		buffer >> element->ilr.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST1A.ka
bool assign_ExcIEEEST1A_ka(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST1A*>(base_class_ptr))
	{
		buffer >> element->ka.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST1A.kc
bool assign_ExcIEEEST1A_kc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST1A*>(base_class_ptr))
	{
		buffer >> element->kc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST1A.kf
bool assign_ExcIEEEST1A_kf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST1A*>(base_class_ptr))
	{
		buffer >> element->kf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST1A.klr
bool assign_ExcIEEEST1A_klr(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST1A*>(base_class_ptr))
	{
		buffer >> element->klr.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST1A.pssin
bool assign_ExcIEEEST1A_pssin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST1A*>(base_class_ptr))
	{
		buffer >> element->pssin;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST1A.ta
bool assign_ExcIEEEST1A_ta(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST1A*>(base_class_ptr))
	{
		buffer >> element->ta.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST1A.tb
bool assign_ExcIEEEST1A_tb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST1A*>(base_class_ptr))
	{
		buffer >> element->tb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST1A.tb1
bool assign_ExcIEEEST1A_tb1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST1A*>(base_class_ptr))
	{
		buffer >> element->tb1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST1A.tc
bool assign_ExcIEEEST1A_tc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST1A*>(base_class_ptr))
	{
		buffer >> element->tc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST1A.tc1
bool assign_ExcIEEEST1A_tc1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST1A*>(base_class_ptr))
	{
		buffer >> element->tc1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST1A.tf
bool assign_ExcIEEEST1A_tf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST1A*>(base_class_ptr))
	{
		buffer >> element->tf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST1A.uelin
bool assign_ExcIEEEST1A_uelin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST1A*>(base_class_ptr))
	{
		buffer >> element->uelin;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST1A.vamax
bool assign_ExcIEEEST1A_vamax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST1A*>(base_class_ptr))
	{
		buffer >> element->vamax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST1A.vamin
bool assign_ExcIEEEST1A_vamin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST1A*>(base_class_ptr))
	{
		buffer >> element->vamin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST1A.vimax
bool assign_ExcIEEEST1A_vimax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST1A*>(base_class_ptr))
	{
		buffer >> element->vimax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST1A.vimin
bool assign_ExcIEEEST1A_vimin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST1A*>(base_class_ptr))
	{
		buffer >> element->vimin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST1A.vrmax
bool assign_ExcIEEEST1A_vrmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST1A*>(base_class_ptr))
	{
		buffer >> element->vrmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST1A.vrmin
bool assign_ExcIEEEST1A_vrmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST1A*>(base_class_ptr))
	{
		buffer >> element->vrmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST2A.efdmax
bool assign_ExcIEEEST2A_efdmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST2A*>(base_class_ptr))
	{
		buffer >> element->efdmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST2A.ka
bool assign_ExcIEEEST2A_ka(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST2A*>(base_class_ptr))
	{
		buffer >> element->ka.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST2A.kc
bool assign_ExcIEEEST2A_kc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST2A*>(base_class_ptr))
	{
		buffer >> element->kc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST2A.ke
bool assign_ExcIEEEST2A_ke(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST2A*>(base_class_ptr))
	{
		buffer >> element->ke.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST2A.kf
bool assign_ExcIEEEST2A_kf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST2A*>(base_class_ptr))
	{
		buffer >> element->kf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST2A.ki
bool assign_ExcIEEEST2A_ki(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST2A*>(base_class_ptr))
	{
		buffer >> element->ki.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST2A.kp
bool assign_ExcIEEEST2A_kp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST2A*>(base_class_ptr))
	{
		buffer >> element->kp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST2A.ta
bool assign_ExcIEEEST2A_ta(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST2A*>(base_class_ptr))
	{
		buffer >> element->ta.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST2A.te
bool assign_ExcIEEEST2A_te(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST2A*>(base_class_ptr))
	{
		buffer >> element->te.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST2A.tf
bool assign_ExcIEEEST2A_tf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST2A*>(base_class_ptr))
	{
		buffer >> element->tf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST2A.uelin
bool assign_ExcIEEEST2A_uelin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST2A*>(base_class_ptr))
	{
		buffer >> element->uelin;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST2A.vrmax
bool assign_ExcIEEEST2A_vrmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST2A*>(base_class_ptr))
	{
		buffer >> element->vrmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST2A.vrmin
bool assign_ExcIEEEST2A_vrmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST2A*>(base_class_ptr))
	{
		buffer >> element->vrmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST3A.ka
bool assign_ExcIEEEST3A_ka(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST3A*>(base_class_ptr))
	{
		buffer >> element->ka.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST3A.kc
bool assign_ExcIEEEST3A_kc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST3A*>(base_class_ptr))
	{
		buffer >> element->kc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST3A.kg
bool assign_ExcIEEEST3A_kg(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST3A*>(base_class_ptr))
	{
		buffer >> element->kg.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST3A.ki
bool assign_ExcIEEEST3A_ki(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST3A*>(base_class_ptr))
	{
		buffer >> element->ki.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST3A.km
bool assign_ExcIEEEST3A_km(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST3A*>(base_class_ptr))
	{
		buffer >> element->km.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST3A.kp
bool assign_ExcIEEEST3A_kp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST3A*>(base_class_ptr))
	{
		buffer >> element->kp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST3A.ta
bool assign_ExcIEEEST3A_ta(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST3A*>(base_class_ptr))
	{
		buffer >> element->ta.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST3A.tb
bool assign_ExcIEEEST3A_tb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST3A*>(base_class_ptr))
	{
		buffer >> element->tb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST3A.tc
bool assign_ExcIEEEST3A_tc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST3A*>(base_class_ptr))
	{
		buffer >> element->tc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST3A.thetap
bool assign_ExcIEEEST3A_thetap(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST3A*>(base_class_ptr))
	{
		buffer >> element->thetap.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST3A.tm
bool assign_ExcIEEEST3A_tm(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST3A*>(base_class_ptr))
	{
		buffer >> element->tm.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST3A.vbmax
bool assign_ExcIEEEST3A_vbmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST3A*>(base_class_ptr))
	{
		buffer >> element->vbmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST3A.vgmax
bool assign_ExcIEEEST3A_vgmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST3A*>(base_class_ptr))
	{
		buffer >> element->vgmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST3A.vimax
bool assign_ExcIEEEST3A_vimax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST3A*>(base_class_ptr))
	{
		buffer >> element->vimax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST3A.vimin
bool assign_ExcIEEEST3A_vimin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST3A*>(base_class_ptr))
	{
		buffer >> element->vimin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST3A.vmmax
bool assign_ExcIEEEST3A_vmmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST3A*>(base_class_ptr))
	{
		buffer >> element->vmmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST3A.vmmin
bool assign_ExcIEEEST3A_vmmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST3A*>(base_class_ptr))
	{
		buffer >> element->vmmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST3A.vrmax
bool assign_ExcIEEEST3A_vrmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST3A*>(base_class_ptr))
	{
		buffer >> element->vrmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST3A.vrmin
bool assign_ExcIEEEST3A_vrmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST3A*>(base_class_ptr))
	{
		buffer >> element->vrmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST3A.xl
bool assign_ExcIEEEST3A_xl(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST3A*>(base_class_ptr))
	{
		buffer >> element->xl.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST4B.kc
bool assign_ExcIEEEST4B_kc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST4B*>(base_class_ptr))
	{
		buffer >> element->kc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST4B.kg
bool assign_ExcIEEEST4B_kg(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST4B*>(base_class_ptr))
	{
		buffer >> element->kg.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST4B.ki
bool assign_ExcIEEEST4B_ki(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST4B*>(base_class_ptr))
	{
		buffer >> element->ki.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST4B.kim
bool assign_ExcIEEEST4B_kim(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST4B*>(base_class_ptr))
	{
		buffer >> element->kim.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST4B.kir
bool assign_ExcIEEEST4B_kir(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST4B*>(base_class_ptr))
	{
		buffer >> element->kir.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST4B.kp
bool assign_ExcIEEEST4B_kp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST4B*>(base_class_ptr))
	{
		buffer >> element->kp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST4B.kpm
bool assign_ExcIEEEST4B_kpm(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST4B*>(base_class_ptr))
	{
		buffer >> element->kpm.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST4B.kpr
bool assign_ExcIEEEST4B_kpr(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST4B*>(base_class_ptr))
	{
		buffer >> element->kpr.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST4B.ta
bool assign_ExcIEEEST4B_ta(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST4B*>(base_class_ptr))
	{
		buffer >> element->ta.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST4B.thetap
bool assign_ExcIEEEST4B_thetap(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST4B*>(base_class_ptr))
	{
		buffer >> element->thetap.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST4B.vbmax
bool assign_ExcIEEEST4B_vbmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST4B*>(base_class_ptr))
	{
		buffer >> element->vbmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST4B.vmmax
bool assign_ExcIEEEST4B_vmmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST4B*>(base_class_ptr))
	{
		buffer >> element->vmmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST4B.vmmin
bool assign_ExcIEEEST4B_vmmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST4B*>(base_class_ptr))
	{
		buffer >> element->vmmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST4B.vrmax
bool assign_ExcIEEEST4B_vrmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST4B*>(base_class_ptr))
	{
		buffer >> element->vrmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST4B.vrmin
bool assign_ExcIEEEST4B_vrmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST4B*>(base_class_ptr))
	{
		buffer >> element->vrmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST4B.xl
bool assign_ExcIEEEST4B_xl(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST4B*>(base_class_ptr))
	{
		buffer >> element->xl.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST5B.kc
bool assign_ExcIEEEST5B_kc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST5B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST5B*>(base_class_ptr))
	{
		buffer >> element->kc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST5B.kr
bool assign_ExcIEEEST5B_kr(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST5B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST5B*>(base_class_ptr))
	{
		buffer >> element->kr.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST5B.t1
bool assign_ExcIEEEST5B_t1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST5B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST5B*>(base_class_ptr))
	{
		buffer >> element->t1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST5B.tb1
bool assign_ExcIEEEST5B_tb1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST5B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST5B*>(base_class_ptr))
	{
		buffer >> element->tb1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST5B.tb2
bool assign_ExcIEEEST5B_tb2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST5B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST5B*>(base_class_ptr))
	{
		buffer >> element->tb2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST5B.tc1
bool assign_ExcIEEEST5B_tc1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST5B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST5B*>(base_class_ptr))
	{
		buffer >> element->tc1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST5B.tc2
bool assign_ExcIEEEST5B_tc2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST5B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST5B*>(base_class_ptr))
	{
		buffer >> element->tc2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST5B.tob1
bool assign_ExcIEEEST5B_tob1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST5B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST5B*>(base_class_ptr))
	{
		buffer >> element->tob1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST5B.tob2
bool assign_ExcIEEEST5B_tob2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST5B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST5B*>(base_class_ptr))
	{
		buffer >> element->tob2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST5B.toc1
bool assign_ExcIEEEST5B_toc1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST5B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST5B*>(base_class_ptr))
	{
		buffer >> element->toc1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST5B.toc2
bool assign_ExcIEEEST5B_toc2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST5B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST5B*>(base_class_ptr))
	{
		buffer >> element->toc2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST5B.tub1
bool assign_ExcIEEEST5B_tub1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST5B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST5B*>(base_class_ptr))
	{
		buffer >> element->tub1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST5B.tub2
bool assign_ExcIEEEST5B_tub2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST5B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST5B*>(base_class_ptr))
	{
		buffer >> element->tub2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST5B.tuc1
bool assign_ExcIEEEST5B_tuc1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST5B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST5B*>(base_class_ptr))
	{
		buffer >> element->tuc1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST5B.tuc2
bool assign_ExcIEEEST5B_tuc2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST5B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST5B*>(base_class_ptr))
	{
		buffer >> element->tuc2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST5B.vrmax
bool assign_ExcIEEEST5B_vrmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST5B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST5B*>(base_class_ptr))
	{
		buffer >> element->vrmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST5B.vrmin
bool assign_ExcIEEEST5B_vrmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST5B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST5B*>(base_class_ptr))
	{
		buffer >> element->vrmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST6B.ilr
bool assign_ExcIEEEST6B_ilr(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST6B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST6B*>(base_class_ptr))
	{
		buffer >> element->ilr.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST6B.kci
bool assign_ExcIEEEST6B_kci(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST6B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST6B*>(base_class_ptr))
	{
		buffer >> element->kci.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST6B.kff
bool assign_ExcIEEEST6B_kff(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST6B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST6B*>(base_class_ptr))
	{
		buffer >> element->kff.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST6B.kg
bool assign_ExcIEEEST6B_kg(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST6B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST6B*>(base_class_ptr))
	{
		buffer >> element->kg.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST6B.kia
bool assign_ExcIEEEST6B_kia(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST6B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST6B*>(base_class_ptr))
	{
		buffer >> element->kia.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST6B.klr
bool assign_ExcIEEEST6B_klr(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST6B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST6B*>(base_class_ptr))
	{
		buffer >> element->klr.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST6B.km
bool assign_ExcIEEEST6B_km(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST6B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST6B*>(base_class_ptr))
	{
		buffer >> element->km.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST6B.kpa
bool assign_ExcIEEEST6B_kpa(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST6B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST6B*>(base_class_ptr))
	{
		buffer >> element->kpa.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST6B.oelin
bool assign_ExcIEEEST6B_oelin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST6B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST6B*>(base_class_ptr))
	{
		buffer >> element->oelin;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST6B.tg
bool assign_ExcIEEEST6B_tg(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST6B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST6B*>(base_class_ptr))
	{
		buffer >> element->tg.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST6B.vamax
bool assign_ExcIEEEST6B_vamax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST6B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST6B*>(base_class_ptr))
	{
		buffer >> element->vamax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST6B.vamin
bool assign_ExcIEEEST6B_vamin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST6B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST6B*>(base_class_ptr))
	{
		buffer >> element->vamin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST6B.vrmax
bool assign_ExcIEEEST6B_vrmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST6B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST6B*>(base_class_ptr))
	{
		buffer >> element->vrmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST6B.vrmin
bool assign_ExcIEEEST6B_vrmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST6B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST6B*>(base_class_ptr))
	{
		buffer >> element->vrmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST7B.kh
bool assign_ExcIEEEST7B_kh(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST7B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST7B*>(base_class_ptr))
	{
		buffer >> element->kh.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST7B.kia
bool assign_ExcIEEEST7B_kia(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST7B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST7B*>(base_class_ptr))
	{
		buffer >> element->kia.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST7B.kl
bool assign_ExcIEEEST7B_kl(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST7B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST7B*>(base_class_ptr))
	{
		buffer >> element->kl.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST7B.kpa
bool assign_ExcIEEEST7B_kpa(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST7B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST7B*>(base_class_ptr))
	{
		buffer >> element->kpa.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST7B.oelin
bool assign_ExcIEEEST7B_oelin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST7B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST7B*>(base_class_ptr))
	{
		buffer >> element->oelin;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST7B.tb
bool assign_ExcIEEEST7B_tb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST7B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST7B*>(base_class_ptr))
	{
		buffer >> element->tb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST7B.tc
bool assign_ExcIEEEST7B_tc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST7B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST7B*>(base_class_ptr))
	{
		buffer >> element->tc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST7B.tf
bool assign_ExcIEEEST7B_tf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST7B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST7B*>(base_class_ptr))
	{
		buffer >> element->tf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST7B.tg
bool assign_ExcIEEEST7B_tg(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST7B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST7B*>(base_class_ptr))
	{
		buffer >> element->tg.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST7B.tia
bool assign_ExcIEEEST7B_tia(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST7B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST7B*>(base_class_ptr))
	{
		buffer >> element->tia.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST7B.uelin
bool assign_ExcIEEEST7B_uelin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST7B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST7B*>(base_class_ptr))
	{
		buffer >> element->uelin;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST7B.vmax
bool assign_ExcIEEEST7B_vmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST7B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST7B*>(base_class_ptr))
	{
		buffer >> element->vmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST7B.vmin
bool assign_ExcIEEEST7B_vmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST7B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST7B*>(base_class_ptr))
	{
		buffer >> element->vmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST7B.vrmax
bool assign_ExcIEEEST7B_vrmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST7B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST7B*>(base_class_ptr))
	{
		buffer >> element->vrmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcIEEEST7B.vrmin
bool assign_ExcIEEEST7B_vrmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST7B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcIEEEST7B*>(base_class_ptr))
	{
		buffer >> element->vrmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcOEX3T.e1
bool assign_ExcOEX3T_e1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcOEX3T* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcOEX3T*>(base_class_ptr))
	{
		buffer >> element->e1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcOEX3T.e2
bool assign_ExcOEX3T_e2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcOEX3T* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcOEX3T*>(base_class_ptr))
	{
		buffer >> element->e2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcOEX3T.ka
bool assign_ExcOEX3T_ka(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcOEX3T* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcOEX3T*>(base_class_ptr))
	{
		buffer >> element->ka.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcOEX3T.kc
bool assign_ExcOEX3T_kc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcOEX3T* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcOEX3T*>(base_class_ptr))
	{
		buffer >> element->kc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcOEX3T.kd
bool assign_ExcOEX3T_kd(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcOEX3T* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcOEX3T*>(base_class_ptr))
	{
		buffer >> element->kd.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcOEX3T.ke
bool assign_ExcOEX3T_ke(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcOEX3T* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcOEX3T*>(base_class_ptr))
	{
		buffer >> element->ke.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcOEX3T.kf
bool assign_ExcOEX3T_kf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcOEX3T* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcOEX3T*>(base_class_ptr))
	{
		buffer >> element->kf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcOEX3T.see1
bool assign_ExcOEX3T_see1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcOEX3T* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcOEX3T*>(base_class_ptr))
	{
		buffer >> element->see1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcOEX3T.see2
bool assign_ExcOEX3T_see2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcOEX3T* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcOEX3T*>(base_class_ptr))
	{
		buffer >> element->see2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcOEX3T.t1
bool assign_ExcOEX3T_t1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcOEX3T* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcOEX3T*>(base_class_ptr))
	{
		buffer >> element->t1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcOEX3T.t2
bool assign_ExcOEX3T_t2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcOEX3T* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcOEX3T*>(base_class_ptr))
	{
		buffer >> element->t2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcOEX3T.t3
bool assign_ExcOEX3T_t3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcOEX3T* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcOEX3T*>(base_class_ptr))
	{
		buffer >> element->t3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcOEX3T.t4
bool assign_ExcOEX3T_t4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcOEX3T* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcOEX3T*>(base_class_ptr))
	{
		buffer >> element->t4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcOEX3T.t5
bool assign_ExcOEX3T_t5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcOEX3T* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcOEX3T*>(base_class_ptr))
	{
		buffer >> element->t5.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcOEX3T.t6
bool assign_ExcOEX3T_t6(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcOEX3T* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcOEX3T*>(base_class_ptr))
	{
		buffer >> element->t6.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcOEX3T.te
bool assign_ExcOEX3T_te(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcOEX3T* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcOEX3T*>(base_class_ptr))
	{
		buffer >> element->te.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcOEX3T.tf
bool assign_ExcOEX3T_tf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcOEX3T* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcOEX3T*>(base_class_ptr))
	{
		buffer >> element->tf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcOEX3T.vrmax
bool assign_ExcOEX3T_vrmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcOEX3T* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcOEX3T*>(base_class_ptr))
	{
		buffer >> element->vrmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcOEX3T.vrmin
bool assign_ExcOEX3T_vrmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcOEX3T* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcOEX3T*>(base_class_ptr))
	{
		buffer >> element->vrmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcPIC.e1
bool assign_ExcPIC_e1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcPIC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcPIC*>(base_class_ptr))
	{
		buffer >> element->e1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcPIC.e2
bool assign_ExcPIC_e2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcPIC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcPIC*>(base_class_ptr))
	{
		buffer >> element->e2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcPIC.efdmax
bool assign_ExcPIC_efdmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcPIC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcPIC*>(base_class_ptr))
	{
		buffer >> element->efdmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcPIC.efdmin
bool assign_ExcPIC_efdmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcPIC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcPIC*>(base_class_ptr))
	{
		buffer >> element->efdmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcPIC.ka
bool assign_ExcPIC_ka(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcPIC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcPIC*>(base_class_ptr))
	{
		buffer >> element->ka.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcPIC.kc
bool assign_ExcPIC_kc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcPIC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcPIC*>(base_class_ptr))
	{
		buffer >> element->kc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcPIC.ke
bool assign_ExcPIC_ke(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcPIC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcPIC*>(base_class_ptr))
	{
		buffer >> element->ke.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcPIC.kf
bool assign_ExcPIC_kf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcPIC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcPIC*>(base_class_ptr))
	{
		buffer >> element->kf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcPIC.ki
bool assign_ExcPIC_ki(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcPIC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcPIC*>(base_class_ptr))
	{
		buffer >> element->ki.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcPIC.kp
bool assign_ExcPIC_kp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcPIC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcPIC*>(base_class_ptr))
	{
		buffer >> element->kp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcPIC.se1
bool assign_ExcPIC_se1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcPIC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcPIC*>(base_class_ptr))
	{
		buffer >> element->se1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcPIC.se2
bool assign_ExcPIC_se2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcPIC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcPIC*>(base_class_ptr))
	{
		buffer >> element->se2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcPIC.ta1
bool assign_ExcPIC_ta1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcPIC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcPIC*>(base_class_ptr))
	{
		buffer >> element->ta1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcPIC.ta2
bool assign_ExcPIC_ta2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcPIC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcPIC*>(base_class_ptr))
	{
		buffer >> element->ta2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcPIC.ta3
bool assign_ExcPIC_ta3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcPIC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcPIC*>(base_class_ptr))
	{
		buffer >> element->ta3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcPIC.ta4
bool assign_ExcPIC_ta4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcPIC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcPIC*>(base_class_ptr))
	{
		buffer >> element->ta4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcPIC.te
bool assign_ExcPIC_te(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcPIC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcPIC*>(base_class_ptr))
	{
		buffer >> element->te.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcPIC.tf1
bool assign_ExcPIC_tf1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcPIC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcPIC*>(base_class_ptr))
	{
		buffer >> element->tf1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcPIC.tf2
bool assign_ExcPIC_tf2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcPIC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcPIC*>(base_class_ptr))
	{
		buffer >> element->tf2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcPIC.vr1
bool assign_ExcPIC_vr1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcPIC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcPIC*>(base_class_ptr))
	{
		buffer >> element->vr1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcPIC.vr2
bool assign_ExcPIC_vr2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcPIC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcPIC*>(base_class_ptr))
	{
		buffer >> element->vr2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcPIC.vrmax
bool assign_ExcPIC_vrmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcPIC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcPIC*>(base_class_ptr))
	{
		buffer >> element->vrmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcPIC.vrmin
bool assign_ExcPIC_vrmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcPIC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcPIC*>(base_class_ptr))
	{
		buffer >> element->vrmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcREXS.e1
bool assign_ExcREXS_e1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS*>(base_class_ptr))
	{
		buffer >> element->e1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcREXS.e2
bool assign_ExcREXS_e2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS*>(base_class_ptr))
	{
		buffer >> element->e2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcREXS.fbf
bool assign_ExcREXS_fbf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS*>(base_class_ptr))
	{
		buffer >> element->fbf;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcREXS.flimf
bool assign_ExcREXS_flimf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS*>(base_class_ptr))
	{
		buffer >> element->flimf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcREXS.kc
bool assign_ExcREXS_kc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS*>(base_class_ptr))
	{
		buffer >> element->kc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcREXS.kd
bool assign_ExcREXS_kd(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS*>(base_class_ptr))
	{
		buffer >> element->kd.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcREXS.ke
bool assign_ExcREXS_ke(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS*>(base_class_ptr))
	{
		buffer >> element->ke.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcREXS.kefd
bool assign_ExcREXS_kefd(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS*>(base_class_ptr))
	{
		buffer >> element->kefd.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcREXS.kf
bool assign_ExcREXS_kf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS*>(base_class_ptr))
	{
		buffer >> element->kf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcREXS.kh
bool assign_ExcREXS_kh(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS*>(base_class_ptr))
	{
		buffer >> element->kh.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcREXS.kii
bool assign_ExcREXS_kii(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS*>(base_class_ptr))
	{
		buffer >> element->kii.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcREXS.kip
bool assign_ExcREXS_kip(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS*>(base_class_ptr))
	{
		buffer >> element->kip.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcREXS.ks
bool assign_ExcREXS_ks(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS*>(base_class_ptr))
	{
		buffer >> element->ks.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcREXS.kvi
bool assign_ExcREXS_kvi(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS*>(base_class_ptr))
	{
		buffer >> element->kvi.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcREXS.kvp
bool assign_ExcREXS_kvp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS*>(base_class_ptr))
	{
		buffer >> element->kvp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcREXS.kvphz
bool assign_ExcREXS_kvphz(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS*>(base_class_ptr))
	{
		buffer >> element->kvphz.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcREXS.nvphz
bool assign_ExcREXS_nvphz(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS*>(base_class_ptr))
	{
		buffer >> element->nvphz.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcREXS.se1
bool assign_ExcREXS_se1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS*>(base_class_ptr))
	{
		buffer >> element->se1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcREXS.se2
bool assign_ExcREXS_se2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS*>(base_class_ptr))
	{
		buffer >> element->se2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcREXS.ta
bool assign_ExcREXS_ta(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS*>(base_class_ptr))
	{
		buffer >> element->ta.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcREXS.tb1
bool assign_ExcREXS_tb1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS*>(base_class_ptr))
	{
		buffer >> element->tb1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcREXS.tb2
bool assign_ExcREXS_tb2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS*>(base_class_ptr))
	{
		buffer >> element->tb2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcREXS.tc1
bool assign_ExcREXS_tc1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS*>(base_class_ptr))
	{
		buffer >> element->tc1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcREXS.tc2
bool assign_ExcREXS_tc2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS*>(base_class_ptr))
	{
		buffer >> element->tc2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcREXS.te
bool assign_ExcREXS_te(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS*>(base_class_ptr))
	{
		buffer >> element->te.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcREXS.tf
bool assign_ExcREXS_tf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS*>(base_class_ptr))
	{
		buffer >> element->tf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcREXS.tf1
bool assign_ExcREXS_tf1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS*>(base_class_ptr))
	{
		buffer >> element->tf1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcREXS.tf2
bool assign_ExcREXS_tf2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS*>(base_class_ptr))
	{
		buffer >> element->tf2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcREXS.tp
bool assign_ExcREXS_tp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS*>(base_class_ptr))
	{
		buffer >> element->tp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcREXS.vcmax
bool assign_ExcREXS_vcmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS*>(base_class_ptr))
	{
		buffer >> element->vcmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcREXS.vfmax
bool assign_ExcREXS_vfmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS*>(base_class_ptr))
	{
		buffer >> element->vfmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcREXS.vfmin
bool assign_ExcREXS_vfmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS*>(base_class_ptr))
	{
		buffer >> element->vfmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcREXS.vimax
bool assign_ExcREXS_vimax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS*>(base_class_ptr))
	{
		buffer >> element->vimax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcREXS.vrmax
bool assign_ExcREXS_vrmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS*>(base_class_ptr))
	{
		buffer >> element->vrmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcREXS.vrmin
bool assign_ExcREXS_vrmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS*>(base_class_ptr))
	{
		buffer >> element->vrmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcREXS.xc
bool assign_ExcREXS_xc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcREXS*>(base_class_ptr))
	{
		buffer >> element->xc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcSCRX.cswitch
bool assign_ExcSCRX_cswitch(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSCRX* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSCRX*>(base_class_ptr))
	{
		buffer >> element->cswitch;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcSCRX.emax
bool assign_ExcSCRX_emax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSCRX* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSCRX*>(base_class_ptr))
	{
		buffer >> element->emax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcSCRX.emin
bool assign_ExcSCRX_emin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSCRX* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSCRX*>(base_class_ptr))
	{
		buffer >> element->emin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcSCRX.k
bool assign_ExcSCRX_k(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSCRX* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSCRX*>(base_class_ptr))
	{
		buffer >> element->k.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcSCRX.rcrfd
bool assign_ExcSCRX_rcrfd(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSCRX* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSCRX*>(base_class_ptr))
	{
		buffer >> element->rcrfd;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcSCRX.tatb
bool assign_ExcSCRX_tatb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSCRX* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSCRX*>(base_class_ptr))
	{
		buffer >> element->tatb;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcSCRX.tb
bool assign_ExcSCRX_tb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSCRX* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSCRX*>(base_class_ptr))
	{
		buffer >> element->tb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcSCRX.te
bool assign_ExcSCRX_te(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSCRX* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSCRX*>(base_class_ptr))
	{
		buffer >> element->te.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcSEXS.efdmax
bool assign_ExcSEXS_efdmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSEXS* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSEXS*>(base_class_ptr))
	{
		buffer >> element->efdmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcSEXS.efdmin
bool assign_ExcSEXS_efdmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSEXS* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSEXS*>(base_class_ptr))
	{
		buffer >> element->efdmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcSEXS.emax
bool assign_ExcSEXS_emax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSEXS* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSEXS*>(base_class_ptr))
	{
		buffer >> element->emax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcSEXS.emin
bool assign_ExcSEXS_emin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSEXS* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSEXS*>(base_class_ptr))
	{
		buffer >> element->emin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcSEXS.k
bool assign_ExcSEXS_k(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSEXS* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSEXS*>(base_class_ptr))
	{
		buffer >> element->k.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcSEXS.kc
bool assign_ExcSEXS_kc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSEXS* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSEXS*>(base_class_ptr))
	{
		buffer >> element->kc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcSEXS.tatb
bool assign_ExcSEXS_tatb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSEXS* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSEXS*>(base_class_ptr))
	{
		buffer >> element->tatb;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcSEXS.tb
bool assign_ExcSEXS_tb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSEXS* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSEXS*>(base_class_ptr))
	{
		buffer >> element->tb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcSEXS.tc
bool assign_ExcSEXS_tc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSEXS* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSEXS*>(base_class_ptr))
	{
		buffer >> element->tc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcSEXS.te
bool assign_ExcSEXS_te(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSEXS* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSEXS*>(base_class_ptr))
	{
		buffer >> element->te.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcSK.efdmax
bool assign_ExcSK_efdmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK*>(base_class_ptr))
	{
		buffer >> element->efdmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcSK.efdmin
bool assign_ExcSK_efdmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK*>(base_class_ptr))
	{
		buffer >> element->efdmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcSK.emax
bool assign_ExcSK_emax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK*>(base_class_ptr))
	{
		buffer >> element->emax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcSK.emin
bool assign_ExcSK_emin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK*>(base_class_ptr))
	{
		buffer >> element->emin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcSK.k
bool assign_ExcSK_k(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK*>(base_class_ptr))
	{
		buffer >> element->k.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcSK.k1
bool assign_ExcSK_k1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK*>(base_class_ptr))
	{
		buffer >> element->k1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcSK.k2
bool assign_ExcSK_k2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK*>(base_class_ptr))
	{
		buffer >> element->k2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcSK.kc
bool assign_ExcSK_kc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK*>(base_class_ptr))
	{
		buffer >> element->kc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcSK.kce
bool assign_ExcSK_kce(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK*>(base_class_ptr))
	{
		buffer >> element->kce.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcSK.kd
bool assign_ExcSK_kd(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK*>(base_class_ptr))
	{
		buffer >> element->kd.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcSK.kgob
bool assign_ExcSK_kgob(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK*>(base_class_ptr))
	{
		buffer >> element->kgob.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcSK.kp
bool assign_ExcSK_kp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK*>(base_class_ptr))
	{
		buffer >> element->kp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcSK.kqi
bool assign_ExcSK_kqi(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK*>(base_class_ptr))
	{
		buffer >> element->kqi.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcSK.kqob
bool assign_ExcSK_kqob(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK*>(base_class_ptr))
	{
		buffer >> element->kqob.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcSK.kqp
bool assign_ExcSK_kqp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK*>(base_class_ptr))
	{
		buffer >> element->kqp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcSK.nq
bool assign_ExcSK_nq(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK*>(base_class_ptr))
	{
		buffer >> element->nq.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcSK.qconoff
bool assign_ExcSK_qconoff(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK*>(base_class_ptr))
	{
		buffer >> element->qconoff;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcSK.qz
bool assign_ExcSK_qz(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK*>(base_class_ptr))
	{
		buffer >> element->qz.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcSK.remote
bool assign_ExcSK_remote(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK*>(base_class_ptr))
	{
		buffer >> element->remote;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcSK.sbase
bool assign_ExcSK_sbase(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK*>(base_class_ptr))
	{
		buffer >> element->sbase.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcSK.tc
bool assign_ExcSK_tc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK*>(base_class_ptr))
	{
		buffer >> element->tc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcSK.te
bool assign_ExcSK_te(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK*>(base_class_ptr))
	{
		buffer >> element->te.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcSK.ti
bool assign_ExcSK_ti(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK*>(base_class_ptr))
	{
		buffer >> element->ti.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcSK.tp
bool assign_ExcSK_tp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK*>(base_class_ptr))
	{
		buffer >> element->tp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcSK.tr
bool assign_ExcSK_tr(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK*>(base_class_ptr))
	{
		buffer >> element->tr.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcSK.uimax
bool assign_ExcSK_uimax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK*>(base_class_ptr))
	{
		buffer >> element->uimax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcSK.uimin
bool assign_ExcSK_uimin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK*>(base_class_ptr))
	{
		buffer >> element->uimin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcSK.urmax
bool assign_ExcSK_urmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK*>(base_class_ptr))
	{
		buffer >> element->urmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcSK.urmin
bool assign_ExcSK_urmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK*>(base_class_ptr))
	{
		buffer >> element->urmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcSK.vtmax
bool assign_ExcSK_vtmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK*>(base_class_ptr))
	{
		buffer >> element->vtmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcSK.vtmin
bool assign_ExcSK_vtmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK*>(base_class_ptr))
	{
		buffer >> element->vtmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcSK.yp
bool assign_ExcSK_yp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcSK*>(base_class_ptr))
	{
		buffer >> element->yp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST1A.ilr
bool assign_ExcST1A_ilr(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST1A*>(base_class_ptr))
	{
		buffer >> element->ilr.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST1A.ka
bool assign_ExcST1A_ka(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST1A*>(base_class_ptr))
	{
		buffer >> element->ka.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST1A.kc
bool assign_ExcST1A_kc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST1A*>(base_class_ptr))
	{
		buffer >> element->kc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST1A.kf
bool assign_ExcST1A_kf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST1A*>(base_class_ptr))
	{
		buffer >> element->kf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST1A.klr
bool assign_ExcST1A_klr(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST1A*>(base_class_ptr))
	{
		buffer >> element->klr.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST1A.ta
bool assign_ExcST1A_ta(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST1A*>(base_class_ptr))
	{
		buffer >> element->ta.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST1A.tb
bool assign_ExcST1A_tb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST1A*>(base_class_ptr))
	{
		buffer >> element->tb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST1A.tb1
bool assign_ExcST1A_tb1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST1A*>(base_class_ptr))
	{
		buffer >> element->tb1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST1A.tc
bool assign_ExcST1A_tc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST1A*>(base_class_ptr))
	{
		buffer >> element->tc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST1A.tc1
bool assign_ExcST1A_tc1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST1A*>(base_class_ptr))
	{
		buffer >> element->tc1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST1A.tf
bool assign_ExcST1A_tf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST1A*>(base_class_ptr))
	{
		buffer >> element->tf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST1A.vamax
bool assign_ExcST1A_vamax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST1A*>(base_class_ptr))
	{
		buffer >> element->vamax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST1A.vamin
bool assign_ExcST1A_vamin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST1A*>(base_class_ptr))
	{
		buffer >> element->vamin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST1A.vimax
bool assign_ExcST1A_vimax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST1A*>(base_class_ptr))
	{
		buffer >> element->vimax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST1A.vimin
bool assign_ExcST1A_vimin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST1A*>(base_class_ptr))
	{
		buffer >> element->vimin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST1A.vrmax
bool assign_ExcST1A_vrmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST1A*>(base_class_ptr))
	{
		buffer >> element->vrmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST1A.vrmin
bool assign_ExcST1A_vrmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST1A*>(base_class_ptr))
	{
		buffer >> element->vrmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST1A.xe
bool assign_ExcST1A_xe(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST1A*>(base_class_ptr))
	{
		buffer >> element->xe.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST2A.efdmax
bool assign_ExcST2A_efdmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST2A*>(base_class_ptr))
	{
		buffer >> element->efdmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST2A.ka
bool assign_ExcST2A_ka(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST2A*>(base_class_ptr))
	{
		buffer >> element->ka.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST2A.kc
bool assign_ExcST2A_kc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST2A*>(base_class_ptr))
	{
		buffer >> element->kc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST2A.ke
bool assign_ExcST2A_ke(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST2A*>(base_class_ptr))
	{
		buffer >> element->ke.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST2A.kf
bool assign_ExcST2A_kf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST2A*>(base_class_ptr))
	{
		buffer >> element->kf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST2A.ki
bool assign_ExcST2A_ki(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST2A*>(base_class_ptr))
	{
		buffer >> element->ki.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST2A.kp
bool assign_ExcST2A_kp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST2A*>(base_class_ptr))
	{
		buffer >> element->kp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST2A.ta
bool assign_ExcST2A_ta(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST2A*>(base_class_ptr))
	{
		buffer >> element->ta.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST2A.tb
bool assign_ExcST2A_tb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST2A*>(base_class_ptr))
	{
		buffer >> element->tb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST2A.tc
bool assign_ExcST2A_tc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST2A*>(base_class_ptr))
	{
		buffer >> element->tc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST2A.te
bool assign_ExcST2A_te(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST2A*>(base_class_ptr))
	{
		buffer >> element->te.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST2A.tf
bool assign_ExcST2A_tf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST2A*>(base_class_ptr))
	{
		buffer >> element->tf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST2A.uelin
bool assign_ExcST2A_uelin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST2A*>(base_class_ptr))
	{
		buffer >> element->uelin;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST2A.vrmax
bool assign_ExcST2A_vrmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST2A*>(base_class_ptr))
	{
		buffer >> element->vrmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST2A.vrmin
bool assign_ExcST2A_vrmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST2A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST2A*>(base_class_ptr))
	{
		buffer >> element->vrmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST3A.efdmax
bool assign_ExcST3A_efdmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST3A*>(base_class_ptr))
	{
		buffer >> element->efdmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST3A.kc
bool assign_ExcST3A_kc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST3A*>(base_class_ptr))
	{
		buffer >> element->kc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST3A.kg
bool assign_ExcST3A_kg(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST3A*>(base_class_ptr))
	{
		buffer >> element->kg.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST3A.ki
bool assign_ExcST3A_ki(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST3A*>(base_class_ptr))
	{
		buffer >> element->ki.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST3A.kj
bool assign_ExcST3A_kj(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST3A*>(base_class_ptr))
	{
		buffer >> element->kj.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST3A.km
bool assign_ExcST3A_km(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST3A*>(base_class_ptr))
	{
		buffer >> element->km.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST3A.kp
bool assign_ExcST3A_kp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST3A*>(base_class_ptr))
	{
		buffer >> element->kp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST3A.ks
bool assign_ExcST3A_ks(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST3A*>(base_class_ptr))
	{
		buffer >> element->ks.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST3A.ks1
bool assign_ExcST3A_ks1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST3A*>(base_class_ptr))
	{
		buffer >> element->ks1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST3A.tb
bool assign_ExcST3A_tb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST3A*>(base_class_ptr))
	{
		buffer >> element->tb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST3A.tc
bool assign_ExcST3A_tc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST3A*>(base_class_ptr))
	{
		buffer >> element->tc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST3A.thetap
bool assign_ExcST3A_thetap(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST3A*>(base_class_ptr))
	{
		buffer >> element->thetap.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST3A.tm
bool assign_ExcST3A_tm(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST3A*>(base_class_ptr))
	{
		buffer >> element->tm.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST3A.vbmax
bool assign_ExcST3A_vbmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST3A*>(base_class_ptr))
	{
		buffer >> element->vbmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST3A.vgmax
bool assign_ExcST3A_vgmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST3A*>(base_class_ptr))
	{
		buffer >> element->vgmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST3A.vimax
bool assign_ExcST3A_vimax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST3A*>(base_class_ptr))
	{
		buffer >> element->vimax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST3A.vimin
bool assign_ExcST3A_vimin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST3A*>(base_class_ptr))
	{
		buffer >> element->vimin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST3A.vrmax
bool assign_ExcST3A_vrmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST3A*>(base_class_ptr))
	{
		buffer >> element->vrmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST3A.vrmin
bool assign_ExcST3A_vrmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST3A*>(base_class_ptr))
	{
		buffer >> element->vrmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST3A.xl
bool assign_ExcST3A_xl(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST3A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST3A*>(base_class_ptr))
	{
		buffer >> element->xl.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST4B.kc
bool assign_ExcST4B_kc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST4B*>(base_class_ptr))
	{
		buffer >> element->kc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST4B.kg
bool assign_ExcST4B_kg(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST4B*>(base_class_ptr))
	{
		buffer >> element->kg.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST4B.ki
bool assign_ExcST4B_ki(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST4B*>(base_class_ptr))
	{
		buffer >> element->ki.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST4B.kim
bool assign_ExcST4B_kim(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST4B*>(base_class_ptr))
	{
		buffer >> element->kim.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST4B.kir
bool assign_ExcST4B_kir(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST4B*>(base_class_ptr))
	{
		buffer >> element->kir.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST4B.kp
bool assign_ExcST4B_kp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST4B*>(base_class_ptr))
	{
		buffer >> element->kp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST4B.kpm
bool assign_ExcST4B_kpm(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST4B*>(base_class_ptr))
	{
		buffer >> element->kpm.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST4B.kpr
bool assign_ExcST4B_kpr(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST4B*>(base_class_ptr))
	{
		buffer >> element->kpr.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST4B.lvgate
bool assign_ExcST4B_lvgate(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST4B*>(base_class_ptr))
	{
		buffer >> element->lvgate;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST4B.ta
bool assign_ExcST4B_ta(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST4B*>(base_class_ptr))
	{
		buffer >> element->ta.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST4B.thetap
bool assign_ExcST4B_thetap(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST4B*>(base_class_ptr))
	{
		buffer >> element->thetap.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST4B.uel
bool assign_ExcST4B_uel(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST4B*>(base_class_ptr))
	{
		buffer >> element->uel;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST4B.vbmax
bool assign_ExcST4B_vbmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST4B*>(base_class_ptr))
	{
		buffer >> element->vbmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST4B.vgmax
bool assign_ExcST4B_vgmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST4B*>(base_class_ptr))
	{
		buffer >> element->vgmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST4B.vmmax
bool assign_ExcST4B_vmmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST4B*>(base_class_ptr))
	{
		buffer >> element->vmmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST4B.vmmin
bool assign_ExcST4B_vmmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST4B*>(base_class_ptr))
	{
		buffer >> element->vmmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST4B.vrmax
bool assign_ExcST4B_vrmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST4B*>(base_class_ptr))
	{
		buffer >> element->vrmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST4B.vrmin
bool assign_ExcST4B_vrmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST4B*>(base_class_ptr))
	{
		buffer >> element->vrmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST4B.xl
bool assign_ExcST4B_xl(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST4B*>(base_class_ptr))
	{
		buffer >> element->xl.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST6B.ilr
bool assign_ExcST6B_ilr(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST6B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST6B*>(base_class_ptr))
	{
		buffer >> element->ilr.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST6B.k1
bool assign_ExcST6B_k1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST6B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST6B*>(base_class_ptr))
	{
		buffer >> element->k1;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST6B.kcl
bool assign_ExcST6B_kcl(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST6B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST6B*>(base_class_ptr))
	{
		buffer >> element->kcl.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST6B.kff
bool assign_ExcST6B_kff(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST6B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST6B*>(base_class_ptr))
	{
		buffer >> element->kff.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST6B.kg
bool assign_ExcST6B_kg(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST6B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST6B*>(base_class_ptr))
	{
		buffer >> element->kg.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST6B.kia
bool assign_ExcST6B_kia(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST6B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST6B*>(base_class_ptr))
	{
		buffer >> element->kia.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST6B.klr
bool assign_ExcST6B_klr(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST6B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST6B*>(base_class_ptr))
	{
		buffer >> element->klr.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST6B.km
bool assign_ExcST6B_km(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST6B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST6B*>(base_class_ptr))
	{
		buffer >> element->km.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST6B.kpa
bool assign_ExcST6B_kpa(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST6B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST6B*>(base_class_ptr))
	{
		buffer >> element->kpa.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST6B.kvd
bool assign_ExcST6B_kvd(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST6B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST6B*>(base_class_ptr))
	{
		buffer >> element->kvd.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST6B.oelin
bool assign_ExcST6B_oelin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST6B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST6B*>(base_class_ptr))
	{
		buffer >> element->oelin;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST6B.tg
bool assign_ExcST6B_tg(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST6B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST6B*>(base_class_ptr))
	{
		buffer >> element->tg.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST6B.ts
bool assign_ExcST6B_ts(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST6B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST6B*>(base_class_ptr))
	{
		buffer >> element->ts.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST6B.tvd
bool assign_ExcST6B_tvd(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST6B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST6B*>(base_class_ptr))
	{
		buffer >> element->tvd.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST6B.vamax
bool assign_ExcST6B_vamax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST6B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST6B*>(base_class_ptr))
	{
		buffer >> element->vamax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST6B.vamin
bool assign_ExcST6B_vamin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST6B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST6B*>(base_class_ptr))
	{
		buffer >> element->vamin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST6B.vilim
bool assign_ExcST6B_vilim(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST6B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST6B*>(base_class_ptr))
	{
		buffer >> element->vilim;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST6B.vimax
bool assign_ExcST6B_vimax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST6B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST6B*>(base_class_ptr))
	{
		buffer >> element->vimax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST6B.vimin
bool assign_ExcST6B_vimin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST6B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST6B*>(base_class_ptr))
	{
		buffer >> element->vimin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST6B.vmult
bool assign_ExcST6B_vmult(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST6B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST6B*>(base_class_ptr))
	{
		buffer >> element->vmult;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST6B.vrmax
bool assign_ExcST6B_vrmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST6B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST6B*>(base_class_ptr))
	{
		buffer >> element->vrmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST6B.vrmin
bool assign_ExcST6B_vrmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST6B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST6B*>(base_class_ptr))
	{
		buffer >> element->vrmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST6B.xc
bool assign_ExcST6B_xc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST6B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST6B*>(base_class_ptr))
	{
		buffer >> element->xc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST7B.kh
bool assign_ExcST7B_kh(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST7B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST7B*>(base_class_ptr))
	{
		buffer >> element->kh.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST7B.kia
bool assign_ExcST7B_kia(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST7B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST7B*>(base_class_ptr))
	{
		buffer >> element->kia.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST7B.kl
bool assign_ExcST7B_kl(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST7B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST7B*>(base_class_ptr))
	{
		buffer >> element->kl.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST7B.kpa
bool assign_ExcST7B_kpa(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST7B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST7B*>(base_class_ptr))
	{
		buffer >> element->kpa.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST7B.oelin
bool assign_ExcST7B_oelin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST7B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST7B*>(base_class_ptr))
	{
		buffer >> element->oelin;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST7B.tb
bool assign_ExcST7B_tb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST7B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST7B*>(base_class_ptr))
	{
		buffer >> element->tb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST7B.tc
bool assign_ExcST7B_tc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST7B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST7B*>(base_class_ptr))
	{
		buffer >> element->tc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST7B.tf
bool assign_ExcST7B_tf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST7B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST7B*>(base_class_ptr))
	{
		buffer >> element->tf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST7B.tg
bool assign_ExcST7B_tg(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST7B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST7B*>(base_class_ptr))
	{
		buffer >> element->tg.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST7B.tia
bool assign_ExcST7B_tia(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST7B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST7B*>(base_class_ptr))
	{
		buffer >> element->tia.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST7B.ts
bool assign_ExcST7B_ts(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST7B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST7B*>(base_class_ptr))
	{
		buffer >> element->ts.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST7B.uelin
bool assign_ExcST7B_uelin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST7B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST7B*>(base_class_ptr))
	{
		buffer >> element->uelin;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST7B.vmax
bool assign_ExcST7B_vmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST7B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST7B*>(base_class_ptr))
	{
		buffer >> element->vmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST7B.vmin
bool assign_ExcST7B_vmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST7B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST7B*>(base_class_ptr))
	{
		buffer >> element->vmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST7B.vrmax
bool assign_ExcST7B_vrmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST7B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST7B*>(base_class_ptr))
	{
		buffer >> element->vrmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcST7B.vrmin
bool assign_ExcST7B_vrmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST7B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::ExcitationSystemDynamics::ExcST7B*>(base_class_ptr))
	{
		buffer >> element->vrmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadComposite.epfd
bool assign_LoadComposite_epfd(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::LoadDynamics::LoadComposite* element = dynamic_cast<IEC61970::Dynamics::StandardModels::LoadDynamics::LoadComposite*>(base_class_ptr))
	{
		buffer >> element->epfd;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadComposite.epfs
bool assign_LoadComposite_epfs(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::LoadDynamics::LoadComposite* element = dynamic_cast<IEC61970::Dynamics::StandardModels::LoadDynamics::LoadComposite*>(base_class_ptr))
	{
		buffer >> element->epfs;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadComposite.epvd
bool assign_LoadComposite_epvd(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::LoadDynamics::LoadComposite* element = dynamic_cast<IEC61970::Dynamics::StandardModels::LoadDynamics::LoadComposite*>(base_class_ptr))
	{
		buffer >> element->epvd;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadComposite.epvs
bool assign_LoadComposite_epvs(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::LoadDynamics::LoadComposite* element = dynamic_cast<IEC61970::Dynamics::StandardModels::LoadDynamics::LoadComposite*>(base_class_ptr))
	{
		buffer >> element->epvs;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadComposite.eqfd
bool assign_LoadComposite_eqfd(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::LoadDynamics::LoadComposite* element = dynamic_cast<IEC61970::Dynamics::StandardModels::LoadDynamics::LoadComposite*>(base_class_ptr))
	{
		buffer >> element->eqfd;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadComposite.eqfs
bool assign_LoadComposite_eqfs(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::LoadDynamics::LoadComposite* element = dynamic_cast<IEC61970::Dynamics::StandardModels::LoadDynamics::LoadComposite*>(base_class_ptr))
	{
		buffer >> element->eqfs;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadComposite.eqvd
bool assign_LoadComposite_eqvd(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::LoadDynamics::LoadComposite* element = dynamic_cast<IEC61970::Dynamics::StandardModels::LoadDynamics::LoadComposite*>(base_class_ptr))
	{
		buffer >> element->eqvd;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadComposite.eqvs
bool assign_LoadComposite_eqvs(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::LoadDynamics::LoadComposite* element = dynamic_cast<IEC61970::Dynamics::StandardModels::LoadDynamics::LoadComposite*>(base_class_ptr))
	{
		buffer >> element->eqvs;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadComposite.h
bool assign_LoadComposite_h(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::LoadDynamics::LoadComposite* element = dynamic_cast<IEC61970::Dynamics::StandardModels::LoadDynamics::LoadComposite*>(base_class_ptr))
	{
		buffer >> element->h.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadComposite.lfrac
bool assign_LoadComposite_lfrac(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::LoadDynamics::LoadComposite* element = dynamic_cast<IEC61970::Dynamics::StandardModels::LoadDynamics::LoadComposite*>(base_class_ptr))
	{
		buffer >> element->lfrac;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadComposite.pfrac
bool assign_LoadComposite_pfrac(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::LoadDynamics::LoadComposite* element = dynamic_cast<IEC61970::Dynamics::StandardModels::LoadDynamics::LoadComposite*>(base_class_ptr))
	{
		buffer >> element->pfrac;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadGenericNonLinear.bs
bool assign_LoadGenericNonLinear_bs(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::LoadDynamics::LoadGenericNonLinear* element = dynamic_cast<IEC61970::Dynamics::StandardModels::LoadDynamics::LoadGenericNonLinear*>(base_class_ptr))
	{
		buffer >> element->bs;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadGenericNonLinear.bt
bool assign_LoadGenericNonLinear_bt(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::LoadDynamics::LoadGenericNonLinear* element = dynamic_cast<IEC61970::Dynamics::StandardModels::LoadDynamics::LoadGenericNonLinear*>(base_class_ptr))
	{
		buffer >> element->bt;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadGenericNonLinear.genericNonLinearLoadModelType
bool assign_LoadGenericNonLinear_genericNonLinearLoadModelType(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::LoadDynamics::LoadGenericNonLinear* element = dynamic_cast<IEC61970::Dynamics::StandardModels::LoadDynamics::LoadGenericNonLinear*>(base_class_ptr))
	{
		buffer >> element->genericNonLinearLoadModelType;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadGenericNonLinear.ls
bool assign_LoadGenericNonLinear_ls(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::LoadDynamics::LoadGenericNonLinear* element = dynamic_cast<IEC61970::Dynamics::StandardModels::LoadDynamics::LoadGenericNonLinear*>(base_class_ptr))
	{
		buffer >> element->ls;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadGenericNonLinear.lt
bool assign_LoadGenericNonLinear_lt(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::LoadDynamics::LoadGenericNonLinear* element = dynamic_cast<IEC61970::Dynamics::StandardModels::LoadDynamics::LoadGenericNonLinear*>(base_class_ptr))
	{
		buffer >> element->lt;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadGenericNonLinear.pt
bool assign_LoadGenericNonLinear_pt(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::LoadDynamics::LoadGenericNonLinear* element = dynamic_cast<IEC61970::Dynamics::StandardModels::LoadDynamics::LoadGenericNonLinear*>(base_class_ptr))
	{
		buffer >> element->pt;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadGenericNonLinear.qt
bool assign_LoadGenericNonLinear_qt(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::LoadDynamics::LoadGenericNonLinear* element = dynamic_cast<IEC61970::Dynamics::StandardModels::LoadDynamics::LoadGenericNonLinear*>(base_class_ptr))
	{
		buffer >> element->qt;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadGenericNonLinear.tp
bool assign_LoadGenericNonLinear_tp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::LoadDynamics::LoadGenericNonLinear* element = dynamic_cast<IEC61970::Dynamics::StandardModels::LoadDynamics::LoadGenericNonLinear*>(base_class_ptr))
	{
		buffer >> element->tp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadGenericNonLinear.tq
bool assign_LoadGenericNonLinear_tq(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::LoadDynamics::LoadGenericNonLinear* element = dynamic_cast<IEC61970::Dynamics::StandardModels::LoadDynamics::LoadGenericNonLinear*>(base_class_ptr))
	{
		buffer >> element->tq.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadMotor.d
bool assign_LoadMotor_d(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::LoadDynamics::LoadMotor* element = dynamic_cast<IEC61970::Dynamics::StandardModels::LoadDynamics::LoadMotor*>(base_class_ptr))
	{
		buffer >> element->d;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadMotor.h
bool assign_LoadMotor_h(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::LoadDynamics::LoadMotor* element = dynamic_cast<IEC61970::Dynamics::StandardModels::LoadDynamics::LoadMotor*>(base_class_ptr))
	{
		buffer >> element->h.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadMotor.lfac
bool assign_LoadMotor_lfac(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::LoadDynamics::LoadMotor* element = dynamic_cast<IEC61970::Dynamics::StandardModels::LoadDynamics::LoadMotor*>(base_class_ptr))
	{
		buffer >> element->lfac;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadMotor.lp
bool assign_LoadMotor_lp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::LoadDynamics::LoadMotor* element = dynamic_cast<IEC61970::Dynamics::StandardModels::LoadDynamics::LoadMotor*>(base_class_ptr))
	{
		buffer >> element->lp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadMotor.lpp
bool assign_LoadMotor_lpp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::LoadDynamics::LoadMotor* element = dynamic_cast<IEC61970::Dynamics::StandardModels::LoadDynamics::LoadMotor*>(base_class_ptr))
	{
		buffer >> element->lpp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadMotor.ls
bool assign_LoadMotor_ls(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::LoadDynamics::LoadMotor* element = dynamic_cast<IEC61970::Dynamics::StandardModels::LoadDynamics::LoadMotor*>(base_class_ptr))
	{
		buffer >> element->ls.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadMotor.pfrac
bool assign_LoadMotor_pfrac(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::LoadDynamics::LoadMotor* element = dynamic_cast<IEC61970::Dynamics::StandardModels::LoadDynamics::LoadMotor*>(base_class_ptr))
	{
		buffer >> element->pfrac;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadMotor.ra
bool assign_LoadMotor_ra(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::LoadDynamics::LoadMotor* element = dynamic_cast<IEC61970::Dynamics::StandardModels::LoadDynamics::LoadMotor*>(base_class_ptr))
	{
		buffer >> element->ra.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadMotor.tbkr
bool assign_LoadMotor_tbkr(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::LoadDynamics::LoadMotor* element = dynamic_cast<IEC61970::Dynamics::StandardModels::LoadDynamics::LoadMotor*>(base_class_ptr))
	{
		buffer >> element->tbkr.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadMotor.tpo
bool assign_LoadMotor_tpo(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::LoadDynamics::LoadMotor* element = dynamic_cast<IEC61970::Dynamics::StandardModels::LoadDynamics::LoadMotor*>(base_class_ptr))
	{
		buffer >> element->tpo.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadMotor.tppo
bool assign_LoadMotor_tppo(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::LoadDynamics::LoadMotor* element = dynamic_cast<IEC61970::Dynamics::StandardModels::LoadDynamics::LoadMotor*>(base_class_ptr))
	{
		buffer >> element->tppo.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadMotor.tv
bool assign_LoadMotor_tv(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::LoadDynamics::LoadMotor* element = dynamic_cast<IEC61970::Dynamics::StandardModels::LoadDynamics::LoadMotor*>(base_class_ptr))
	{
		buffer >> element->tv.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadMotor.vt
bool assign_LoadMotor_vt(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::LoadDynamics::LoadMotor* element = dynamic_cast<IEC61970::Dynamics::StandardModels::LoadDynamics::LoadMotor*>(base_class_ptr))
	{
		buffer >> element->vt.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadStatic.ep1
bool assign_LoadStatic_ep1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::LoadDynamics::LoadStatic* element = dynamic_cast<IEC61970::Dynamics::StandardModels::LoadDynamics::LoadStatic*>(base_class_ptr))
	{
		buffer >> element->ep1;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadStatic.ep2
bool assign_LoadStatic_ep2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::LoadDynamics::LoadStatic* element = dynamic_cast<IEC61970::Dynamics::StandardModels::LoadDynamics::LoadStatic*>(base_class_ptr))
	{
		buffer >> element->ep2;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadStatic.ep3
bool assign_LoadStatic_ep3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::LoadDynamics::LoadStatic* element = dynamic_cast<IEC61970::Dynamics::StandardModels::LoadDynamics::LoadStatic*>(base_class_ptr))
	{
		buffer >> element->ep3;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadStatic.eq1
bool assign_LoadStatic_eq1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::LoadDynamics::LoadStatic* element = dynamic_cast<IEC61970::Dynamics::StandardModels::LoadDynamics::LoadStatic*>(base_class_ptr))
	{
		buffer >> element->eq1;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadStatic.eq2
bool assign_LoadStatic_eq2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::LoadDynamics::LoadStatic* element = dynamic_cast<IEC61970::Dynamics::StandardModels::LoadDynamics::LoadStatic*>(base_class_ptr))
	{
		buffer >> element->eq2;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadStatic.eq3
bool assign_LoadStatic_eq3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::LoadDynamics::LoadStatic* element = dynamic_cast<IEC61970::Dynamics::StandardModels::LoadDynamics::LoadStatic*>(base_class_ptr))
	{
		buffer >> element->eq3;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadStatic.kp1
bool assign_LoadStatic_kp1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::LoadDynamics::LoadStatic* element = dynamic_cast<IEC61970::Dynamics::StandardModels::LoadDynamics::LoadStatic*>(base_class_ptr))
	{
		buffer >> element->kp1;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadStatic.kp2
bool assign_LoadStatic_kp2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::LoadDynamics::LoadStatic* element = dynamic_cast<IEC61970::Dynamics::StandardModels::LoadDynamics::LoadStatic*>(base_class_ptr))
	{
		buffer >> element->kp2;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadStatic.kp3
bool assign_LoadStatic_kp3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::LoadDynamics::LoadStatic* element = dynamic_cast<IEC61970::Dynamics::StandardModels::LoadDynamics::LoadStatic*>(base_class_ptr))
	{
		buffer >> element->kp3;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadStatic.kp4
bool assign_LoadStatic_kp4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::LoadDynamics::LoadStatic* element = dynamic_cast<IEC61970::Dynamics::StandardModels::LoadDynamics::LoadStatic*>(base_class_ptr))
	{
		buffer >> element->kp4;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadStatic.kpf
bool assign_LoadStatic_kpf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::LoadDynamics::LoadStatic* element = dynamic_cast<IEC61970::Dynamics::StandardModels::LoadDynamics::LoadStatic*>(base_class_ptr))
	{
		buffer >> element->kpf;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadStatic.kq1
bool assign_LoadStatic_kq1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::LoadDynamics::LoadStatic* element = dynamic_cast<IEC61970::Dynamics::StandardModels::LoadDynamics::LoadStatic*>(base_class_ptr))
	{
		buffer >> element->kq1;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadStatic.kq2
bool assign_LoadStatic_kq2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::LoadDynamics::LoadStatic* element = dynamic_cast<IEC61970::Dynamics::StandardModels::LoadDynamics::LoadStatic*>(base_class_ptr))
	{
		buffer >> element->kq2;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadStatic.kq3
bool assign_LoadStatic_kq3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::LoadDynamics::LoadStatic* element = dynamic_cast<IEC61970::Dynamics::StandardModels::LoadDynamics::LoadStatic*>(base_class_ptr))
	{
		buffer >> element->kq3;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadStatic.kq4
bool assign_LoadStatic_kq4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::LoadDynamics::LoadStatic* element = dynamic_cast<IEC61970::Dynamics::StandardModels::LoadDynamics::LoadStatic*>(base_class_ptr))
	{
		buffer >> element->kq4;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadStatic.kqf
bool assign_LoadStatic_kqf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::LoadDynamics::LoadStatic* element = dynamic_cast<IEC61970::Dynamics::StandardModels::LoadDynamics::LoadStatic*>(base_class_ptr))
	{
		buffer >> element->kqf;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadStatic.staticLoadModelType
bool assign_LoadStatic_staticLoadModelType(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::LoadDynamics::LoadStatic* element = dynamic_cast<IEC61970::Dynamics::StandardModels::LoadDynamics::LoadStatic*>(base_class_ptr))
	{
		buffer >> element->staticLoadModelType;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:MechLoad1.a
bool assign_MechLoad1_a(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::MechanicalLoadDynamics::MechLoad1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::MechanicalLoadDynamics::MechLoad1*>(base_class_ptr))
	{
		buffer >> element->a;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:MechLoad1.b
bool assign_MechLoad1_b(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::MechanicalLoadDynamics::MechLoad1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::MechanicalLoadDynamics::MechLoad1*>(base_class_ptr))
	{
		buffer >> element->b;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:MechLoad1.d
bool assign_MechLoad1_d(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::MechanicalLoadDynamics::MechLoad1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::MechanicalLoadDynamics::MechLoad1*>(base_class_ptr))
	{
		buffer >> element->d;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:MechLoad1.e
bool assign_MechLoad1_e(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::MechanicalLoadDynamics::MechLoad1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::MechanicalLoadDynamics::MechLoad1*>(base_class_ptr))
	{
		buffer >> element->e;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:OverexcLim2.ifdlim
bool assign_OverexcLim2_ifdlim(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLim2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLim2*>(base_class_ptr))
	{
		buffer >> element->ifdlim.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:OverexcLim2.koi
bool assign_OverexcLim2_koi(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLim2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLim2*>(base_class_ptr))
	{
		buffer >> element->koi.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:OverexcLim2.voimax
bool assign_OverexcLim2_voimax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLim2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLim2*>(base_class_ptr))
	{
		buffer >> element->voimax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:OverexcLim2.voimin
bool assign_OverexcLim2_voimin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLim2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLim2*>(base_class_ptr))
	{
		buffer >> element->voimin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:OverexcLimIEEE.hyst
bool assign_OverexcLimIEEE_hyst(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLimIEEE* element = dynamic_cast<IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLimIEEE*>(base_class_ptr))
	{
		buffer >> element->hyst.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:OverexcLimIEEE.ifdlim
bool assign_OverexcLimIEEE_ifdlim(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLimIEEE* element = dynamic_cast<IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLimIEEE*>(base_class_ptr))
	{
		buffer >> element->ifdlim.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:OverexcLimIEEE.ifdmax
bool assign_OverexcLimIEEE_ifdmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLimIEEE* element = dynamic_cast<IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLimIEEE*>(base_class_ptr))
	{
		buffer >> element->ifdmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:OverexcLimIEEE.itfpu
bool assign_OverexcLimIEEE_itfpu(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLimIEEE* element = dynamic_cast<IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLimIEEE*>(base_class_ptr))
	{
		buffer >> element->itfpu.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:OverexcLimIEEE.kcd
bool assign_OverexcLimIEEE_kcd(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLimIEEE* element = dynamic_cast<IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLimIEEE*>(base_class_ptr))
	{
		buffer >> element->kcd.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:OverexcLimIEEE.kramp
bool assign_OverexcLimIEEE_kramp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLimIEEE* element = dynamic_cast<IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLimIEEE*>(base_class_ptr))
	{
		buffer >> element->kramp;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:OverexcLimX1.efd1
bool assign_OverexcLimX1_efd1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLimX1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLimX1*>(base_class_ptr))
	{
		buffer >> element->efd1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:OverexcLimX1.efd2
bool assign_OverexcLimX1_efd2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLimX1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLimX1*>(base_class_ptr))
	{
		buffer >> element->efd2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:OverexcLimX1.efd3
bool assign_OverexcLimX1_efd3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLimX1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLimX1*>(base_class_ptr))
	{
		buffer >> element->efd3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:OverexcLimX1.efddes
bool assign_OverexcLimX1_efddes(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLimX1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLimX1*>(base_class_ptr))
	{
		buffer >> element->efddes.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:OverexcLimX1.efdrated
bool assign_OverexcLimX1_efdrated(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLimX1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLimX1*>(base_class_ptr))
	{
		buffer >> element->efdrated.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:OverexcLimX1.kmx
bool assign_OverexcLimX1_kmx(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLimX1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLimX1*>(base_class_ptr))
	{
		buffer >> element->kmx.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:OverexcLimX1.t1
bool assign_OverexcLimX1_t1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLimX1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLimX1*>(base_class_ptr))
	{
		buffer >> element->t1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:OverexcLimX1.t2
bool assign_OverexcLimX1_t2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLimX1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLimX1*>(base_class_ptr))
	{
		buffer >> element->t2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:OverexcLimX1.t3
bool assign_OverexcLimX1_t3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLimX1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLimX1*>(base_class_ptr))
	{
		buffer >> element->t3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:OverexcLimX1.vlow
bool assign_OverexcLimX1_vlow(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLimX1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLimX1*>(base_class_ptr))
	{
		buffer >> element->vlow.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:OverexcLimX2.efd1
bool assign_OverexcLimX2_efd1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLimX2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLimX2*>(base_class_ptr))
	{
		buffer >> element->efd1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:OverexcLimX2.efd2
bool assign_OverexcLimX2_efd2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLimX2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLimX2*>(base_class_ptr))
	{
		buffer >> element->efd2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:OverexcLimX2.efd3
bool assign_OverexcLimX2_efd3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLimX2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLimX2*>(base_class_ptr))
	{
		buffer >> element->efd3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:OverexcLimX2.efddes
bool assign_OverexcLimX2_efddes(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLimX2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLimX2*>(base_class_ptr))
	{
		buffer >> element->efddes.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:OverexcLimX2.efdrated
bool assign_OverexcLimX2_efdrated(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLimX2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLimX2*>(base_class_ptr))
	{
		buffer >> element->efdrated.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:OverexcLimX2.kmx
bool assign_OverexcLimX2_kmx(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLimX2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLimX2*>(base_class_ptr))
	{
		buffer >> element->kmx.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:OverexcLimX2.m
bool assign_OverexcLimX2_m(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLimX2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLimX2*>(base_class_ptr))
	{
		buffer >> element->m;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:OverexcLimX2.t1
bool assign_OverexcLimX2_t1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLimX2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLimX2*>(base_class_ptr))
	{
		buffer >> element->t1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:OverexcLimX2.t2
bool assign_OverexcLimX2_t2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLimX2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLimX2*>(base_class_ptr))
	{
		buffer >> element->t2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:OverexcLimX2.t3
bool assign_OverexcLimX2_t3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLimX2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLimX2*>(base_class_ptr))
	{
		buffer >> element->t3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:OverexcLimX2.vlow
bool assign_OverexcLimX2_vlow(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLimX2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::OverexcitationLimiterDynamics::OverexcLimX2*>(base_class_ptr))
	{
		buffer >> element->vlow.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PFVArType1IEEEPFController.ovex
bool assign_PFVArType1IEEEPFController_ovex(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PFVArControllerType1Dynamics::PFVArType1IEEEPFController* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PFVArControllerType1Dynamics::PFVArType1IEEEPFController*>(base_class_ptr))
	{
		buffer >> element->ovex;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PFVArType1IEEEPFController.tpfc
bool assign_PFVArType1IEEEPFController_tpfc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PFVArControllerType1Dynamics::PFVArType1IEEEPFController* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PFVArControllerType1Dynamics::PFVArType1IEEEPFController*>(base_class_ptr))
	{
		buffer >> element->tpfc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PFVArType1IEEEPFController.vitmin
bool assign_PFVArType1IEEEPFController_vitmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PFVArControllerType1Dynamics::PFVArType1IEEEPFController* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PFVArControllerType1Dynamics::PFVArType1IEEEPFController*>(base_class_ptr))
	{
		buffer >> element->vitmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PFVArType1IEEEPFController.vpf
bool assign_PFVArType1IEEEPFController_vpf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PFVArControllerType1Dynamics::PFVArType1IEEEPFController* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PFVArControllerType1Dynamics::PFVArType1IEEEPFController*>(base_class_ptr))
	{
		buffer >> element->vpf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PFVArType1IEEEPFController.vpfcbw
bool assign_PFVArType1IEEEPFController_vpfcbw(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PFVArControllerType1Dynamics::PFVArType1IEEEPFController* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PFVArControllerType1Dynamics::PFVArType1IEEEPFController*>(base_class_ptr))
	{
		buffer >> element->vpfcbw;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PFVArType1IEEEPFController.vpfref
bool assign_PFVArType1IEEEPFController_vpfref(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PFVArControllerType1Dynamics::PFVArType1IEEEPFController* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PFVArControllerType1Dynamics::PFVArType1IEEEPFController*>(base_class_ptr))
	{
		buffer >> element->vpfref.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PFVArType1IEEEPFController.vvtmax
bool assign_PFVArType1IEEEPFController_vvtmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PFVArControllerType1Dynamics::PFVArType1IEEEPFController* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PFVArControllerType1Dynamics::PFVArType1IEEEPFController*>(base_class_ptr))
	{
		buffer >> element->vvtmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PFVArType1IEEEPFController.vvtmin
bool assign_PFVArType1IEEEPFController_vvtmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PFVArControllerType1Dynamics::PFVArType1IEEEPFController* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PFVArControllerType1Dynamics::PFVArType1IEEEPFController*>(base_class_ptr))
	{
		buffer >> element->vvtmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PFVArType1IEEEVArController.tvarc
bool assign_PFVArType1IEEEVArController_tvarc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PFVArControllerType1Dynamics::PFVArType1IEEEVArController* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PFVArControllerType1Dynamics::PFVArType1IEEEVArController*>(base_class_ptr))
	{
		buffer >> element->tvarc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PFVArType1IEEEVArController.vvar
bool assign_PFVArType1IEEEVArController_vvar(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PFVArControllerType1Dynamics::PFVArType1IEEEVArController* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PFVArControllerType1Dynamics::PFVArType1IEEEVArController*>(base_class_ptr))
	{
		buffer >> element->vvar.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PFVArType1IEEEVArController.vvarcbw
bool assign_PFVArType1IEEEVArController_vvarcbw(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PFVArControllerType1Dynamics::PFVArType1IEEEVArController* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PFVArControllerType1Dynamics::PFVArType1IEEEVArController*>(base_class_ptr))
	{
		buffer >> element->vvarcbw;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PFVArType1IEEEVArController.vvarref
bool assign_PFVArType1IEEEVArController_vvarref(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PFVArControllerType1Dynamics::PFVArType1IEEEVArController* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PFVArControllerType1Dynamics::PFVArType1IEEEVArController*>(base_class_ptr))
	{
		buffer >> element->vvarref.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PFVArType1IEEEVArController.vvtmax
bool assign_PFVArType1IEEEVArController_vvtmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PFVArControllerType1Dynamics::PFVArType1IEEEVArController* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PFVArControllerType1Dynamics::PFVArType1IEEEVArController*>(base_class_ptr))
	{
		buffer >> element->vvtmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PFVArType1IEEEVArController.vvtmin
bool assign_PFVArType1IEEEVArController_vvtmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PFVArControllerType1Dynamics::PFVArType1IEEEVArController* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PFVArControllerType1Dynamics::PFVArType1IEEEVArController*>(base_class_ptr))
	{
		buffer >> element->vvtmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PFVArType2Common1.j
bool assign_PFVArType2Common1_j(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PFVArControllerType2Dynamics::PFVArType2Common1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PFVArControllerType2Dynamics::PFVArType2Common1*>(base_class_ptr))
	{
		buffer >> element->j;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PFVArType2Common1.ki
bool assign_PFVArType2Common1_ki(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PFVArControllerType2Dynamics::PFVArType2Common1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PFVArControllerType2Dynamics::PFVArType2Common1*>(base_class_ptr))
	{
		buffer >> element->ki.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PFVArType2Common1.kp
bool assign_PFVArType2Common1_kp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PFVArControllerType2Dynamics::PFVArType2Common1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PFVArControllerType2Dynamics::PFVArType2Common1*>(base_class_ptr))
	{
		buffer >> element->kp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PFVArType2Common1.max
bool assign_PFVArType2Common1_max(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PFVArControllerType2Dynamics::PFVArType2Common1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PFVArControllerType2Dynamics::PFVArType2Common1*>(base_class_ptr))
	{
		buffer >> element->max.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PFVArType2Common1.ref
bool assign_PFVArType2Common1_ref(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PFVArControllerType2Dynamics::PFVArType2Common1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PFVArControllerType2Dynamics::PFVArType2Common1*>(base_class_ptr))
	{
		buffer >> element->ref.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PFVArType2IEEEPFController.exlon
bool assign_PFVArType2IEEEPFController_exlon(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PFVArControllerType2Dynamics::PFVArType2IEEEPFController* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PFVArControllerType2Dynamics::PFVArType2IEEEPFController*>(base_class_ptr))
	{
		buffer >> element->exlon;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PFVArType2IEEEPFController.ki
bool assign_PFVArType2IEEEPFController_ki(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PFVArControllerType2Dynamics::PFVArType2IEEEPFController* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PFVArControllerType2Dynamics::PFVArType2IEEEPFController*>(base_class_ptr))
	{
		buffer >> element->ki.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PFVArType2IEEEPFController.kp
bool assign_PFVArType2IEEEPFController_kp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PFVArControllerType2Dynamics::PFVArType2IEEEPFController* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PFVArControllerType2Dynamics::PFVArType2IEEEPFController*>(base_class_ptr))
	{
		buffer >> element->kp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PFVArType2IEEEPFController.pfref
bool assign_PFVArType2IEEEPFController_pfref(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PFVArControllerType2Dynamics::PFVArType2IEEEPFController* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PFVArControllerType2Dynamics::PFVArType2IEEEPFController*>(base_class_ptr))
	{
		buffer >> element->pfref.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PFVArType2IEEEPFController.vclmt
bool assign_PFVArType2IEEEPFController_vclmt(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PFVArControllerType2Dynamics::PFVArType2IEEEPFController* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PFVArControllerType2Dynamics::PFVArType2IEEEPFController*>(base_class_ptr))
	{
		buffer >> element->vclmt.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PFVArType2IEEEPFController.vref
bool assign_PFVArType2IEEEPFController_vref(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PFVArControllerType2Dynamics::PFVArType2IEEEPFController* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PFVArControllerType2Dynamics::PFVArType2IEEEPFController*>(base_class_ptr))
	{
		buffer >> element->vref.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PFVArType2IEEEPFController.vs
bool assign_PFVArType2IEEEPFController_vs(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PFVArControllerType2Dynamics::PFVArType2IEEEPFController* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PFVArControllerType2Dynamics::PFVArType2IEEEPFController*>(base_class_ptr))
	{
		buffer >> element->vs;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PFVArType2IEEEVArController.exlon
bool assign_PFVArType2IEEEVArController_exlon(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PFVArControllerType2Dynamics::PFVArType2IEEEVArController* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PFVArControllerType2Dynamics::PFVArType2IEEEVArController*>(base_class_ptr))
	{
		buffer >> element->exlon;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PFVArType2IEEEVArController.ki
bool assign_PFVArType2IEEEVArController_ki(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PFVArControllerType2Dynamics::PFVArType2IEEEVArController* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PFVArControllerType2Dynamics::PFVArType2IEEEVArController*>(base_class_ptr))
	{
		buffer >> element->ki.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PFVArType2IEEEVArController.kp
bool assign_PFVArType2IEEEVArController_kp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PFVArControllerType2Dynamics::PFVArType2IEEEVArController* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PFVArControllerType2Dynamics::PFVArType2IEEEVArController*>(base_class_ptr))
	{
		buffer >> element->kp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PFVArType2IEEEVArController.qref
bool assign_PFVArType2IEEEVArController_qref(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PFVArControllerType2Dynamics::PFVArType2IEEEVArController* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PFVArControllerType2Dynamics::PFVArType2IEEEVArController*>(base_class_ptr))
	{
		buffer >> element->qref.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PFVArType2IEEEVArController.vclmt
bool assign_PFVArType2IEEEVArController_vclmt(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PFVArControllerType2Dynamics::PFVArType2IEEEVArController* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PFVArControllerType2Dynamics::PFVArType2IEEEVArController*>(base_class_ptr))
	{
		buffer >> element->vclmt.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PFVArType2IEEEVArController.vref
bool assign_PFVArType2IEEEVArController_vref(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PFVArControllerType2Dynamics::PFVArType2IEEEVArController* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PFVArControllerType2Dynamics::PFVArType2IEEEVArController*>(base_class_ptr))
	{
		buffer >> element->vref.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PFVArType2IEEEVArController.vs
bool assign_PFVArType2IEEEVArController_vs(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PFVArControllerType2Dynamics::PFVArType2IEEEVArController* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PFVArControllerType2Dynamics::PFVArType2IEEEVArController*>(base_class_ptr))
	{
		buffer >> element->vs;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss1.kf
bool assign_Pss1_kf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1*>(base_class_ptr))
	{
		buffer >> element->kf;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss1.kpe
bool assign_Pss1_kpe(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1*>(base_class_ptr))
	{
		buffer >> element->kpe;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss1.ks
bool assign_Pss1_ks(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1*>(base_class_ptr))
	{
		buffer >> element->ks;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss1.kw
bool assign_Pss1_kw(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1*>(base_class_ptr))
	{
		buffer >> element->kw;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss1.pmin
bool assign_Pss1_pmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1*>(base_class_ptr))
	{
		buffer >> element->pmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss1.t10
bool assign_Pss1_t10(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1*>(base_class_ptr))
	{
		buffer >> element->t10.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss1.t5
bool assign_Pss1_t5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1*>(base_class_ptr))
	{
		buffer >> element->t5.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss1.t6
bool assign_Pss1_t6(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1*>(base_class_ptr))
	{
		buffer >> element->t6.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss1.t7
bool assign_Pss1_t7(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1*>(base_class_ptr))
	{
		buffer >> element->t7.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss1.t8
bool assign_Pss1_t8(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1*>(base_class_ptr))
	{
		buffer >> element->t8.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss1.t9
bool assign_Pss1_t9(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1*>(base_class_ptr))
	{
		buffer >> element->t9.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss1.tpe
bool assign_Pss1_tpe(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1*>(base_class_ptr))
	{
		buffer >> element->tpe.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss1.vadat
bool assign_Pss1_vadat(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1*>(base_class_ptr))
	{
		buffer >> element->vadat;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss1.vsmn
bool assign_Pss1_vsmn(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1*>(base_class_ptr))
	{
		buffer >> element->vsmn.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss1.vsmx
bool assign_Pss1_vsmx(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1*>(base_class_ptr))
	{
		buffer >> element->vsmx.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss1A.a1
bool assign_Pss1A_a1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1A*>(base_class_ptr))
	{
		buffer >> element->a1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss1A.a2
bool assign_Pss1A_a2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1A*>(base_class_ptr))
	{
		buffer >> element->a2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss1A.a3
bool assign_Pss1A_a3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1A*>(base_class_ptr))
	{
		buffer >> element->a3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss1A.a4
bool assign_Pss1A_a4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1A*>(base_class_ptr))
	{
		buffer >> element->a4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss1A.a5
bool assign_Pss1A_a5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1A*>(base_class_ptr))
	{
		buffer >> element->a5.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss1A.a6
bool assign_Pss1A_a6(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1A*>(base_class_ptr))
	{
		buffer >> element->a6.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss1A.a7
bool assign_Pss1A_a7(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1A*>(base_class_ptr))
	{
		buffer >> element->a7.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss1A.a8
bool assign_Pss1A_a8(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1A*>(base_class_ptr))
	{
		buffer >> element->a8.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss1A.inputSignalType
bool assign_Pss1A_inputSignalType(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1A*>(base_class_ptr))
	{
		buffer >> element->inputSignalType;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss1A.kd
bool assign_Pss1A_kd(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1A*>(base_class_ptr))
	{
		buffer >> element->kd;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss1A.ks
bool assign_Pss1A_ks(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1A*>(base_class_ptr))
	{
		buffer >> element->ks.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss1A.t1
bool assign_Pss1A_t1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1A*>(base_class_ptr))
	{
		buffer >> element->t1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss1A.t2
bool assign_Pss1A_t2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1A*>(base_class_ptr))
	{
		buffer >> element->t2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss1A.t3
bool assign_Pss1A_t3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1A*>(base_class_ptr))
	{
		buffer >> element->t3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss1A.t4
bool assign_Pss1A_t4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1A*>(base_class_ptr))
	{
		buffer >> element->t4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss1A.t5
bool assign_Pss1A_t5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1A*>(base_class_ptr))
	{
		buffer >> element->t5.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss1A.t6
bool assign_Pss1A_t6(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1A*>(base_class_ptr))
	{
		buffer >> element->t6.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss1A.tdelay
bool assign_Pss1A_tdelay(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1A*>(base_class_ptr))
	{
		buffer >> element->tdelay.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss1A.vcl
bool assign_Pss1A_vcl(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1A*>(base_class_ptr))
	{
		buffer >> element->vcl.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss1A.vcu
bool assign_Pss1A_vcu(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1A*>(base_class_ptr))
	{
		buffer >> element->vcu.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss1A.vrmax
bool assign_Pss1A_vrmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1A*>(base_class_ptr))
	{
		buffer >> element->vrmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss1A.vrmin
bool assign_Pss1A_vrmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss1A*>(base_class_ptr))
	{
		buffer >> element->vrmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss2B.a
bool assign_Pss2B_a(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B*>(base_class_ptr))
	{
		buffer >> element->a;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss2B.inputSignal1Type
bool assign_Pss2B_inputSignal1Type(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B*>(base_class_ptr))
	{
		buffer >> element->inputSignal1Type;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss2B.inputSignal2Type
bool assign_Pss2B_inputSignal2Type(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B*>(base_class_ptr))
	{
		buffer >> element->inputSignal2Type;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss2B.ks1
bool assign_Pss2B_ks1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B*>(base_class_ptr))
	{
		buffer >> element->ks1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss2B.ks2
bool assign_Pss2B_ks2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B*>(base_class_ptr))
	{
		buffer >> element->ks2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss2B.ks3
bool assign_Pss2B_ks3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B*>(base_class_ptr))
	{
		buffer >> element->ks3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss2B.ks4
bool assign_Pss2B_ks4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B*>(base_class_ptr))
	{
		buffer >> element->ks4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss2B.m
bool assign_Pss2B_m(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B*>(base_class_ptr))
	{
		buffer >> element->m;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss2B.n
bool assign_Pss2B_n(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B*>(base_class_ptr))
	{
		buffer >> element->n;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss2B.t1
bool assign_Pss2B_t1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B*>(base_class_ptr))
	{
		buffer >> element->t1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss2B.t10
bool assign_Pss2B_t10(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B*>(base_class_ptr))
	{
		buffer >> element->t10.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss2B.t11
bool assign_Pss2B_t11(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B*>(base_class_ptr))
	{
		buffer >> element->t11.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss2B.t2
bool assign_Pss2B_t2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B*>(base_class_ptr))
	{
		buffer >> element->t2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss2B.t3
bool assign_Pss2B_t3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B*>(base_class_ptr))
	{
		buffer >> element->t3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss2B.t4
bool assign_Pss2B_t4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B*>(base_class_ptr))
	{
		buffer >> element->t4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss2B.t6
bool assign_Pss2B_t6(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B*>(base_class_ptr))
	{
		buffer >> element->t6.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss2B.t7
bool assign_Pss2B_t7(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B*>(base_class_ptr))
	{
		buffer >> element->t7.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss2B.t8
bool assign_Pss2B_t8(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B*>(base_class_ptr))
	{
		buffer >> element->t8.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss2B.t9
bool assign_Pss2B_t9(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B*>(base_class_ptr))
	{
		buffer >> element->t9.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss2B.ta
bool assign_Pss2B_ta(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B*>(base_class_ptr))
	{
		buffer >> element->ta.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss2B.tb
bool assign_Pss2B_tb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B*>(base_class_ptr))
	{
		buffer >> element->tb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss2B.tw1
bool assign_Pss2B_tw1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B*>(base_class_ptr))
	{
		buffer >> element->tw1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss2B.tw2
bool assign_Pss2B_tw2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B*>(base_class_ptr))
	{
		buffer >> element->tw2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss2B.tw3
bool assign_Pss2B_tw3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B*>(base_class_ptr))
	{
		buffer >> element->tw3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss2B.tw4
bool assign_Pss2B_tw4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B*>(base_class_ptr))
	{
		buffer >> element->tw4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss2B.vsi1max
bool assign_Pss2B_vsi1max(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B*>(base_class_ptr))
	{
		buffer >> element->vsi1max.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss2B.vsi1min
bool assign_Pss2B_vsi1min(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B*>(base_class_ptr))
	{
		buffer >> element->vsi1min.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss2B.vsi2max
bool assign_Pss2B_vsi2max(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B*>(base_class_ptr))
	{
		buffer >> element->vsi2max.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss2B.vsi2min
bool assign_Pss2B_vsi2min(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B*>(base_class_ptr))
	{
		buffer >> element->vsi2min.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss2B.vstmax
bool assign_Pss2B_vstmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B*>(base_class_ptr))
	{
		buffer >> element->vstmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss2B.vstmin
bool assign_Pss2B_vstmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2B*>(base_class_ptr))
	{
		buffer >> element->vstmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss2ST.inputSignal1Type
bool assign_Pss2ST_inputSignal1Type(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2ST* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2ST*>(base_class_ptr))
	{
		buffer >> element->inputSignal1Type;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss2ST.inputSignal2Type
bool assign_Pss2ST_inputSignal2Type(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2ST* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2ST*>(base_class_ptr))
	{
		buffer >> element->inputSignal2Type;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss2ST.k1
bool assign_Pss2ST_k1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2ST* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2ST*>(base_class_ptr))
	{
		buffer >> element->k1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss2ST.k2
bool assign_Pss2ST_k2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2ST* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2ST*>(base_class_ptr))
	{
		buffer >> element->k2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss2ST.lsmax
bool assign_Pss2ST_lsmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2ST* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2ST*>(base_class_ptr))
	{
		buffer >> element->lsmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss2ST.lsmin
bool assign_Pss2ST_lsmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2ST* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2ST*>(base_class_ptr))
	{
		buffer >> element->lsmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss2ST.t1
bool assign_Pss2ST_t1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2ST* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2ST*>(base_class_ptr))
	{
		buffer >> element->t1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss2ST.t10
bool assign_Pss2ST_t10(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2ST* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2ST*>(base_class_ptr))
	{
		buffer >> element->t10.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss2ST.t2
bool assign_Pss2ST_t2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2ST* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2ST*>(base_class_ptr))
	{
		buffer >> element->t2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss2ST.t3
bool assign_Pss2ST_t3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2ST* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2ST*>(base_class_ptr))
	{
		buffer >> element->t3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss2ST.t4
bool assign_Pss2ST_t4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2ST* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2ST*>(base_class_ptr))
	{
		buffer >> element->t4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss2ST.t5
bool assign_Pss2ST_t5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2ST* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2ST*>(base_class_ptr))
	{
		buffer >> element->t5.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss2ST.t6
bool assign_Pss2ST_t6(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2ST* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2ST*>(base_class_ptr))
	{
		buffer >> element->t6.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss2ST.t7
bool assign_Pss2ST_t7(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2ST* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2ST*>(base_class_ptr))
	{
		buffer >> element->t7.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss2ST.t8
bool assign_Pss2ST_t8(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2ST* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2ST*>(base_class_ptr))
	{
		buffer >> element->t8.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss2ST.t9
bool assign_Pss2ST_t9(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2ST* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2ST*>(base_class_ptr))
	{
		buffer >> element->t9.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss2ST.vcl
bool assign_Pss2ST_vcl(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2ST* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2ST*>(base_class_ptr))
	{
		buffer >> element->vcl.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss2ST.vcu
bool assign_Pss2ST_vcu(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2ST* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss2ST*>(base_class_ptr))
	{
		buffer >> element->vcu.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss5.ctw2
bool assign_Pss5_ctw2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss5* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss5*>(base_class_ptr))
	{
		buffer >> element->ctw2;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss5.deadband
bool assign_Pss5_deadband(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss5* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss5*>(base_class_ptr))
	{
		buffer >> element->deadband.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss5.isfreq
bool assign_Pss5_isfreq(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss5* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss5*>(base_class_ptr))
	{
		buffer >> element->isfreq;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss5.kf
bool assign_Pss5_kf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss5* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss5*>(base_class_ptr))
	{
		buffer >> element->kf;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss5.kpe
bool assign_Pss5_kpe(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss5* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss5*>(base_class_ptr))
	{
		buffer >> element->kpe;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss5.kpss
bool assign_Pss5_kpss(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss5* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss5*>(base_class_ptr))
	{
		buffer >> element->kpss;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss5.pmm
bool assign_Pss5_pmm(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss5* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss5*>(base_class_ptr))
	{
		buffer >> element->pmm.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss5.tl1
bool assign_Pss5_tl1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss5* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss5*>(base_class_ptr))
	{
		buffer >> element->tl1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss5.tl2
bool assign_Pss5_tl2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss5* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss5*>(base_class_ptr))
	{
		buffer >> element->tl2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss5.tl3
bool assign_Pss5_tl3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss5* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss5*>(base_class_ptr))
	{
		buffer >> element->tl3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss5.tl4
bool assign_Pss5_tl4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss5* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss5*>(base_class_ptr))
	{
		buffer >> element->tl4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss5.tpe
bool assign_Pss5_tpe(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss5* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss5*>(base_class_ptr))
	{
		buffer >> element->tpe.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss5.tw1
bool assign_Pss5_tw1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss5* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss5*>(base_class_ptr))
	{
		buffer >> element->tw1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss5.tw2
bool assign_Pss5_tw2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss5* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss5*>(base_class_ptr))
	{
		buffer >> element->tw2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss5.vadat
bool assign_Pss5_vadat(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss5* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss5*>(base_class_ptr))
	{
		buffer >> element->vadat;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss5.vsmn
bool assign_Pss5_vsmn(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss5* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss5*>(base_class_ptr))
	{
		buffer >> element->vsmn.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:Pss5.vsmx
bool assign_Pss5_vsmx(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss5* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::Pss5*>(base_class_ptr))
	{
		buffer >> element->vsmx.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssELIN2.apss
bool assign_PssELIN2_apss(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssELIN2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssELIN2*>(base_class_ptr))
	{
		buffer >> element->apss.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssELIN2.ks1
bool assign_PssELIN2_ks1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssELIN2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssELIN2*>(base_class_ptr))
	{
		buffer >> element->ks1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssELIN2.ks2
bool assign_PssELIN2_ks2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssELIN2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssELIN2*>(base_class_ptr))
	{
		buffer >> element->ks2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssELIN2.ppss
bool assign_PssELIN2_ppss(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssELIN2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssELIN2*>(base_class_ptr))
	{
		buffer >> element->ppss.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssELIN2.psslim
bool assign_PssELIN2_psslim(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssELIN2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssELIN2*>(base_class_ptr))
	{
		buffer >> element->psslim.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssELIN2.ts1
bool assign_PssELIN2_ts1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssELIN2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssELIN2*>(base_class_ptr))
	{
		buffer >> element->ts1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssELIN2.ts2
bool assign_PssELIN2_ts2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssELIN2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssELIN2*>(base_class_ptr))
	{
		buffer >> element->ts2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssELIN2.ts3
bool assign_PssELIN2_ts3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssELIN2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssELIN2*>(base_class_ptr))
	{
		buffer >> element->ts3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssELIN2.ts4
bool assign_PssELIN2_ts4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssELIN2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssELIN2*>(base_class_ptr))
	{
		buffer >> element->ts4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssELIN2.ts5
bool assign_PssELIN2_ts5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssELIN2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssELIN2*>(base_class_ptr))
	{
		buffer >> element->ts5.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssELIN2.ts6
bool assign_PssELIN2_ts6(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssELIN2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssELIN2*>(base_class_ptr))
	{
		buffer >> element->ts6.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE1A.a1
bool assign_PssIEEE1A_a1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE1A*>(base_class_ptr))
	{
		buffer >> element->a1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE1A.a2
bool assign_PssIEEE1A_a2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE1A*>(base_class_ptr))
	{
		buffer >> element->a2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE1A.inputSignalType
bool assign_PssIEEE1A_inputSignalType(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE1A*>(base_class_ptr))
	{
		buffer >> element->inputSignalType;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE1A.ks
bool assign_PssIEEE1A_ks(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE1A*>(base_class_ptr))
	{
		buffer >> element->ks.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE1A.t1
bool assign_PssIEEE1A_t1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE1A*>(base_class_ptr))
	{
		buffer >> element->t1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE1A.t2
bool assign_PssIEEE1A_t2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE1A*>(base_class_ptr))
	{
		buffer >> element->t2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE1A.t3
bool assign_PssIEEE1A_t3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE1A*>(base_class_ptr))
	{
		buffer >> element->t3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE1A.t4
bool assign_PssIEEE1A_t4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE1A*>(base_class_ptr))
	{
		buffer >> element->t4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE1A.t5
bool assign_PssIEEE1A_t5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE1A*>(base_class_ptr))
	{
		buffer >> element->t5.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE1A.t6
bool assign_PssIEEE1A_t6(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE1A*>(base_class_ptr))
	{
		buffer >> element->t6.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE1A.vrmax
bool assign_PssIEEE1A_vrmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE1A*>(base_class_ptr))
	{
		buffer >> element->vrmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE1A.vrmin
bool assign_PssIEEE1A_vrmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE1A* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE1A*>(base_class_ptr))
	{
		buffer >> element->vrmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE2B.inputSignal1Type
bool assign_PssIEEE2B_inputSignal1Type(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE2B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE2B*>(base_class_ptr))
	{
		buffer >> element->inputSignal1Type;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE2B.inputSignal2Type
bool assign_PssIEEE2B_inputSignal2Type(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE2B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE2B*>(base_class_ptr))
	{
		buffer >> element->inputSignal2Type;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE2B.ks1
bool assign_PssIEEE2B_ks1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE2B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE2B*>(base_class_ptr))
	{
		buffer >> element->ks1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE2B.ks2
bool assign_PssIEEE2B_ks2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE2B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE2B*>(base_class_ptr))
	{
		buffer >> element->ks2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE2B.ks3
bool assign_PssIEEE2B_ks3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE2B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE2B*>(base_class_ptr))
	{
		buffer >> element->ks3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE2B.m
bool assign_PssIEEE2B_m(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE2B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE2B*>(base_class_ptr))
	{
		buffer >> element->m;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE2B.n
bool assign_PssIEEE2B_n(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE2B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE2B*>(base_class_ptr))
	{
		buffer >> element->n;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE2B.t1
bool assign_PssIEEE2B_t1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE2B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE2B*>(base_class_ptr))
	{
		buffer >> element->t1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE2B.t10
bool assign_PssIEEE2B_t10(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE2B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE2B*>(base_class_ptr))
	{
		buffer >> element->t10.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE2B.t11
bool assign_PssIEEE2B_t11(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE2B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE2B*>(base_class_ptr))
	{
		buffer >> element->t11.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE2B.t2
bool assign_PssIEEE2B_t2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE2B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE2B*>(base_class_ptr))
	{
		buffer >> element->t2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE2B.t3
bool assign_PssIEEE2B_t3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE2B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE2B*>(base_class_ptr))
	{
		buffer >> element->t3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE2B.t4
bool assign_PssIEEE2B_t4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE2B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE2B*>(base_class_ptr))
	{
		buffer >> element->t4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE2B.t6
bool assign_PssIEEE2B_t6(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE2B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE2B*>(base_class_ptr))
	{
		buffer >> element->t6.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE2B.t7
bool assign_PssIEEE2B_t7(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE2B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE2B*>(base_class_ptr))
	{
		buffer >> element->t7.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE2B.t8
bool assign_PssIEEE2B_t8(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE2B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE2B*>(base_class_ptr))
	{
		buffer >> element->t8.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE2B.t9
bool assign_PssIEEE2B_t9(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE2B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE2B*>(base_class_ptr))
	{
		buffer >> element->t9.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE2B.tw1
bool assign_PssIEEE2B_tw1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE2B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE2B*>(base_class_ptr))
	{
		buffer >> element->tw1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE2B.tw2
bool assign_PssIEEE2B_tw2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE2B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE2B*>(base_class_ptr))
	{
		buffer >> element->tw2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE2B.tw3
bool assign_PssIEEE2B_tw3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE2B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE2B*>(base_class_ptr))
	{
		buffer >> element->tw3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE2B.tw4
bool assign_PssIEEE2B_tw4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE2B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE2B*>(base_class_ptr))
	{
		buffer >> element->tw4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE2B.vsi1max
bool assign_PssIEEE2B_vsi1max(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE2B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE2B*>(base_class_ptr))
	{
		buffer >> element->vsi1max.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE2B.vsi1min
bool assign_PssIEEE2B_vsi1min(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE2B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE2B*>(base_class_ptr))
	{
		buffer >> element->vsi1min.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE2B.vsi2max
bool assign_PssIEEE2B_vsi2max(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE2B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE2B*>(base_class_ptr))
	{
		buffer >> element->vsi2max.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE2B.vsi2min
bool assign_PssIEEE2B_vsi2min(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE2B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE2B*>(base_class_ptr))
	{
		buffer >> element->vsi2min.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE2B.vstmax
bool assign_PssIEEE2B_vstmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE2B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE2B*>(base_class_ptr))
	{
		buffer >> element->vstmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE2B.vstmin
bool assign_PssIEEE2B_vstmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE2B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE2B*>(base_class_ptr))
	{
		buffer >> element->vstmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE3B.a1
bool assign_PssIEEE3B_a1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE3B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE3B*>(base_class_ptr))
	{
		buffer >> element->a1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE3B.a2
bool assign_PssIEEE3B_a2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE3B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE3B*>(base_class_ptr))
	{
		buffer >> element->a2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE3B.a3
bool assign_PssIEEE3B_a3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE3B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE3B*>(base_class_ptr))
	{
		buffer >> element->a3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE3B.a4
bool assign_PssIEEE3B_a4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE3B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE3B*>(base_class_ptr))
	{
		buffer >> element->a4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE3B.a5
bool assign_PssIEEE3B_a5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE3B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE3B*>(base_class_ptr))
	{
		buffer >> element->a5.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE3B.a6
bool assign_PssIEEE3B_a6(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE3B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE3B*>(base_class_ptr))
	{
		buffer >> element->a6.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE3B.a7
bool assign_PssIEEE3B_a7(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE3B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE3B*>(base_class_ptr))
	{
		buffer >> element->a7.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE3B.a8
bool assign_PssIEEE3B_a8(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE3B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE3B*>(base_class_ptr))
	{
		buffer >> element->a8.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE3B.inputSignal1Type
bool assign_PssIEEE3B_inputSignal1Type(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE3B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE3B*>(base_class_ptr))
	{
		buffer >> element->inputSignal1Type;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE3B.inputSignal2Type
bool assign_PssIEEE3B_inputSignal2Type(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE3B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE3B*>(base_class_ptr))
	{
		buffer >> element->inputSignal2Type;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE3B.ks1
bool assign_PssIEEE3B_ks1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE3B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE3B*>(base_class_ptr))
	{
		buffer >> element->ks1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE3B.ks2
bool assign_PssIEEE3B_ks2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE3B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE3B*>(base_class_ptr))
	{
		buffer >> element->ks2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE3B.t1
bool assign_PssIEEE3B_t1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE3B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE3B*>(base_class_ptr))
	{
		buffer >> element->t1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE3B.t2
bool assign_PssIEEE3B_t2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE3B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE3B*>(base_class_ptr))
	{
		buffer >> element->t2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE3B.tw1
bool assign_PssIEEE3B_tw1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE3B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE3B*>(base_class_ptr))
	{
		buffer >> element->tw1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE3B.tw2
bool assign_PssIEEE3B_tw2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE3B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE3B*>(base_class_ptr))
	{
		buffer >> element->tw2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE3B.tw3
bool assign_PssIEEE3B_tw3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE3B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE3B*>(base_class_ptr))
	{
		buffer >> element->tw3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE3B.vstmax
bool assign_PssIEEE3B_vstmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE3B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE3B*>(base_class_ptr))
	{
		buffer >> element->vstmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE3B.vstmin
bool assign_PssIEEE3B_vstmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE3B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE3B*>(base_class_ptr))
	{
		buffer >> element->vstmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.bwh1
bool assign_PssIEEE4B_bwh1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->bwh1;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.bwh2
bool assign_PssIEEE4B_bwh2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->bwh2;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.bwl1
bool assign_PssIEEE4B_bwl1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->bwl1;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.bwl2
bool assign_PssIEEE4B_bwl2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->bwl2;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.kh
bool assign_PssIEEE4B_kh(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->kh.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.kh1
bool assign_PssIEEE4B_kh1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->kh1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.kh11
bool assign_PssIEEE4B_kh11(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->kh11.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.kh17
bool assign_PssIEEE4B_kh17(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->kh17.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.kh2
bool assign_PssIEEE4B_kh2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->kh2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.ki
bool assign_PssIEEE4B_ki(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->ki.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.ki1
bool assign_PssIEEE4B_ki1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->ki1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.ki11
bool assign_PssIEEE4B_ki11(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->ki11.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.ki17
bool assign_PssIEEE4B_ki17(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->ki17.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.ki2
bool assign_PssIEEE4B_ki2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->ki2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.kl
bool assign_PssIEEE4B_kl(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->kl.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.kl1
bool assign_PssIEEE4B_kl1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->kl1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.kl11
bool assign_PssIEEE4B_kl11(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->kl11.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.kl17
bool assign_PssIEEE4B_kl17(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->kl17.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.kl2
bool assign_PssIEEE4B_kl2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->kl2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.omeganh1
bool assign_PssIEEE4B_omeganh1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->omeganh1;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.omeganh2
bool assign_PssIEEE4B_omeganh2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->omeganh2;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.omeganl1
bool assign_PssIEEE4B_omeganl1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->omeganl1;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.omeganl2
bool assign_PssIEEE4B_omeganl2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->omeganl2;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.th1
bool assign_PssIEEE4B_th1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->th1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.th10
bool assign_PssIEEE4B_th10(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->th10.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.th11
bool assign_PssIEEE4B_th11(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->th11.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.th12
bool assign_PssIEEE4B_th12(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->th12.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.th2
bool assign_PssIEEE4B_th2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->th2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.th3
bool assign_PssIEEE4B_th3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->th3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.th4
bool assign_PssIEEE4B_th4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->th4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.th5
bool assign_PssIEEE4B_th5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->th5.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.th6
bool assign_PssIEEE4B_th6(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->th6.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.th7
bool assign_PssIEEE4B_th7(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->th7.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.th8
bool assign_PssIEEE4B_th8(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->th8.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.th9
bool assign_PssIEEE4B_th9(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->th9.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.ti1
bool assign_PssIEEE4B_ti1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->ti1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.ti10
bool assign_PssIEEE4B_ti10(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->ti10.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.ti11
bool assign_PssIEEE4B_ti11(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->ti11.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.ti12
bool assign_PssIEEE4B_ti12(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->ti12.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.ti2
bool assign_PssIEEE4B_ti2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->ti2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.ti3
bool assign_PssIEEE4B_ti3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->ti3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.ti4
bool assign_PssIEEE4B_ti4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->ti4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.ti5
bool assign_PssIEEE4B_ti5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->ti5.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.ti6
bool assign_PssIEEE4B_ti6(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->ti6.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.ti7
bool assign_PssIEEE4B_ti7(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->ti7.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.ti8
bool assign_PssIEEE4B_ti8(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->ti8.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.ti9
bool assign_PssIEEE4B_ti9(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->ti9.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.tl1
bool assign_PssIEEE4B_tl1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->tl1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.tl10
bool assign_PssIEEE4B_tl10(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->tl10.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.tl11
bool assign_PssIEEE4B_tl11(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->tl11.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.tl12
bool assign_PssIEEE4B_tl12(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->tl12.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.tl2
bool assign_PssIEEE4B_tl2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->tl2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.tl3
bool assign_PssIEEE4B_tl3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->tl3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.tl4
bool assign_PssIEEE4B_tl4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->tl4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.tl5
bool assign_PssIEEE4B_tl5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->tl5.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.tl6
bool assign_PssIEEE4B_tl6(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->tl6.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.tl7
bool assign_PssIEEE4B_tl7(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->tl7.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.tl8
bool assign_PssIEEE4B_tl8(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->tl8.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.tl9
bool assign_PssIEEE4B_tl9(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->tl9.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.vhmax
bool assign_PssIEEE4B_vhmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->vhmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.vhmin
bool assign_PssIEEE4B_vhmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->vhmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.vimax
bool assign_PssIEEE4B_vimax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->vimax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.vimin
bool assign_PssIEEE4B_vimin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->vimin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.vlmax
bool assign_PssIEEE4B_vlmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->vlmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.vlmin
bool assign_PssIEEE4B_vlmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->vlmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.vstmax
bool assign_PssIEEE4B_vstmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->vstmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssIEEE4B.vstmin
bool assign_PssIEEE4B_vstmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssIEEE4B*>(base_class_ptr))
	{
		buffer >> element->vstmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssPTIST1.dtc
bool assign_PssPTIST1_dtc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST1*>(base_class_ptr))
	{
		buffer >> element->dtc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssPTIST1.dtf
bool assign_PssPTIST1_dtf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST1*>(base_class_ptr))
	{
		buffer >> element->dtf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssPTIST1.dtp
bool assign_PssPTIST1_dtp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST1*>(base_class_ptr))
	{
		buffer >> element->dtp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssPTIST1.k
bool assign_PssPTIST1_k(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST1*>(base_class_ptr))
	{
		buffer >> element->k.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssPTIST1.m
bool assign_PssPTIST1_m(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST1*>(base_class_ptr))
	{
		buffer >> element->m.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssPTIST1.t1
bool assign_PssPTIST1_t1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST1*>(base_class_ptr))
	{
		buffer >> element->t1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssPTIST1.t2
bool assign_PssPTIST1_t2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST1*>(base_class_ptr))
	{
		buffer >> element->t2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssPTIST1.t3
bool assign_PssPTIST1_t3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST1*>(base_class_ptr))
	{
		buffer >> element->t3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssPTIST1.t4
bool assign_PssPTIST1_t4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST1*>(base_class_ptr))
	{
		buffer >> element->t4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssPTIST1.tf
bool assign_PssPTIST1_tf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST1*>(base_class_ptr))
	{
		buffer >> element->tf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssPTIST1.tp
bool assign_PssPTIST1_tp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST1*>(base_class_ptr))
	{
		buffer >> element->tp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssPTIST3.a0
bool assign_PssPTIST3_a0(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3*>(base_class_ptr))
	{
		buffer >> element->a0.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssPTIST3.a1
bool assign_PssPTIST3_a1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3*>(base_class_ptr))
	{
		buffer >> element->a1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssPTIST3.a2
bool assign_PssPTIST3_a2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3*>(base_class_ptr))
	{
		buffer >> element->a2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssPTIST3.a3
bool assign_PssPTIST3_a3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3*>(base_class_ptr))
	{
		buffer >> element->a3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssPTIST3.a4
bool assign_PssPTIST3_a4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3*>(base_class_ptr))
	{
		buffer >> element->a4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssPTIST3.a5
bool assign_PssPTIST3_a5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3*>(base_class_ptr))
	{
		buffer >> element->a5.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssPTIST3.al
bool assign_PssPTIST3_al(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3*>(base_class_ptr))
	{
		buffer >> element->al.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssPTIST3.athres
bool assign_PssPTIST3_athres(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3*>(base_class_ptr))
	{
		buffer >> element->athres.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssPTIST3.b0
bool assign_PssPTIST3_b0(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3*>(base_class_ptr))
	{
		buffer >> element->b0.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssPTIST3.b1
bool assign_PssPTIST3_b1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3*>(base_class_ptr))
	{
		buffer >> element->b1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssPTIST3.b2
bool assign_PssPTIST3_b2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3*>(base_class_ptr))
	{
		buffer >> element->b2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssPTIST3.b3
bool assign_PssPTIST3_b3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3*>(base_class_ptr))
	{
		buffer >> element->b3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssPTIST3.b4
bool assign_PssPTIST3_b4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3*>(base_class_ptr))
	{
		buffer >> element->b4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssPTIST3.b5
bool assign_PssPTIST3_b5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3*>(base_class_ptr))
	{
		buffer >> element->b5.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssPTIST3.dl
bool assign_PssPTIST3_dl(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3*>(base_class_ptr))
	{
		buffer >> element->dl.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssPTIST3.dtc
bool assign_PssPTIST3_dtc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3*>(base_class_ptr))
	{
		buffer >> element->dtc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssPTIST3.dtf
bool assign_PssPTIST3_dtf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3*>(base_class_ptr))
	{
		buffer >> element->dtf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssPTIST3.dtp
bool assign_PssPTIST3_dtp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3*>(base_class_ptr))
	{
		buffer >> element->dtp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssPTIST3.isw
bool assign_PssPTIST3_isw(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3*>(base_class_ptr))
	{
		buffer >> element->isw;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssPTIST3.k
bool assign_PssPTIST3_k(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3*>(base_class_ptr))
	{
		buffer >> element->k.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssPTIST3.lthres
bool assign_PssPTIST3_lthres(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3*>(base_class_ptr))
	{
		buffer >> element->lthres.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssPTIST3.m
bool assign_PssPTIST3_m(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3*>(base_class_ptr))
	{
		buffer >> element->m.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssPTIST3.nav
bool assign_PssPTIST3_nav(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3*>(base_class_ptr))
	{
		buffer >> element->nav;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssPTIST3.ncl
bool assign_PssPTIST3_ncl(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3*>(base_class_ptr))
	{
		buffer >> element->ncl;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssPTIST3.ncr
bool assign_PssPTIST3_ncr(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3*>(base_class_ptr))
	{
		buffer >> element->ncr;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssPTIST3.pmin
bool assign_PssPTIST3_pmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3*>(base_class_ptr))
	{
		buffer >> element->pmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssPTIST3.t1
bool assign_PssPTIST3_t1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3*>(base_class_ptr))
	{
		buffer >> element->t1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssPTIST3.t2
bool assign_PssPTIST3_t2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3*>(base_class_ptr))
	{
		buffer >> element->t2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssPTIST3.t3
bool assign_PssPTIST3_t3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3*>(base_class_ptr))
	{
		buffer >> element->t3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssPTIST3.t4
bool assign_PssPTIST3_t4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3*>(base_class_ptr))
	{
		buffer >> element->t4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssPTIST3.t5
bool assign_PssPTIST3_t5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3*>(base_class_ptr))
	{
		buffer >> element->t5.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssPTIST3.t6
bool assign_PssPTIST3_t6(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3*>(base_class_ptr))
	{
		buffer >> element->t6.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssPTIST3.tf
bool assign_PssPTIST3_tf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3*>(base_class_ptr))
	{
		buffer >> element->tf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssPTIST3.tp
bool assign_PssPTIST3_tp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssPTIST3*>(base_class_ptr))
	{
		buffer >> element->tp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssSB4.kx
bool assign_PssSB4_kx(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSB4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSB4*>(base_class_ptr))
	{
		buffer >> element->kx.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssSB4.ta
bool assign_PssSB4_ta(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSB4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSB4*>(base_class_ptr))
	{
		buffer >> element->ta.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssSB4.tb
bool assign_PssSB4_tb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSB4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSB4*>(base_class_ptr))
	{
		buffer >> element->tb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssSB4.tc
bool assign_PssSB4_tc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSB4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSB4*>(base_class_ptr))
	{
		buffer >> element->tc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssSB4.td
bool assign_PssSB4_td(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSB4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSB4*>(base_class_ptr))
	{
		buffer >> element->td.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssSB4.te
bool assign_PssSB4_te(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSB4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSB4*>(base_class_ptr))
	{
		buffer >> element->te.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssSB4.tt
bool assign_PssSB4_tt(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSB4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSB4*>(base_class_ptr))
	{
		buffer >> element->tt.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssSB4.tx1
bool assign_PssSB4_tx1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSB4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSB4*>(base_class_ptr))
	{
		buffer >> element->tx1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssSB4.tx2
bool assign_PssSB4_tx2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSB4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSB4*>(base_class_ptr))
	{
		buffer >> element->tx2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssSB4.vsmax
bool assign_PssSB4_vsmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSB4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSB4*>(base_class_ptr))
	{
		buffer >> element->vsmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssSB4.vsmin
bool assign_PssSB4_vsmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSB4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSB4*>(base_class_ptr))
	{
		buffer >> element->vsmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssSH.k
bool assign_PssSH_k(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSH*>(base_class_ptr))
	{
		buffer >> element->k.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssSH.k0
bool assign_PssSH_k0(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSH*>(base_class_ptr))
	{
		buffer >> element->k0.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssSH.k1
bool assign_PssSH_k1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSH*>(base_class_ptr))
	{
		buffer >> element->k1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssSH.k2
bool assign_PssSH_k2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSH*>(base_class_ptr))
	{
		buffer >> element->k2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssSH.k3
bool assign_PssSH_k3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSH*>(base_class_ptr))
	{
		buffer >> element->k3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssSH.k4
bool assign_PssSH_k4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSH*>(base_class_ptr))
	{
		buffer >> element->k4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssSH.t1
bool assign_PssSH_t1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSH*>(base_class_ptr))
	{
		buffer >> element->t1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssSH.t2
bool assign_PssSH_t2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSH*>(base_class_ptr))
	{
		buffer >> element->t2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssSH.t3
bool assign_PssSH_t3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSH*>(base_class_ptr))
	{
		buffer >> element->t3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssSH.t4
bool assign_PssSH_t4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSH*>(base_class_ptr))
	{
		buffer >> element->t4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssSH.td
bool assign_PssSH_td(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSH*>(base_class_ptr))
	{
		buffer >> element->td.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssSH.vsmax
bool assign_PssSH_vsmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSH*>(base_class_ptr))
	{
		buffer >> element->vsmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssSH.vsmin
bool assign_PssSH_vsmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSH*>(base_class_ptr))
	{
		buffer >> element->vsmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssSK.k1
bool assign_PssSK_k1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSK* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSK*>(base_class_ptr))
	{
		buffer >> element->k1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssSK.k2
bool assign_PssSK_k2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSK* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSK*>(base_class_ptr))
	{
		buffer >> element->k2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssSK.k3
bool assign_PssSK_k3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSK* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSK*>(base_class_ptr))
	{
		buffer >> element->k3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssSK.t1
bool assign_PssSK_t1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSK* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSK*>(base_class_ptr))
	{
		buffer >> element->t1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssSK.t2
bool assign_PssSK_t2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSK* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSK*>(base_class_ptr))
	{
		buffer >> element->t2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssSK.t3
bool assign_PssSK_t3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSK* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSK*>(base_class_ptr))
	{
		buffer >> element->t3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssSK.t4
bool assign_PssSK_t4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSK* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSK*>(base_class_ptr))
	{
		buffer >> element->t4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssSK.t5
bool assign_PssSK_t5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSK* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSK*>(base_class_ptr))
	{
		buffer >> element->t5.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssSK.t6
bool assign_PssSK_t6(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSK* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSK*>(base_class_ptr))
	{
		buffer >> element->t6.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssSK.vsmax
bool assign_PssSK_vsmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSK* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSK*>(base_class_ptr))
	{
		buffer >> element->vsmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssSK.vsmin
bool assign_PssSK_vsmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSK* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssSK*>(base_class_ptr))
	{
		buffer >> element->vsmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssWECC.inputSignal1Type
bool assign_PssWECC_inputSignal1Type(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssWECC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssWECC*>(base_class_ptr))
	{
		buffer >> element->inputSignal1Type;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssWECC.inputSignal2Type
bool assign_PssWECC_inputSignal2Type(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssWECC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssWECC*>(base_class_ptr))
	{
		buffer >> element->inputSignal2Type;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssWECC.k1
bool assign_PssWECC_k1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssWECC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssWECC*>(base_class_ptr))
	{
		buffer >> element->k1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssWECC.k2
bool assign_PssWECC_k2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssWECC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssWECC*>(base_class_ptr))
	{
		buffer >> element->k2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssWECC.t1
bool assign_PssWECC_t1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssWECC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssWECC*>(base_class_ptr))
	{
		buffer >> element->t1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssWECC.t10
bool assign_PssWECC_t10(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssWECC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssWECC*>(base_class_ptr))
	{
		buffer >> element->t10.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssWECC.t2
bool assign_PssWECC_t2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssWECC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssWECC*>(base_class_ptr))
	{
		buffer >> element->t2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssWECC.t3
bool assign_PssWECC_t3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssWECC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssWECC*>(base_class_ptr))
	{
		buffer >> element->t3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssWECC.t4
bool assign_PssWECC_t4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssWECC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssWECC*>(base_class_ptr))
	{
		buffer >> element->t4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssWECC.t5
bool assign_PssWECC_t5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssWECC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssWECC*>(base_class_ptr))
	{
		buffer >> element->t5.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssWECC.t6
bool assign_PssWECC_t6(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssWECC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssWECC*>(base_class_ptr))
	{
		buffer >> element->t6.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssWECC.t7
bool assign_PssWECC_t7(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssWECC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssWECC*>(base_class_ptr))
	{
		buffer >> element->t7.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssWECC.t8
bool assign_PssWECC_t8(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssWECC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssWECC*>(base_class_ptr))
	{
		buffer >> element->t8.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssWECC.t9
bool assign_PssWECC_t9(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssWECC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssWECC*>(base_class_ptr))
	{
		buffer >> element->t9.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssWECC.vcl
bool assign_PssWECC_vcl(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssWECC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssWECC*>(base_class_ptr))
	{
		buffer >> element->vcl.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssWECC.vcu
bool assign_PssWECC_vcu(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssWECC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssWECC*>(base_class_ptr))
	{
		buffer >> element->vcu.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssWECC.vsmax
bool assign_PssWECC_vsmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssWECC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssWECC*>(base_class_ptr))
	{
		buffer >> element->vsmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PssWECC.vsmin
bool assign_PssWECC_vsmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssWECC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::PowerSystemStabilizerDynamics::PssWECC*>(base_class_ptr))
	{
		buffer >> element->vsmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachineDetailed.efdBaseRatio
bool assign_SynchronousMachineDetailed_efdBaseRatio(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineDetailed* element = dynamic_cast<IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineDetailed*>(base_class_ptr))
	{
		buffer >> element->efdBaseRatio;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachineDetailed.ifdBaseType
bool assign_SynchronousMachineDetailed_ifdBaseType(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineDetailed* element = dynamic_cast<IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineDetailed*>(base_class_ptr))
	{
		buffer >> element->ifdBaseType;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachineDetailed.ifdBaseValue
bool assign_SynchronousMachineDetailed_ifdBaseValue(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineDetailed* element = dynamic_cast<IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineDetailed*>(base_class_ptr))
	{
		buffer >> element->ifdBaseValue.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachineDetailed.saturationFactor120QAxis
bool assign_SynchronousMachineDetailed_saturationFactor120QAxis(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineDetailed* element = dynamic_cast<IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineDetailed*>(base_class_ptr))
	{
		buffer >> element->saturationFactor120QAxis;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachineDetailed.saturationFactorQAxis
bool assign_SynchronousMachineDetailed_saturationFactorQAxis(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineDetailed* element = dynamic_cast<IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineDetailed*>(base_class_ptr))
	{
		buffer >> element->saturationFactorQAxis;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachineEquivalentCircuit.r1d
bool assign_SynchronousMachineEquivalentCircuit_r1d(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineEquivalentCircuit* element = dynamic_cast<IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineEquivalentCircuit*>(base_class_ptr))
	{
		buffer >> element->r1d.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachineEquivalentCircuit.r1q
bool assign_SynchronousMachineEquivalentCircuit_r1q(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineEquivalentCircuit* element = dynamic_cast<IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineEquivalentCircuit*>(base_class_ptr))
	{
		buffer >> element->r1q.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachineEquivalentCircuit.r2q
bool assign_SynchronousMachineEquivalentCircuit_r2q(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineEquivalentCircuit* element = dynamic_cast<IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineEquivalentCircuit*>(base_class_ptr))
	{
		buffer >> element->r2q.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachineEquivalentCircuit.rfd
bool assign_SynchronousMachineEquivalentCircuit_rfd(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineEquivalentCircuit* element = dynamic_cast<IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineEquivalentCircuit*>(base_class_ptr))
	{
		buffer >> element->rfd.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachineEquivalentCircuit.x1d
bool assign_SynchronousMachineEquivalentCircuit_x1d(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineEquivalentCircuit* element = dynamic_cast<IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineEquivalentCircuit*>(base_class_ptr))
	{
		buffer >> element->x1d.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachineEquivalentCircuit.x1q
bool assign_SynchronousMachineEquivalentCircuit_x1q(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineEquivalentCircuit* element = dynamic_cast<IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineEquivalentCircuit*>(base_class_ptr))
	{
		buffer >> element->x1q.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachineEquivalentCircuit.x2q
bool assign_SynchronousMachineEquivalentCircuit_x2q(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineEquivalentCircuit* element = dynamic_cast<IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineEquivalentCircuit*>(base_class_ptr))
	{
		buffer >> element->x2q.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachineEquivalentCircuit.xad
bool assign_SynchronousMachineEquivalentCircuit_xad(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineEquivalentCircuit* element = dynamic_cast<IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineEquivalentCircuit*>(base_class_ptr))
	{
		buffer >> element->xad.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachineEquivalentCircuit.xaq
bool assign_SynchronousMachineEquivalentCircuit_xaq(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineEquivalentCircuit* element = dynamic_cast<IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineEquivalentCircuit*>(base_class_ptr))
	{
		buffer >> element->xaq.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachineEquivalentCircuit.xf1d
bool assign_SynchronousMachineEquivalentCircuit_xf1d(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineEquivalentCircuit* element = dynamic_cast<IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineEquivalentCircuit*>(base_class_ptr))
	{
		buffer >> element->xf1d.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachineEquivalentCircuit.xfd
bool assign_SynchronousMachineEquivalentCircuit_xfd(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineEquivalentCircuit* element = dynamic_cast<IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineEquivalentCircuit*>(base_class_ptr))
	{
		buffer >> element->xfd.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachineTimeConstantReactance.ks
bool assign_SynchronousMachineTimeConstantReactance_ks(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineTimeConstantReactance* element = dynamic_cast<IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineTimeConstantReactance*>(base_class_ptr))
	{
		buffer >> element->ks;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachineTimeConstantReactance.modelType
bool assign_SynchronousMachineTimeConstantReactance_modelType(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineTimeConstantReactance* element = dynamic_cast<IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineTimeConstantReactance*>(base_class_ptr))
	{
		buffer >> element->modelType;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachineTimeConstantReactance.rotorType
bool assign_SynchronousMachineTimeConstantReactance_rotorType(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineTimeConstantReactance* element = dynamic_cast<IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineTimeConstantReactance*>(base_class_ptr))
	{
		buffer >> element->rotorType;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachineTimeConstantReactance.tc
bool assign_SynchronousMachineTimeConstantReactance_tc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineTimeConstantReactance* element = dynamic_cast<IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineTimeConstantReactance*>(base_class_ptr))
	{
		buffer >> element->tc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachineTimeConstantReactance.tpdo
bool assign_SynchronousMachineTimeConstantReactance_tpdo(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineTimeConstantReactance* element = dynamic_cast<IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineTimeConstantReactance*>(base_class_ptr))
	{
		buffer >> element->tpdo.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachineTimeConstantReactance.tppdo
bool assign_SynchronousMachineTimeConstantReactance_tppdo(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineTimeConstantReactance* element = dynamic_cast<IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineTimeConstantReactance*>(base_class_ptr))
	{
		buffer >> element->tppdo.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachineTimeConstantReactance.tppqo
bool assign_SynchronousMachineTimeConstantReactance_tppqo(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineTimeConstantReactance* element = dynamic_cast<IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineTimeConstantReactance*>(base_class_ptr))
	{
		buffer >> element->tppqo.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachineTimeConstantReactance.tpqo
bool assign_SynchronousMachineTimeConstantReactance_tpqo(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineTimeConstantReactance* element = dynamic_cast<IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineTimeConstantReactance*>(base_class_ptr))
	{
		buffer >> element->tpqo.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachineTimeConstantReactance.xDirectSubtrans
bool assign_SynchronousMachineTimeConstantReactance_xDirectSubtrans(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineTimeConstantReactance* element = dynamic_cast<IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineTimeConstantReactance*>(base_class_ptr))
	{
		buffer >> element->xDirectSubtrans.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachineTimeConstantReactance.xDirectSync
bool assign_SynchronousMachineTimeConstantReactance_xDirectSync(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineTimeConstantReactance* element = dynamic_cast<IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineTimeConstantReactance*>(base_class_ptr))
	{
		buffer >> element->xDirectSync.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachineTimeConstantReactance.xDirectTrans
bool assign_SynchronousMachineTimeConstantReactance_xDirectTrans(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineTimeConstantReactance* element = dynamic_cast<IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineTimeConstantReactance*>(base_class_ptr))
	{
		buffer >> element->xDirectTrans.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachineTimeConstantReactance.xQuadSubtrans
bool assign_SynchronousMachineTimeConstantReactance_xQuadSubtrans(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineTimeConstantReactance* element = dynamic_cast<IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineTimeConstantReactance*>(base_class_ptr))
	{
		buffer >> element->xQuadSubtrans.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachineTimeConstantReactance.xQuadSync
bool assign_SynchronousMachineTimeConstantReactance_xQuadSync(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineTimeConstantReactance* element = dynamic_cast<IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineTimeConstantReactance*>(base_class_ptr))
	{
		buffer >> element->xQuadSync.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachineTimeConstantReactance.xQuadTrans
bool assign_SynchronousMachineTimeConstantReactance_xQuadTrans(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineTimeConstantReactance* element = dynamic_cast<IEC61970::Dynamics::StandardModels::SynchronousMachineDynamics::SynchronousMachineTimeConstantReactance*>(base_class_ptr))
	{
		buffer >> element->xQuadTrans.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT1.aset
bool assign_GovCT1_aset(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1*>(base_class_ptr))
	{
		buffer >> element->aset;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT1.db
bool assign_GovCT1_db(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1*>(base_class_ptr))
	{
		buffer >> element->db.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT1.dm
bool assign_GovCT1_dm(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1*>(base_class_ptr))
	{
		buffer >> element->dm.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT1.ka
bool assign_GovCT1_ka(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1*>(base_class_ptr))
	{
		buffer >> element->ka.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT1.kdgov
bool assign_GovCT1_kdgov(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1*>(base_class_ptr))
	{
		buffer >> element->kdgov.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT1.kigov
bool assign_GovCT1_kigov(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1*>(base_class_ptr))
	{
		buffer >> element->kigov.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT1.kiload
bool assign_GovCT1_kiload(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1*>(base_class_ptr))
	{
		buffer >> element->kiload.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT1.kimw
bool assign_GovCT1_kimw(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1*>(base_class_ptr))
	{
		buffer >> element->kimw.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT1.kpgov
bool assign_GovCT1_kpgov(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1*>(base_class_ptr))
	{
		buffer >> element->kpgov.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT1.kpload
bool assign_GovCT1_kpload(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1*>(base_class_ptr))
	{
		buffer >> element->kpload.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT1.kturb
bool assign_GovCT1_kturb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1*>(base_class_ptr))
	{
		buffer >> element->kturb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT1.ldref
bool assign_GovCT1_ldref(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1*>(base_class_ptr))
	{
		buffer >> element->ldref.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT1.maxerr
bool assign_GovCT1_maxerr(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1*>(base_class_ptr))
	{
		buffer >> element->maxerr.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT1.minerr
bool assign_GovCT1_minerr(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1*>(base_class_ptr))
	{
		buffer >> element->minerr.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT1.mwbase
bool assign_GovCT1_mwbase(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1*>(base_class_ptr))
	{
		buffer >> element->mwbase.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT1.r
bool assign_GovCT1_r(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1*>(base_class_ptr))
	{
		buffer >> element->r.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT1.rclose
bool assign_GovCT1_rclose(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1*>(base_class_ptr))
	{
		buffer >> element->rclose;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT1.rdown
bool assign_GovCT1_rdown(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1*>(base_class_ptr))
	{
		buffer >> element->rdown.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT1.ropen
bool assign_GovCT1_ropen(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1*>(base_class_ptr))
	{
		buffer >> element->ropen;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT1.rselect
bool assign_GovCT1_rselect(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1*>(base_class_ptr))
	{
		buffer >> element->rselect;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT1.rup
bool assign_GovCT1_rup(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1*>(base_class_ptr))
	{
		buffer >> element->rup.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT1.ta
bool assign_GovCT1_ta(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1*>(base_class_ptr))
	{
		buffer >> element->ta.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT1.tact
bool assign_GovCT1_tact(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1*>(base_class_ptr))
	{
		buffer >> element->tact.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT1.tb
bool assign_GovCT1_tb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1*>(base_class_ptr))
	{
		buffer >> element->tb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT1.tc
bool assign_GovCT1_tc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1*>(base_class_ptr))
	{
		buffer >> element->tc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT1.tdgov
bool assign_GovCT1_tdgov(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1*>(base_class_ptr))
	{
		buffer >> element->tdgov.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT1.teng
bool assign_GovCT1_teng(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1*>(base_class_ptr))
	{
		buffer >> element->teng.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT1.tfload
bool assign_GovCT1_tfload(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1*>(base_class_ptr))
	{
		buffer >> element->tfload.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT1.tpelec
bool assign_GovCT1_tpelec(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1*>(base_class_ptr))
	{
		buffer >> element->tpelec.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT1.tsa
bool assign_GovCT1_tsa(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1*>(base_class_ptr))
	{
		buffer >> element->tsa.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT1.tsb
bool assign_GovCT1_tsb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1*>(base_class_ptr))
	{
		buffer >> element->tsb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT1.vmax
bool assign_GovCT1_vmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1*>(base_class_ptr))
	{
		buffer >> element->vmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT1.vmin
bool assign_GovCT1_vmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1*>(base_class_ptr))
	{
		buffer >> element->vmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT1.wfnl
bool assign_GovCT1_wfnl(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1*>(base_class_ptr))
	{
		buffer >> element->wfnl.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT1.wfspd
bool assign_GovCT1_wfspd(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT1*>(base_class_ptr))
	{
		buffer >> element->wfspd;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT2.aset
bool assign_GovCT2_aset(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2*>(base_class_ptr))
	{
		buffer >> element->aset;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT2.db
bool assign_GovCT2_db(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2*>(base_class_ptr))
	{
		buffer >> element->db.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT2.dm
bool assign_GovCT2_dm(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2*>(base_class_ptr))
	{
		buffer >> element->dm.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT2.flim1
bool assign_GovCT2_flim1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2*>(base_class_ptr))
	{
		buffer >> element->flim1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT2.flim10
bool assign_GovCT2_flim10(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2*>(base_class_ptr))
	{
		buffer >> element->flim10.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT2.flim2
bool assign_GovCT2_flim2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2*>(base_class_ptr))
	{
		buffer >> element->flim2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT2.flim3
bool assign_GovCT2_flim3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2*>(base_class_ptr))
	{
		buffer >> element->flim3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT2.flim4
bool assign_GovCT2_flim4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2*>(base_class_ptr))
	{
		buffer >> element->flim4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT2.flim5
bool assign_GovCT2_flim5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2*>(base_class_ptr))
	{
		buffer >> element->flim5.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT2.flim6
bool assign_GovCT2_flim6(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2*>(base_class_ptr))
	{
		buffer >> element->flim6.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT2.flim7
bool assign_GovCT2_flim7(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2*>(base_class_ptr))
	{
		buffer >> element->flim7.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT2.flim8
bool assign_GovCT2_flim8(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2*>(base_class_ptr))
	{
		buffer >> element->flim8.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT2.flim9
bool assign_GovCT2_flim9(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2*>(base_class_ptr))
	{
		buffer >> element->flim9.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT2.ka
bool assign_GovCT2_ka(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2*>(base_class_ptr))
	{
		buffer >> element->ka.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT2.kdgov
bool assign_GovCT2_kdgov(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2*>(base_class_ptr))
	{
		buffer >> element->kdgov.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT2.kigov
bool assign_GovCT2_kigov(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2*>(base_class_ptr))
	{
		buffer >> element->kigov.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT2.kiload
bool assign_GovCT2_kiload(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2*>(base_class_ptr))
	{
		buffer >> element->kiload.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT2.kimw
bool assign_GovCT2_kimw(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2*>(base_class_ptr))
	{
		buffer >> element->kimw.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT2.kpgov
bool assign_GovCT2_kpgov(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2*>(base_class_ptr))
	{
		buffer >> element->kpgov.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT2.kpload
bool assign_GovCT2_kpload(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2*>(base_class_ptr))
	{
		buffer >> element->kpload.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT2.kturb
bool assign_GovCT2_kturb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2*>(base_class_ptr))
	{
		buffer >> element->kturb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT2.ldref
bool assign_GovCT2_ldref(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2*>(base_class_ptr))
	{
		buffer >> element->ldref.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT2.maxerr
bool assign_GovCT2_maxerr(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2*>(base_class_ptr))
	{
		buffer >> element->maxerr.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT2.minerr
bool assign_GovCT2_minerr(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2*>(base_class_ptr))
	{
		buffer >> element->minerr.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT2.mwbase
bool assign_GovCT2_mwbase(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2*>(base_class_ptr))
	{
		buffer >> element->mwbase.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT2.plim1
bool assign_GovCT2_plim1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2*>(base_class_ptr))
	{
		buffer >> element->plim1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT2.plim10
bool assign_GovCT2_plim10(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2*>(base_class_ptr))
	{
		buffer >> element->plim10.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT2.plim2
bool assign_GovCT2_plim2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2*>(base_class_ptr))
	{
		buffer >> element->plim2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT2.plim3
bool assign_GovCT2_plim3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2*>(base_class_ptr))
	{
		buffer >> element->plim3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT2.plim4
bool assign_GovCT2_plim4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2*>(base_class_ptr))
	{
		buffer >> element->plim4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT2.plim5
bool assign_GovCT2_plim5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2*>(base_class_ptr))
	{
		buffer >> element->plim5.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT2.plim6
bool assign_GovCT2_plim6(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2*>(base_class_ptr))
	{
		buffer >> element->plim6.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT2.plim7
bool assign_GovCT2_plim7(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2*>(base_class_ptr))
	{
		buffer >> element->plim7.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT2.plim8
bool assign_GovCT2_plim8(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2*>(base_class_ptr))
	{
		buffer >> element->plim8.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT2.plim9
bool assign_GovCT2_plim9(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2*>(base_class_ptr))
	{
		buffer >> element->plim9.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT2.prate
bool assign_GovCT2_prate(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2*>(base_class_ptr))
	{
		buffer >> element->prate.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT2.r
bool assign_GovCT2_r(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2*>(base_class_ptr))
	{
		buffer >> element->r.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT2.rclose
bool assign_GovCT2_rclose(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2*>(base_class_ptr))
	{
		buffer >> element->rclose;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT2.rdown
bool assign_GovCT2_rdown(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2*>(base_class_ptr))
	{
		buffer >> element->rdown.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT2.ropen
bool assign_GovCT2_ropen(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2*>(base_class_ptr))
	{
		buffer >> element->ropen;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT2.rselect
bool assign_GovCT2_rselect(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2*>(base_class_ptr))
	{
		buffer >> element->rselect;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT2.rup
bool assign_GovCT2_rup(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2*>(base_class_ptr))
	{
		buffer >> element->rup.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT2.ta
bool assign_GovCT2_ta(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2*>(base_class_ptr))
	{
		buffer >> element->ta.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT2.tact
bool assign_GovCT2_tact(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2*>(base_class_ptr))
	{
		buffer >> element->tact.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT2.tb
bool assign_GovCT2_tb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2*>(base_class_ptr))
	{
		buffer >> element->tb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT2.tc
bool assign_GovCT2_tc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2*>(base_class_ptr))
	{
		buffer >> element->tc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT2.tdgov
bool assign_GovCT2_tdgov(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2*>(base_class_ptr))
	{
		buffer >> element->tdgov.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT2.teng
bool assign_GovCT2_teng(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2*>(base_class_ptr))
	{
		buffer >> element->teng.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT2.tfload
bool assign_GovCT2_tfload(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2*>(base_class_ptr))
	{
		buffer >> element->tfload.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT2.tpelec
bool assign_GovCT2_tpelec(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2*>(base_class_ptr))
	{
		buffer >> element->tpelec.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT2.tsa
bool assign_GovCT2_tsa(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2*>(base_class_ptr))
	{
		buffer >> element->tsa.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT2.tsb
bool assign_GovCT2_tsb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2*>(base_class_ptr))
	{
		buffer >> element->tsb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT2.vmax
bool assign_GovCT2_vmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2*>(base_class_ptr))
	{
		buffer >> element->vmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT2.vmin
bool assign_GovCT2_vmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2*>(base_class_ptr))
	{
		buffer >> element->vmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT2.wfnl
bool assign_GovCT2_wfnl(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2*>(base_class_ptr))
	{
		buffer >> element->wfnl.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovCT2.wfspd
bool assign_GovCT2_wfspd(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovCT2*>(base_class_ptr))
	{
		buffer >> element->wfspd;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST.at
bool assign_GovGAST_at(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST*>(base_class_ptr))
	{
		buffer >> element->at.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST.dturb
bool assign_GovGAST_dturb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST*>(base_class_ptr))
	{
		buffer >> element->dturb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST.kt
bool assign_GovGAST_kt(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST*>(base_class_ptr))
	{
		buffer >> element->kt.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST.mwbase
bool assign_GovGAST_mwbase(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST*>(base_class_ptr))
	{
		buffer >> element->mwbase.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST.r
bool assign_GovGAST_r(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST*>(base_class_ptr))
	{
		buffer >> element->r.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST.t1
bool assign_GovGAST_t1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST*>(base_class_ptr))
	{
		buffer >> element->t1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST.t2
bool assign_GovGAST_t2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST*>(base_class_ptr))
	{
		buffer >> element->t2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST.t3
bool assign_GovGAST_t3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST*>(base_class_ptr))
	{
		buffer >> element->t3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST.vmax
bool assign_GovGAST_vmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST*>(base_class_ptr))
	{
		buffer >> element->vmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST.vmin
bool assign_GovGAST_vmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST*>(base_class_ptr))
	{
		buffer >> element->vmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST1.a
bool assign_GovGAST1_a(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1*>(base_class_ptr))
	{
		buffer >> element->a;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST1.b
bool assign_GovGAST1_b(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1*>(base_class_ptr))
	{
		buffer >> element->b;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST1.db1
bool assign_GovGAST1_db1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1*>(base_class_ptr))
	{
		buffer >> element->db1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST1.db2
bool assign_GovGAST1_db2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1*>(base_class_ptr))
	{
		buffer >> element->db2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST1.eps
bool assign_GovGAST1_eps(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1*>(base_class_ptr))
	{
		buffer >> element->eps.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST1.fidle
bool assign_GovGAST1_fidle(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1*>(base_class_ptr))
	{
		buffer >> element->fidle.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST1.gv1
bool assign_GovGAST1_gv1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1*>(base_class_ptr))
	{
		buffer >> element->gv1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST1.gv2
bool assign_GovGAST1_gv2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1*>(base_class_ptr))
	{
		buffer >> element->gv2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST1.gv3
bool assign_GovGAST1_gv3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1*>(base_class_ptr))
	{
		buffer >> element->gv3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST1.gv4
bool assign_GovGAST1_gv4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1*>(base_class_ptr))
	{
		buffer >> element->gv4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST1.gv5
bool assign_GovGAST1_gv5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1*>(base_class_ptr))
	{
		buffer >> element->gv5.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST1.gv6
bool assign_GovGAST1_gv6(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1*>(base_class_ptr))
	{
		buffer >> element->gv6.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST1.ka
bool assign_GovGAST1_ka(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1*>(base_class_ptr))
	{
		buffer >> element->ka.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST1.kt
bool assign_GovGAST1_kt(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1*>(base_class_ptr))
	{
		buffer >> element->kt.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST1.lmax
bool assign_GovGAST1_lmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1*>(base_class_ptr))
	{
		buffer >> element->lmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST1.loadinc
bool assign_GovGAST1_loadinc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1*>(base_class_ptr))
	{
		buffer >> element->loadinc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST1.ltrate
bool assign_GovGAST1_ltrate(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1*>(base_class_ptr))
	{
		buffer >> element->ltrate;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST1.mwbase
bool assign_GovGAST1_mwbase(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1*>(base_class_ptr))
	{
		buffer >> element->mwbase.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST1.pgv1
bool assign_GovGAST1_pgv1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1*>(base_class_ptr))
	{
		buffer >> element->pgv1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST1.pgv2
bool assign_GovGAST1_pgv2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1*>(base_class_ptr))
	{
		buffer >> element->pgv2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST1.pgv3
bool assign_GovGAST1_pgv3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1*>(base_class_ptr))
	{
		buffer >> element->pgv3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST1.pgv4
bool assign_GovGAST1_pgv4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1*>(base_class_ptr))
	{
		buffer >> element->pgv4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST1.pgv5
bool assign_GovGAST1_pgv5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1*>(base_class_ptr))
	{
		buffer >> element->pgv5.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST1.pgv6
bool assign_GovGAST1_pgv6(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1*>(base_class_ptr))
	{
		buffer >> element->pgv6.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST1.r
bool assign_GovGAST1_r(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1*>(base_class_ptr))
	{
		buffer >> element->r.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST1.rmax
bool assign_GovGAST1_rmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1*>(base_class_ptr))
	{
		buffer >> element->rmax;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST1.t1
bool assign_GovGAST1_t1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1*>(base_class_ptr))
	{
		buffer >> element->t1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST1.t2
bool assign_GovGAST1_t2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1*>(base_class_ptr))
	{
		buffer >> element->t2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST1.t3
bool assign_GovGAST1_t3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1*>(base_class_ptr))
	{
		buffer >> element->t3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST1.t4
bool assign_GovGAST1_t4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1*>(base_class_ptr))
	{
		buffer >> element->t4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST1.t5
bool assign_GovGAST1_t5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1*>(base_class_ptr))
	{
		buffer >> element->t5.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST1.tltr
bool assign_GovGAST1_tltr(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1*>(base_class_ptr))
	{
		buffer >> element->tltr.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST1.vmax
bool assign_GovGAST1_vmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1*>(base_class_ptr))
	{
		buffer >> element->vmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST1.vmin
bool assign_GovGAST1_vmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST1*>(base_class_ptr))
	{
		buffer >> element->vmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST2.a
bool assign_GovGAST2_a(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2*>(base_class_ptr))
	{
		buffer >> element->a;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST2.af1
bool assign_GovGAST2_af1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2*>(base_class_ptr))
	{
		buffer >> element->af1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST2.af2
bool assign_GovGAST2_af2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2*>(base_class_ptr))
	{
		buffer >> element->af2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST2.b
bool assign_GovGAST2_b(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2*>(base_class_ptr))
	{
		buffer >> element->b;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST2.bf1
bool assign_GovGAST2_bf1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2*>(base_class_ptr))
	{
		buffer >> element->bf1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST2.bf2
bool assign_GovGAST2_bf2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2*>(base_class_ptr))
	{
		buffer >> element->bf2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST2.c
bool assign_GovGAST2_c(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2*>(base_class_ptr))
	{
		buffer >> element->c;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST2.cf2
bool assign_GovGAST2_cf2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2*>(base_class_ptr))
	{
		buffer >> element->cf2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST2.ecr
bool assign_GovGAST2_ecr(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2*>(base_class_ptr))
	{
		buffer >> element->ecr.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST2.etd
bool assign_GovGAST2_etd(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2*>(base_class_ptr))
	{
		buffer >> element->etd.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST2.k3
bool assign_GovGAST2_k3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2*>(base_class_ptr))
	{
		buffer >> element->k3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST2.k4
bool assign_GovGAST2_k4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2*>(base_class_ptr))
	{
		buffer >> element->k4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST2.k5
bool assign_GovGAST2_k5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2*>(base_class_ptr))
	{
		buffer >> element->k5.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST2.k6
bool assign_GovGAST2_k6(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2*>(base_class_ptr))
	{
		buffer >> element->k6.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST2.kf
bool assign_GovGAST2_kf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2*>(base_class_ptr))
	{
		buffer >> element->kf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST2.mwbase
bool assign_GovGAST2_mwbase(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2*>(base_class_ptr))
	{
		buffer >> element->mwbase.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST2.t
bool assign_GovGAST2_t(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2*>(base_class_ptr))
	{
		buffer >> element->t.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST2.t3
bool assign_GovGAST2_t3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2*>(base_class_ptr))
	{
		buffer >> element->t3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST2.t4
bool assign_GovGAST2_t4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2*>(base_class_ptr))
	{
		buffer >> element->t4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST2.t5
bool assign_GovGAST2_t5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2*>(base_class_ptr))
	{
		buffer >> element->t5.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST2.tc
bool assign_GovGAST2_tc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2*>(base_class_ptr))
	{
		buffer >> element->tc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST2.tcd
bool assign_GovGAST2_tcd(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2*>(base_class_ptr))
	{
		buffer >> element->tcd.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST2.tf
bool assign_GovGAST2_tf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2*>(base_class_ptr))
	{
		buffer >> element->tf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST2.tmax
bool assign_GovGAST2_tmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2*>(base_class_ptr))
	{
		buffer >> element->tmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST2.tmin
bool assign_GovGAST2_tmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2*>(base_class_ptr))
	{
		buffer >> element->tmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST2.tr
bool assign_GovGAST2_tr(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2*>(base_class_ptr))
	{
		buffer >> element->tr.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST2.trate
bool assign_GovGAST2_trate(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2*>(base_class_ptr))
	{
		buffer >> element->trate.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST2.tt
bool assign_GovGAST2_tt(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2*>(base_class_ptr))
	{
		buffer >> element->tt.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST2.w
bool assign_GovGAST2_w(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2*>(base_class_ptr))
	{
		buffer >> element->w.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST2.x
bool assign_GovGAST2_x(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2*>(base_class_ptr))
	{
		buffer >> element->x.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST2.y
bool assign_GovGAST2_y(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2*>(base_class_ptr))
	{
		buffer >> element->y.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST2.z
bool assign_GovGAST2_z(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST2*>(base_class_ptr))
	{
		buffer >> element->z;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST3.bca
bool assign_GovGAST3_bca(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST3*>(base_class_ptr))
	{
		buffer >> element->bca;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST3.bp
bool assign_GovGAST3_bp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST3*>(base_class_ptr))
	{
		buffer >> element->bp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST3.dtc
bool assign_GovGAST3_dtc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST3*>(base_class_ptr))
	{
		buffer >> element->dtc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST3.ka
bool assign_GovGAST3_ka(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST3*>(base_class_ptr))
	{
		buffer >> element->ka.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST3.kac
bool assign_GovGAST3_kac(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST3*>(base_class_ptr))
	{
		buffer >> element->kac;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST3.kca
bool assign_GovGAST3_kca(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST3*>(base_class_ptr))
	{
		buffer >> element->kca;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST3.ksi
bool assign_GovGAST3_ksi(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST3*>(base_class_ptr))
	{
		buffer >> element->ksi;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST3.ky
bool assign_GovGAST3_ky(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST3*>(base_class_ptr))
	{
		buffer >> element->ky;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST3.mnef
bool assign_GovGAST3_mnef(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST3*>(base_class_ptr))
	{
		buffer >> element->mnef.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST3.mxef
bool assign_GovGAST3_mxef(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST3*>(base_class_ptr))
	{
		buffer >> element->mxef.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST3.rcmn
bool assign_GovGAST3_rcmn(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST3*>(base_class_ptr))
	{
		buffer >> element->rcmn.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST3.rcmx
bool assign_GovGAST3_rcmx(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST3*>(base_class_ptr))
	{
		buffer >> element->rcmx.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST3.tac
bool assign_GovGAST3_tac(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST3*>(base_class_ptr))
	{
		buffer >> element->tac.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST3.tc
bool assign_GovGAST3_tc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST3*>(base_class_ptr))
	{
		buffer >> element->tc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST3.td
bool assign_GovGAST3_td(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST3*>(base_class_ptr))
	{
		buffer >> element->td.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST3.tfen
bool assign_GovGAST3_tfen(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST3*>(base_class_ptr))
	{
		buffer >> element->tfen.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST3.tg
bool assign_GovGAST3_tg(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST3*>(base_class_ptr))
	{
		buffer >> element->tg.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST3.tsi
bool assign_GovGAST3_tsi(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST3*>(base_class_ptr))
	{
		buffer >> element->tsi.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST3.tt
bool assign_GovGAST3_tt(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST3*>(base_class_ptr))
	{
		buffer >> element->tt.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST3.ttc
bool assign_GovGAST3_ttc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST3*>(base_class_ptr))
	{
		buffer >> element->ttc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST3.ty
bool assign_GovGAST3_ty(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST3*>(base_class_ptr))
	{
		buffer >> element->ty.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST4.bp
bool assign_GovGAST4_bp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST4*>(base_class_ptr))
	{
		buffer >> element->bp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST4.ktm
bool assign_GovGAST4_ktm(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST4*>(base_class_ptr))
	{
		buffer >> element->ktm.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST4.mnef
bool assign_GovGAST4_mnef(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST4*>(base_class_ptr))
	{
		buffer >> element->mnef.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST4.mxef
bool assign_GovGAST4_mxef(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST4*>(base_class_ptr))
	{
		buffer >> element->mxef.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST4.rymn
bool assign_GovGAST4_rymn(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST4*>(base_class_ptr))
	{
		buffer >> element->rymn.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST4.rymx
bool assign_GovGAST4_rymx(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST4*>(base_class_ptr))
	{
		buffer >> element->rymx.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST4.ta
bool assign_GovGAST4_ta(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST4*>(base_class_ptr))
	{
		buffer >> element->ta.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST4.tc
bool assign_GovGAST4_tc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST4*>(base_class_ptr))
	{
		buffer >> element->tc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST4.tcm
bool assign_GovGAST4_tcm(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST4*>(base_class_ptr))
	{
		buffer >> element->tcm.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST4.tm
bool assign_GovGAST4_tm(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST4*>(base_class_ptr))
	{
		buffer >> element->tm.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGAST4.tv
bool assign_GovGAST4_tv(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGAST4*>(base_class_ptr))
	{
		buffer >> element->tv.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGASTWD.a
bool assign_GovGASTWD_a(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD*>(base_class_ptr))
	{
		buffer >> element->a;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGASTWD.af1
bool assign_GovGASTWD_af1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD*>(base_class_ptr))
	{
		buffer >> element->af1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGASTWD.af2
bool assign_GovGASTWD_af2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD*>(base_class_ptr))
	{
		buffer >> element->af2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGASTWD.b
bool assign_GovGASTWD_b(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD*>(base_class_ptr))
	{
		buffer >> element->b;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGASTWD.bf1
bool assign_GovGASTWD_bf1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD*>(base_class_ptr))
	{
		buffer >> element->bf1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGASTWD.bf2
bool assign_GovGASTWD_bf2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD*>(base_class_ptr))
	{
		buffer >> element->bf2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGASTWD.c
bool assign_GovGASTWD_c(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD*>(base_class_ptr))
	{
		buffer >> element->c;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGASTWD.cf2
bool assign_GovGASTWD_cf2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD*>(base_class_ptr))
	{
		buffer >> element->cf2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGASTWD.ecr
bool assign_GovGASTWD_ecr(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD*>(base_class_ptr))
	{
		buffer >> element->ecr.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGASTWD.etd
bool assign_GovGASTWD_etd(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD*>(base_class_ptr))
	{
		buffer >> element->etd.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGASTWD.k3
bool assign_GovGASTWD_k3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD*>(base_class_ptr))
	{
		buffer >> element->k3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGASTWD.k4
bool assign_GovGASTWD_k4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD*>(base_class_ptr))
	{
		buffer >> element->k4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGASTWD.k5
bool assign_GovGASTWD_k5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD*>(base_class_ptr))
	{
		buffer >> element->k5.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGASTWD.k6
bool assign_GovGASTWD_k6(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD*>(base_class_ptr))
	{
		buffer >> element->k6.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGASTWD.kd
bool assign_GovGASTWD_kd(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD*>(base_class_ptr))
	{
		buffer >> element->kd.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGASTWD.kdroop
bool assign_GovGASTWD_kdroop(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD*>(base_class_ptr))
	{
		buffer >> element->kdroop.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGASTWD.kf
bool assign_GovGASTWD_kf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD*>(base_class_ptr))
	{
		buffer >> element->kf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGASTWD.ki
bool assign_GovGASTWD_ki(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD*>(base_class_ptr))
	{
		buffer >> element->ki.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGASTWD.kp
bool assign_GovGASTWD_kp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD*>(base_class_ptr))
	{
		buffer >> element->kp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGASTWD.mwbase
bool assign_GovGASTWD_mwbase(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD*>(base_class_ptr))
	{
		buffer >> element->mwbase.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGASTWD.t
bool assign_GovGASTWD_t(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD*>(base_class_ptr))
	{
		buffer >> element->t.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGASTWD.t3
bool assign_GovGASTWD_t3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD*>(base_class_ptr))
	{
		buffer >> element->t3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGASTWD.t4
bool assign_GovGASTWD_t4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD*>(base_class_ptr))
	{
		buffer >> element->t4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGASTWD.t5
bool assign_GovGASTWD_t5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD*>(base_class_ptr))
	{
		buffer >> element->t5.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGASTWD.tc
bool assign_GovGASTWD_tc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD*>(base_class_ptr))
	{
		buffer >> element->tc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGASTWD.tcd
bool assign_GovGASTWD_tcd(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD*>(base_class_ptr))
	{
		buffer >> element->tcd.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGASTWD.td
bool assign_GovGASTWD_td(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD*>(base_class_ptr))
	{
		buffer >> element->td.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGASTWD.tf
bool assign_GovGASTWD_tf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD*>(base_class_ptr))
	{
		buffer >> element->tf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGASTWD.tmax
bool assign_GovGASTWD_tmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD*>(base_class_ptr))
	{
		buffer >> element->tmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGASTWD.tmin
bool assign_GovGASTWD_tmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD*>(base_class_ptr))
	{
		buffer >> element->tmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGASTWD.tr
bool assign_GovGASTWD_tr(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD*>(base_class_ptr))
	{
		buffer >> element->tr.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGASTWD.trate
bool assign_GovGASTWD_trate(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD*>(base_class_ptr))
	{
		buffer >> element->trate.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovGASTWD.tt
bool assign_GovGASTWD_tt(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovGASTWD*>(base_class_ptr))
	{
		buffer >> element->tt.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro1.at
bool assign_GovHydro1_at(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro1*>(base_class_ptr))
	{
		buffer >> element->at.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro1.dturb
bool assign_GovHydro1_dturb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro1*>(base_class_ptr))
	{
		buffer >> element->dturb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro1.gmax
bool assign_GovHydro1_gmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro1*>(base_class_ptr))
	{
		buffer >> element->gmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro1.gmin
bool assign_GovHydro1_gmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro1*>(base_class_ptr))
	{
		buffer >> element->gmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro1.hdam
bool assign_GovHydro1_hdam(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro1*>(base_class_ptr))
	{
		buffer >> element->hdam.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro1.mwbase
bool assign_GovHydro1_mwbase(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro1*>(base_class_ptr))
	{
		buffer >> element->mwbase.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro1.qnl
bool assign_GovHydro1_qnl(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro1*>(base_class_ptr))
	{
		buffer >> element->qnl.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro1.rperm
bool assign_GovHydro1_rperm(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro1*>(base_class_ptr))
	{
		buffer >> element->rperm.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro1.rtemp
bool assign_GovHydro1_rtemp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro1*>(base_class_ptr))
	{
		buffer >> element->rtemp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro1.tf
bool assign_GovHydro1_tf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro1*>(base_class_ptr))
	{
		buffer >> element->tf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro1.tg
bool assign_GovHydro1_tg(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro1*>(base_class_ptr))
	{
		buffer >> element->tg.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro1.tr
bool assign_GovHydro1_tr(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro1*>(base_class_ptr))
	{
		buffer >> element->tr.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro1.tw
bool assign_GovHydro1_tw(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro1*>(base_class_ptr))
	{
		buffer >> element->tw.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro1.velm
bool assign_GovHydro1_velm(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro1*>(base_class_ptr))
	{
		buffer >> element->velm;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro2.aturb
bool assign_GovHydro2_aturb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro2*>(base_class_ptr))
	{
		buffer >> element->aturb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro2.bturb
bool assign_GovHydro2_bturb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro2*>(base_class_ptr))
	{
		buffer >> element->bturb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro2.db1
bool assign_GovHydro2_db1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro2*>(base_class_ptr))
	{
		buffer >> element->db1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro2.db2
bool assign_GovHydro2_db2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro2*>(base_class_ptr))
	{
		buffer >> element->db2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro2.eps
bool assign_GovHydro2_eps(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro2*>(base_class_ptr))
	{
		buffer >> element->eps.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro2.gv1
bool assign_GovHydro2_gv1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro2*>(base_class_ptr))
	{
		buffer >> element->gv1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro2.gv2
bool assign_GovHydro2_gv2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro2*>(base_class_ptr))
	{
		buffer >> element->gv2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro2.gv3
bool assign_GovHydro2_gv3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro2*>(base_class_ptr))
	{
		buffer >> element->gv3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro2.gv4
bool assign_GovHydro2_gv4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro2*>(base_class_ptr))
	{
		buffer >> element->gv4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro2.gv5
bool assign_GovHydro2_gv5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro2*>(base_class_ptr))
	{
		buffer >> element->gv5.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro2.gv6
bool assign_GovHydro2_gv6(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro2*>(base_class_ptr))
	{
		buffer >> element->gv6.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro2.kturb
bool assign_GovHydro2_kturb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro2*>(base_class_ptr))
	{
		buffer >> element->kturb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro2.mwbase
bool assign_GovHydro2_mwbase(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro2*>(base_class_ptr))
	{
		buffer >> element->mwbase.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro2.pgv1
bool assign_GovHydro2_pgv1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro2*>(base_class_ptr))
	{
		buffer >> element->pgv1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro2.pgv2
bool assign_GovHydro2_pgv2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro2*>(base_class_ptr))
	{
		buffer >> element->pgv2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro2.pgv3
bool assign_GovHydro2_pgv3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro2*>(base_class_ptr))
	{
		buffer >> element->pgv3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro2.pgv4
bool assign_GovHydro2_pgv4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro2*>(base_class_ptr))
	{
		buffer >> element->pgv4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro2.pgv5
bool assign_GovHydro2_pgv5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro2*>(base_class_ptr))
	{
		buffer >> element->pgv5.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro2.pgv6
bool assign_GovHydro2_pgv6(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro2*>(base_class_ptr))
	{
		buffer >> element->pgv6.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro2.pmax
bool assign_GovHydro2_pmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro2*>(base_class_ptr))
	{
		buffer >> element->pmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro2.pmin
bool assign_GovHydro2_pmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro2*>(base_class_ptr))
	{
		buffer >> element->pmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro2.rperm
bool assign_GovHydro2_rperm(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro2*>(base_class_ptr))
	{
		buffer >> element->rperm.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro2.rtemp
bool assign_GovHydro2_rtemp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro2*>(base_class_ptr))
	{
		buffer >> element->rtemp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro2.tg
bool assign_GovHydro2_tg(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro2*>(base_class_ptr))
	{
		buffer >> element->tg.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro2.tp
bool assign_GovHydro2_tp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro2*>(base_class_ptr))
	{
		buffer >> element->tp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro2.tr
bool assign_GovHydro2_tr(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro2*>(base_class_ptr))
	{
		buffer >> element->tr.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro2.tw
bool assign_GovHydro2_tw(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro2*>(base_class_ptr))
	{
		buffer >> element->tw.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro2.uc
bool assign_GovHydro2_uc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro2*>(base_class_ptr))
	{
		buffer >> element->uc;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro2.uo
bool assign_GovHydro2_uo(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro2*>(base_class_ptr))
	{
		buffer >> element->uo;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro3.at
bool assign_GovHydro3_at(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3*>(base_class_ptr))
	{
		buffer >> element->at.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro3.db1
bool assign_GovHydro3_db1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3*>(base_class_ptr))
	{
		buffer >> element->db1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro3.db2
bool assign_GovHydro3_db2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3*>(base_class_ptr))
	{
		buffer >> element->db2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro3.dturb
bool assign_GovHydro3_dturb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3*>(base_class_ptr))
	{
		buffer >> element->dturb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro3.eps
bool assign_GovHydro3_eps(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3*>(base_class_ptr))
	{
		buffer >> element->eps.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro3.governorControl
bool assign_GovHydro3_governorControl(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3*>(base_class_ptr))
	{
		buffer >> element->governorControl;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro3.gv1
bool assign_GovHydro3_gv1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3*>(base_class_ptr))
	{
		buffer >> element->gv1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro3.gv2
bool assign_GovHydro3_gv2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3*>(base_class_ptr))
	{
		buffer >> element->gv2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro3.gv3
bool assign_GovHydro3_gv3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3*>(base_class_ptr))
	{
		buffer >> element->gv3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro3.gv4
bool assign_GovHydro3_gv4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3*>(base_class_ptr))
	{
		buffer >> element->gv4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro3.gv5
bool assign_GovHydro3_gv5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3*>(base_class_ptr))
	{
		buffer >> element->gv5.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro3.gv6
bool assign_GovHydro3_gv6(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3*>(base_class_ptr))
	{
		buffer >> element->gv6.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro3.h0
bool assign_GovHydro3_h0(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3*>(base_class_ptr))
	{
		buffer >> element->h0.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro3.k1
bool assign_GovHydro3_k1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3*>(base_class_ptr))
	{
		buffer >> element->k1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro3.k2
bool assign_GovHydro3_k2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3*>(base_class_ptr))
	{
		buffer >> element->k2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro3.kg
bool assign_GovHydro3_kg(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3*>(base_class_ptr))
	{
		buffer >> element->kg.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro3.ki
bool assign_GovHydro3_ki(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3*>(base_class_ptr))
	{
		buffer >> element->ki.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro3.mwbase
bool assign_GovHydro3_mwbase(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3*>(base_class_ptr))
	{
		buffer >> element->mwbase.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro3.pgv1
bool assign_GovHydro3_pgv1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3*>(base_class_ptr))
	{
		buffer >> element->pgv1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro3.pgv2
bool assign_GovHydro3_pgv2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3*>(base_class_ptr))
	{
		buffer >> element->pgv2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro3.pgv3
bool assign_GovHydro3_pgv3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3*>(base_class_ptr))
	{
		buffer >> element->pgv3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro3.pgv4
bool assign_GovHydro3_pgv4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3*>(base_class_ptr))
	{
		buffer >> element->pgv4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro3.pgv5
bool assign_GovHydro3_pgv5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3*>(base_class_ptr))
	{
		buffer >> element->pgv5.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro3.pgv6
bool assign_GovHydro3_pgv6(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3*>(base_class_ptr))
	{
		buffer >> element->pgv6.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro3.pmax
bool assign_GovHydro3_pmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3*>(base_class_ptr))
	{
		buffer >> element->pmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro3.pmin
bool assign_GovHydro3_pmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3*>(base_class_ptr))
	{
		buffer >> element->pmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro3.qnl
bool assign_GovHydro3_qnl(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3*>(base_class_ptr))
	{
		buffer >> element->qnl.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro3.relec
bool assign_GovHydro3_relec(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3*>(base_class_ptr))
	{
		buffer >> element->relec.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro3.rgate
bool assign_GovHydro3_rgate(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3*>(base_class_ptr))
	{
		buffer >> element->rgate.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro3.td
bool assign_GovHydro3_td(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3*>(base_class_ptr))
	{
		buffer >> element->td.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro3.tf
bool assign_GovHydro3_tf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3*>(base_class_ptr))
	{
		buffer >> element->tf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro3.tp
bool assign_GovHydro3_tp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3*>(base_class_ptr))
	{
		buffer >> element->tp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro3.tt
bool assign_GovHydro3_tt(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3*>(base_class_ptr))
	{
		buffer >> element->tt.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro3.tw
bool assign_GovHydro3_tw(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3*>(base_class_ptr))
	{
		buffer >> element->tw.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro3.velcl
bool assign_GovHydro3_velcl(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3*>(base_class_ptr))
	{
		buffer >> element->velcl;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro3.velop
bool assign_GovHydro3_velop(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro3*>(base_class_ptr))
	{
		buffer >> element->velop;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro4.at
bool assign_GovHydro4_at(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4*>(base_class_ptr))
	{
		buffer >> element->at.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro4.bgv0
bool assign_GovHydro4_bgv0(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4*>(base_class_ptr))
	{
		buffer >> element->bgv0.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro4.bgv1
bool assign_GovHydro4_bgv1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4*>(base_class_ptr))
	{
		buffer >> element->bgv1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro4.bgv2
bool assign_GovHydro4_bgv2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4*>(base_class_ptr))
	{
		buffer >> element->bgv2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro4.bgv3
bool assign_GovHydro4_bgv3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4*>(base_class_ptr))
	{
		buffer >> element->bgv3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro4.bgv4
bool assign_GovHydro4_bgv4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4*>(base_class_ptr))
	{
		buffer >> element->bgv4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro4.bgv5
bool assign_GovHydro4_bgv5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4*>(base_class_ptr))
	{
		buffer >> element->bgv5.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro4.bmax
bool assign_GovHydro4_bmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4*>(base_class_ptr))
	{
		buffer >> element->bmax;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro4.db1
bool assign_GovHydro4_db1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4*>(base_class_ptr))
	{
		buffer >> element->db1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro4.db2
bool assign_GovHydro4_db2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4*>(base_class_ptr))
	{
		buffer >> element->db2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro4.dturb
bool assign_GovHydro4_dturb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4*>(base_class_ptr))
	{
		buffer >> element->dturb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro4.eps
bool assign_GovHydro4_eps(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4*>(base_class_ptr))
	{
		buffer >> element->eps.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro4.gmax
bool assign_GovHydro4_gmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4*>(base_class_ptr))
	{
		buffer >> element->gmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro4.gmin
bool assign_GovHydro4_gmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4*>(base_class_ptr))
	{
		buffer >> element->gmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro4.gv0
bool assign_GovHydro4_gv0(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4*>(base_class_ptr))
	{
		buffer >> element->gv0.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro4.gv1
bool assign_GovHydro4_gv1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4*>(base_class_ptr))
	{
		buffer >> element->gv1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro4.gv2
bool assign_GovHydro4_gv2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4*>(base_class_ptr))
	{
		buffer >> element->gv2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro4.gv3
bool assign_GovHydro4_gv3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4*>(base_class_ptr))
	{
		buffer >> element->gv3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro4.gv4
bool assign_GovHydro4_gv4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4*>(base_class_ptr))
	{
		buffer >> element->gv4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro4.gv5
bool assign_GovHydro4_gv5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4*>(base_class_ptr))
	{
		buffer >> element->gv5.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro4.hdam
bool assign_GovHydro4_hdam(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4*>(base_class_ptr))
	{
		buffer >> element->hdam.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro4.mwbase
bool assign_GovHydro4_mwbase(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4*>(base_class_ptr))
	{
		buffer >> element->mwbase.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro4.pgv0
bool assign_GovHydro4_pgv0(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4*>(base_class_ptr))
	{
		buffer >> element->pgv0.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro4.pgv1
bool assign_GovHydro4_pgv1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4*>(base_class_ptr))
	{
		buffer >> element->pgv1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro4.pgv2
bool assign_GovHydro4_pgv2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4*>(base_class_ptr))
	{
		buffer >> element->pgv2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro4.pgv3
bool assign_GovHydro4_pgv3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4*>(base_class_ptr))
	{
		buffer >> element->pgv3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro4.pgv4
bool assign_GovHydro4_pgv4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4*>(base_class_ptr))
	{
		buffer >> element->pgv4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro4.pgv5
bool assign_GovHydro4_pgv5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4*>(base_class_ptr))
	{
		buffer >> element->pgv5.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro4.qn1
bool assign_GovHydro4_qn1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4*>(base_class_ptr))
	{
		buffer >> element->qn1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro4.rperm
bool assign_GovHydro4_rperm(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4*>(base_class_ptr))
	{
		buffer >> element->rperm.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro4.rtemp
bool assign_GovHydro4_rtemp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4*>(base_class_ptr))
	{
		buffer >> element->rtemp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro4.tblade
bool assign_GovHydro4_tblade(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4*>(base_class_ptr))
	{
		buffer >> element->tblade.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro4.tg
bool assign_GovHydro4_tg(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4*>(base_class_ptr))
	{
		buffer >> element->tg.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro4.tp
bool assign_GovHydro4_tp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4*>(base_class_ptr))
	{
		buffer >> element->tp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro4.tr
bool assign_GovHydro4_tr(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4*>(base_class_ptr))
	{
		buffer >> element->tr.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro4.tw
bool assign_GovHydro4_tw(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4*>(base_class_ptr))
	{
		buffer >> element->tw.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro4.uc
bool assign_GovHydro4_uc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4*>(base_class_ptr))
	{
		buffer >> element->uc;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydro4.uo
bool assign_GovHydro4_uo(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydro4*>(base_class_ptr))
	{
		buffer >> element->uo;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroDD.aturb
bool assign_GovHydroDD_aturb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD*>(base_class_ptr))
	{
		buffer >> element->aturb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroDD.bturb
bool assign_GovHydroDD_bturb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD*>(base_class_ptr))
	{
		buffer >> element->bturb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroDD.db1
bool assign_GovHydroDD_db1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD*>(base_class_ptr))
	{
		buffer >> element->db1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroDD.db2
bool assign_GovHydroDD_db2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD*>(base_class_ptr))
	{
		buffer >> element->db2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroDD.eps
bool assign_GovHydroDD_eps(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD*>(base_class_ptr))
	{
		buffer >> element->eps.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroDD.gmax
bool assign_GovHydroDD_gmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD*>(base_class_ptr))
	{
		buffer >> element->gmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroDD.gmin
bool assign_GovHydroDD_gmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD*>(base_class_ptr))
	{
		buffer >> element->gmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroDD.gv1
bool assign_GovHydroDD_gv1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD*>(base_class_ptr))
	{
		buffer >> element->gv1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroDD.gv2
bool assign_GovHydroDD_gv2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD*>(base_class_ptr))
	{
		buffer >> element->gv2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroDD.gv3
bool assign_GovHydroDD_gv3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD*>(base_class_ptr))
	{
		buffer >> element->gv3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroDD.gv4
bool assign_GovHydroDD_gv4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD*>(base_class_ptr))
	{
		buffer >> element->gv4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroDD.gv5
bool assign_GovHydroDD_gv5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD*>(base_class_ptr))
	{
		buffer >> element->gv5.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroDD.gv6
bool assign_GovHydroDD_gv6(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD*>(base_class_ptr))
	{
		buffer >> element->gv6.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroDD.inputSignal
bool assign_GovHydroDD_inputSignal(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD*>(base_class_ptr))
	{
		buffer >> element->inputSignal;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroDD.k1
bool assign_GovHydroDD_k1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD*>(base_class_ptr))
	{
		buffer >> element->k1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroDD.k2
bool assign_GovHydroDD_k2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD*>(base_class_ptr))
	{
		buffer >> element->k2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroDD.kg
bool assign_GovHydroDD_kg(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD*>(base_class_ptr))
	{
		buffer >> element->kg.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroDD.ki
bool assign_GovHydroDD_ki(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD*>(base_class_ptr))
	{
		buffer >> element->ki.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroDD.mwbase
bool assign_GovHydroDD_mwbase(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD*>(base_class_ptr))
	{
		buffer >> element->mwbase.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroDD.pgv1
bool assign_GovHydroDD_pgv1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD*>(base_class_ptr))
	{
		buffer >> element->pgv1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroDD.pgv2
bool assign_GovHydroDD_pgv2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD*>(base_class_ptr))
	{
		buffer >> element->pgv2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroDD.pgv3
bool assign_GovHydroDD_pgv3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD*>(base_class_ptr))
	{
		buffer >> element->pgv3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroDD.pgv4
bool assign_GovHydroDD_pgv4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD*>(base_class_ptr))
	{
		buffer >> element->pgv4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroDD.pgv5
bool assign_GovHydroDD_pgv5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD*>(base_class_ptr))
	{
		buffer >> element->pgv5.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroDD.pgv6
bool assign_GovHydroDD_pgv6(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD*>(base_class_ptr))
	{
		buffer >> element->pgv6.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroDD.pmax
bool assign_GovHydroDD_pmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD*>(base_class_ptr))
	{
		buffer >> element->pmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroDD.pmin
bool assign_GovHydroDD_pmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD*>(base_class_ptr))
	{
		buffer >> element->pmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroDD.r
bool assign_GovHydroDD_r(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD*>(base_class_ptr))
	{
		buffer >> element->r.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroDD.td
bool assign_GovHydroDD_td(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD*>(base_class_ptr))
	{
		buffer >> element->td.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroDD.tf
bool assign_GovHydroDD_tf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD*>(base_class_ptr))
	{
		buffer >> element->tf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroDD.tp
bool assign_GovHydroDD_tp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD*>(base_class_ptr))
	{
		buffer >> element->tp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroDD.tt
bool assign_GovHydroDD_tt(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD*>(base_class_ptr))
	{
		buffer >> element->tt.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroDD.tturb
bool assign_GovHydroDD_tturb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD*>(base_class_ptr))
	{
		buffer >> element->tturb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroDD.velcl
bool assign_GovHydroDD_velcl(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD*>(base_class_ptr))
	{
		buffer >> element->velcl;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroDD.velop
bool assign_GovHydroDD_velop(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroDD*>(base_class_ptr))
	{
		buffer >> element->velop;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroFrancis.am
bool assign_GovHydroFrancis_am(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroFrancis* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroFrancis*>(base_class_ptr))
	{
		buffer >> element->am.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroFrancis.av0
bool assign_GovHydroFrancis_av0(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroFrancis* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroFrancis*>(base_class_ptr))
	{
		buffer >> element->av0.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroFrancis.av1
bool assign_GovHydroFrancis_av1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroFrancis* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroFrancis*>(base_class_ptr))
	{
		buffer >> element->av1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroFrancis.bp
bool assign_GovHydroFrancis_bp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroFrancis* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroFrancis*>(base_class_ptr))
	{
		buffer >> element->bp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroFrancis.db1
bool assign_GovHydroFrancis_db1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroFrancis* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroFrancis*>(base_class_ptr))
	{
		buffer >> element->db1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroFrancis.etamax
bool assign_GovHydroFrancis_etamax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroFrancis* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroFrancis*>(base_class_ptr))
	{
		buffer >> element->etamax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroFrancis.governorControl
bool assign_GovHydroFrancis_governorControl(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroFrancis* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroFrancis*>(base_class_ptr))
	{
		buffer >> element->governorControl;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroFrancis.h1
bool assign_GovHydroFrancis_h1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroFrancis* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroFrancis*>(base_class_ptr))
	{
		buffer >> element->h1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroFrancis.h2
bool assign_GovHydroFrancis_h2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroFrancis* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroFrancis*>(base_class_ptr))
	{
		buffer >> element->h2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroFrancis.hn
bool assign_GovHydroFrancis_hn(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroFrancis* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroFrancis*>(base_class_ptr))
	{
		buffer >> element->hn.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroFrancis.kc
bool assign_GovHydroFrancis_kc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroFrancis* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroFrancis*>(base_class_ptr))
	{
		buffer >> element->kc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroFrancis.kg
bool assign_GovHydroFrancis_kg(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroFrancis* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroFrancis*>(base_class_ptr))
	{
		buffer >> element->kg.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroFrancis.kt
bool assign_GovHydroFrancis_kt(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroFrancis* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroFrancis*>(base_class_ptr))
	{
		buffer >> element->kt.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroFrancis.qc0
bool assign_GovHydroFrancis_qc0(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroFrancis* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroFrancis*>(base_class_ptr))
	{
		buffer >> element->qc0.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroFrancis.qn
bool assign_GovHydroFrancis_qn(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroFrancis* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroFrancis*>(base_class_ptr))
	{
		buffer >> element->qn.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroFrancis.ta
bool assign_GovHydroFrancis_ta(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroFrancis* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroFrancis*>(base_class_ptr))
	{
		buffer >> element->ta.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroFrancis.td
bool assign_GovHydroFrancis_td(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroFrancis* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroFrancis*>(base_class_ptr))
	{
		buffer >> element->td.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroFrancis.ts
bool assign_GovHydroFrancis_ts(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroFrancis* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroFrancis*>(base_class_ptr))
	{
		buffer >> element->ts.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroFrancis.twnc
bool assign_GovHydroFrancis_twnc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroFrancis* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroFrancis*>(base_class_ptr))
	{
		buffer >> element->twnc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroFrancis.twng
bool assign_GovHydroFrancis_twng(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroFrancis* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroFrancis*>(base_class_ptr))
	{
		buffer >> element->twng.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroFrancis.tx
bool assign_GovHydroFrancis_tx(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroFrancis* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroFrancis*>(base_class_ptr))
	{
		buffer >> element->tx.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroFrancis.va
bool assign_GovHydroFrancis_va(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroFrancis* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroFrancis*>(base_class_ptr))
	{
		buffer >> element->va;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroFrancis.valvmax
bool assign_GovHydroFrancis_valvmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroFrancis* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroFrancis*>(base_class_ptr))
	{
		buffer >> element->valvmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroFrancis.valvmin
bool assign_GovHydroFrancis_valvmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroFrancis* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroFrancis*>(base_class_ptr))
	{
		buffer >> element->valvmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroFrancis.vc
bool assign_GovHydroFrancis_vc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroFrancis* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroFrancis*>(base_class_ptr))
	{
		buffer >> element->vc;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroFrancis.waterTunnelSurgeChamberSimulation
bool assign_GovHydroFrancis_waterTunnelSurgeChamberSimulation(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroFrancis* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroFrancis*>(base_class_ptr))
	{
		buffer >> element->waterTunnelSurgeChamberSimulation;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroFrancis.zsfc
bool assign_GovHydroFrancis_zsfc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroFrancis* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroFrancis*>(base_class_ptr))
	{
		buffer >> element->zsfc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroIEEE0.k
bool assign_GovHydroIEEE0_k(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE0* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE0*>(base_class_ptr))
	{
		buffer >> element->k.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroIEEE0.mwbase
bool assign_GovHydroIEEE0_mwbase(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE0* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE0*>(base_class_ptr))
	{
		buffer >> element->mwbase.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroIEEE0.pmax
bool assign_GovHydroIEEE0_pmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE0* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE0*>(base_class_ptr))
	{
		buffer >> element->pmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroIEEE0.pmin
bool assign_GovHydroIEEE0_pmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE0* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE0*>(base_class_ptr))
	{
		buffer >> element->pmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroIEEE0.t1
bool assign_GovHydroIEEE0_t1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE0* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE0*>(base_class_ptr))
	{
		buffer >> element->t1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroIEEE0.t2
bool assign_GovHydroIEEE0_t2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE0* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE0*>(base_class_ptr))
	{
		buffer >> element->t2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroIEEE0.t3
bool assign_GovHydroIEEE0_t3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE0* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE0*>(base_class_ptr))
	{
		buffer >> element->t3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroIEEE0.t4
bool assign_GovHydroIEEE0_t4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE0* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE0*>(base_class_ptr))
	{
		buffer >> element->t4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroIEEE2.aturb
bool assign_GovHydroIEEE2_aturb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE2*>(base_class_ptr))
	{
		buffer >> element->aturb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroIEEE2.bturb
bool assign_GovHydroIEEE2_bturb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE2*>(base_class_ptr))
	{
		buffer >> element->bturb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroIEEE2.gv1
bool assign_GovHydroIEEE2_gv1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE2*>(base_class_ptr))
	{
		buffer >> element->gv1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroIEEE2.gv2
bool assign_GovHydroIEEE2_gv2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE2*>(base_class_ptr))
	{
		buffer >> element->gv2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroIEEE2.gv3
bool assign_GovHydroIEEE2_gv3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE2*>(base_class_ptr))
	{
		buffer >> element->gv3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroIEEE2.gv4
bool assign_GovHydroIEEE2_gv4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE2*>(base_class_ptr))
	{
		buffer >> element->gv4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroIEEE2.gv5
bool assign_GovHydroIEEE2_gv5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE2*>(base_class_ptr))
	{
		buffer >> element->gv5.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroIEEE2.gv6
bool assign_GovHydroIEEE2_gv6(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE2*>(base_class_ptr))
	{
		buffer >> element->gv6.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroIEEE2.kturb
bool assign_GovHydroIEEE2_kturb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE2*>(base_class_ptr))
	{
		buffer >> element->kturb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroIEEE2.mwbase
bool assign_GovHydroIEEE2_mwbase(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE2*>(base_class_ptr))
	{
		buffer >> element->mwbase.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroIEEE2.pgv1
bool assign_GovHydroIEEE2_pgv1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE2*>(base_class_ptr))
	{
		buffer >> element->pgv1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroIEEE2.pgv2
bool assign_GovHydroIEEE2_pgv2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE2*>(base_class_ptr))
	{
		buffer >> element->pgv2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroIEEE2.pgv3
bool assign_GovHydroIEEE2_pgv3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE2*>(base_class_ptr))
	{
		buffer >> element->pgv3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroIEEE2.pgv4
bool assign_GovHydroIEEE2_pgv4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE2*>(base_class_ptr))
	{
		buffer >> element->pgv4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroIEEE2.pgv5
bool assign_GovHydroIEEE2_pgv5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE2*>(base_class_ptr))
	{
		buffer >> element->pgv5.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroIEEE2.pgv6
bool assign_GovHydroIEEE2_pgv6(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE2*>(base_class_ptr))
	{
		buffer >> element->pgv6.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroIEEE2.pmax
bool assign_GovHydroIEEE2_pmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE2*>(base_class_ptr))
	{
		buffer >> element->pmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroIEEE2.pmin
bool assign_GovHydroIEEE2_pmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE2*>(base_class_ptr))
	{
		buffer >> element->pmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroIEEE2.rperm
bool assign_GovHydroIEEE2_rperm(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE2*>(base_class_ptr))
	{
		buffer >> element->rperm.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroIEEE2.rtemp
bool assign_GovHydroIEEE2_rtemp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE2*>(base_class_ptr))
	{
		buffer >> element->rtemp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroIEEE2.tg
bool assign_GovHydroIEEE2_tg(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE2*>(base_class_ptr))
	{
		buffer >> element->tg.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroIEEE2.tp
bool assign_GovHydroIEEE2_tp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE2*>(base_class_ptr))
	{
		buffer >> element->tp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroIEEE2.tr
bool assign_GovHydroIEEE2_tr(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE2*>(base_class_ptr))
	{
		buffer >> element->tr.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroIEEE2.tw
bool assign_GovHydroIEEE2_tw(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE2*>(base_class_ptr))
	{
		buffer >> element->tw.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroIEEE2.uc
bool assign_GovHydroIEEE2_uc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE2*>(base_class_ptr))
	{
		buffer >> element->uc;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroIEEE2.uo
bool assign_GovHydroIEEE2_uo(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroIEEE2*>(base_class_ptr))
	{
		buffer >> element->uo;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPelton.av0
bool assign_GovHydroPelton_av0(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPelton* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPelton*>(base_class_ptr))
	{
		buffer >> element->av0.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPelton.av1
bool assign_GovHydroPelton_av1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPelton* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPelton*>(base_class_ptr))
	{
		buffer >> element->av1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPelton.bp
bool assign_GovHydroPelton_bp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPelton* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPelton*>(base_class_ptr))
	{
		buffer >> element->bp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPelton.db1
bool assign_GovHydroPelton_db1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPelton* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPelton*>(base_class_ptr))
	{
		buffer >> element->db1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPelton.db2
bool assign_GovHydroPelton_db2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPelton* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPelton*>(base_class_ptr))
	{
		buffer >> element->db2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPelton.h1
bool assign_GovHydroPelton_h1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPelton* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPelton*>(base_class_ptr))
	{
		buffer >> element->h1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPelton.h2
bool assign_GovHydroPelton_h2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPelton* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPelton*>(base_class_ptr))
	{
		buffer >> element->h2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPelton.hn
bool assign_GovHydroPelton_hn(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPelton* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPelton*>(base_class_ptr))
	{
		buffer >> element->hn.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPelton.kc
bool assign_GovHydroPelton_kc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPelton* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPelton*>(base_class_ptr))
	{
		buffer >> element->kc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPelton.kg
bool assign_GovHydroPelton_kg(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPelton* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPelton*>(base_class_ptr))
	{
		buffer >> element->kg.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPelton.qc0
bool assign_GovHydroPelton_qc0(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPelton* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPelton*>(base_class_ptr))
	{
		buffer >> element->qc0.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPelton.qn
bool assign_GovHydroPelton_qn(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPelton* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPelton*>(base_class_ptr))
	{
		buffer >> element->qn.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPelton.simplifiedPelton
bool assign_GovHydroPelton_simplifiedPelton(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPelton* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPelton*>(base_class_ptr))
	{
		buffer >> element->simplifiedPelton;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPelton.staticCompensating
bool assign_GovHydroPelton_staticCompensating(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPelton* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPelton*>(base_class_ptr))
	{
		buffer >> element->staticCompensating;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPelton.ta
bool assign_GovHydroPelton_ta(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPelton* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPelton*>(base_class_ptr))
	{
		buffer >> element->ta.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPelton.ts
bool assign_GovHydroPelton_ts(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPelton* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPelton*>(base_class_ptr))
	{
		buffer >> element->ts.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPelton.tv
bool assign_GovHydroPelton_tv(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPelton* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPelton*>(base_class_ptr))
	{
		buffer >> element->tv.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPelton.twnc
bool assign_GovHydroPelton_twnc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPelton* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPelton*>(base_class_ptr))
	{
		buffer >> element->twnc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPelton.twng
bool assign_GovHydroPelton_twng(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPelton* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPelton*>(base_class_ptr))
	{
		buffer >> element->twng.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPelton.tx
bool assign_GovHydroPelton_tx(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPelton* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPelton*>(base_class_ptr))
	{
		buffer >> element->tx.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPelton.va
bool assign_GovHydroPelton_va(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPelton* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPelton*>(base_class_ptr))
	{
		buffer >> element->va;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPelton.valvmax
bool assign_GovHydroPelton_valvmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPelton* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPelton*>(base_class_ptr))
	{
		buffer >> element->valvmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPelton.valvmin
bool assign_GovHydroPelton_valvmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPelton* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPelton*>(base_class_ptr))
	{
		buffer >> element->valvmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPelton.vav
bool assign_GovHydroPelton_vav(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPelton* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPelton*>(base_class_ptr))
	{
		buffer >> element->vav.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPelton.vc
bool assign_GovHydroPelton_vc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPelton* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPelton*>(base_class_ptr))
	{
		buffer >> element->vc;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPelton.vcv
bool assign_GovHydroPelton_vcv(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPelton* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPelton*>(base_class_ptr))
	{
		buffer >> element->vcv.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPelton.waterTunnelSurgeChamberSimulation
bool assign_GovHydroPelton_waterTunnelSurgeChamberSimulation(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPelton* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPelton*>(base_class_ptr))
	{
		buffer >> element->waterTunnelSurgeChamberSimulation;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPelton.zsfc
bool assign_GovHydroPelton_zsfc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPelton* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPelton*>(base_class_ptr))
	{
		buffer >> element->zsfc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPID.aturb
bool assign_GovHydroPID_aturb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID*>(base_class_ptr))
	{
		buffer >> element->aturb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPID.bturb
bool assign_GovHydroPID_bturb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID*>(base_class_ptr))
	{
		buffer >> element->bturb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPID.db1
bool assign_GovHydroPID_db1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID*>(base_class_ptr))
	{
		buffer >> element->db1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPID.db2
bool assign_GovHydroPID_db2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID*>(base_class_ptr))
	{
		buffer >> element->db2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPID.eps
bool assign_GovHydroPID_eps(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID*>(base_class_ptr))
	{
		buffer >> element->eps.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPID.gv1
bool assign_GovHydroPID_gv1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID*>(base_class_ptr))
	{
		buffer >> element->gv1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPID.gv2
bool assign_GovHydroPID_gv2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID*>(base_class_ptr))
	{
		buffer >> element->gv2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPID.gv3
bool assign_GovHydroPID_gv3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID*>(base_class_ptr))
	{
		buffer >> element->gv3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPID.gv4
bool assign_GovHydroPID_gv4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID*>(base_class_ptr))
	{
		buffer >> element->gv4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPID.gv5
bool assign_GovHydroPID_gv5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID*>(base_class_ptr))
	{
		buffer >> element->gv5.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPID.gv6
bool assign_GovHydroPID_gv6(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID*>(base_class_ptr))
	{
		buffer >> element->gv6.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPID.inputSignal
bool assign_GovHydroPID_inputSignal(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID*>(base_class_ptr))
	{
		buffer >> element->inputSignal;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPID.kd
bool assign_GovHydroPID_kd(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID*>(base_class_ptr))
	{
		buffer >> element->kd.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPID.kg
bool assign_GovHydroPID_kg(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID*>(base_class_ptr))
	{
		buffer >> element->kg.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPID.ki
bool assign_GovHydroPID_ki(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID*>(base_class_ptr))
	{
		buffer >> element->ki.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPID.kp
bool assign_GovHydroPID_kp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID*>(base_class_ptr))
	{
		buffer >> element->kp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPID.mwbase
bool assign_GovHydroPID_mwbase(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID*>(base_class_ptr))
	{
		buffer >> element->mwbase.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPID.pgv1
bool assign_GovHydroPID_pgv1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID*>(base_class_ptr))
	{
		buffer >> element->pgv1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPID.pgv2
bool assign_GovHydroPID_pgv2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID*>(base_class_ptr))
	{
		buffer >> element->pgv2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPID.pgv3
bool assign_GovHydroPID_pgv3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID*>(base_class_ptr))
	{
		buffer >> element->pgv3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPID.pgv4
bool assign_GovHydroPID_pgv4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID*>(base_class_ptr))
	{
		buffer >> element->pgv4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPID.pgv5
bool assign_GovHydroPID_pgv5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID*>(base_class_ptr))
	{
		buffer >> element->pgv5.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPID.pgv6
bool assign_GovHydroPID_pgv6(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID*>(base_class_ptr))
	{
		buffer >> element->pgv6.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPID.pmax
bool assign_GovHydroPID_pmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID*>(base_class_ptr))
	{
		buffer >> element->pmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPID.pmin
bool assign_GovHydroPID_pmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID*>(base_class_ptr))
	{
		buffer >> element->pmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPID.r
bool assign_GovHydroPID_r(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID*>(base_class_ptr))
	{
		buffer >> element->r.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPID.td
bool assign_GovHydroPID_td(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID*>(base_class_ptr))
	{
		buffer >> element->td.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPID.tf
bool assign_GovHydroPID_tf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID*>(base_class_ptr))
	{
		buffer >> element->tf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPID.tp
bool assign_GovHydroPID_tp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID*>(base_class_ptr))
	{
		buffer >> element->tp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPID.tt
bool assign_GovHydroPID_tt(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID*>(base_class_ptr))
	{
		buffer >> element->tt.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPID.tturb
bool assign_GovHydroPID_tturb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID*>(base_class_ptr))
	{
		buffer >> element->tturb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPID.velcl
bool assign_GovHydroPID_velcl(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID*>(base_class_ptr))
	{
		buffer >> element->velcl;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPID.velop
bool assign_GovHydroPID_velop(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID*>(base_class_ptr))
	{
		buffer >> element->velop;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPID2.atw
bool assign_GovHydroPID2_atw(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID2*>(base_class_ptr))
	{
		buffer >> element->atw.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPID2.d
bool assign_GovHydroPID2_d(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID2*>(base_class_ptr))
	{
		buffer >> element->d.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPID2.feedbackSignal
bool assign_GovHydroPID2_feedbackSignal(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID2*>(base_class_ptr))
	{
		buffer >> element->feedbackSignal;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPID2.g0
bool assign_GovHydroPID2_g0(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID2*>(base_class_ptr))
	{
		buffer >> element->g0.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPID2.g1
bool assign_GovHydroPID2_g1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID2*>(base_class_ptr))
	{
		buffer >> element->g1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPID2.g2
bool assign_GovHydroPID2_g2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID2*>(base_class_ptr))
	{
		buffer >> element->g2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPID2.gmax
bool assign_GovHydroPID2_gmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID2*>(base_class_ptr))
	{
		buffer >> element->gmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPID2.gmin
bool assign_GovHydroPID2_gmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID2*>(base_class_ptr))
	{
		buffer >> element->gmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPID2.kd
bool assign_GovHydroPID2_kd(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID2*>(base_class_ptr))
	{
		buffer >> element->kd.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPID2.ki
bool assign_GovHydroPID2_ki(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID2*>(base_class_ptr))
	{
		buffer >> element->ki;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPID2.kp
bool assign_GovHydroPID2_kp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID2*>(base_class_ptr))
	{
		buffer >> element->kp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPID2.mwbase
bool assign_GovHydroPID2_mwbase(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID2*>(base_class_ptr))
	{
		buffer >> element->mwbase.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPID2.p1
bool assign_GovHydroPID2_p1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID2*>(base_class_ptr))
	{
		buffer >> element->p1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPID2.p2
bool assign_GovHydroPID2_p2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID2*>(base_class_ptr))
	{
		buffer >> element->p2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPID2.p3
bool assign_GovHydroPID2_p3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID2*>(base_class_ptr))
	{
		buffer >> element->p3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPID2.rperm
bool assign_GovHydroPID2_rperm(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID2*>(base_class_ptr))
	{
		buffer >> element->rperm.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPID2.ta
bool assign_GovHydroPID2_ta(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID2*>(base_class_ptr))
	{
		buffer >> element->ta.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPID2.tb
bool assign_GovHydroPID2_tb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID2*>(base_class_ptr))
	{
		buffer >> element->tb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPID2.treg
bool assign_GovHydroPID2_treg(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID2*>(base_class_ptr))
	{
		buffer >> element->treg.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPID2.tw
bool assign_GovHydroPID2_tw(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID2*>(base_class_ptr))
	{
		buffer >> element->tw.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPID2.velmax
bool assign_GovHydroPID2_velmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID2*>(base_class_ptr))
	{
		buffer >> element->velmax;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroPID2.velmin
bool assign_GovHydroPID2_velmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroPID2*>(base_class_ptr))
	{
		buffer >> element->velmin;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroR.at
bool assign_GovHydroR_at(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR*>(base_class_ptr))
	{
		buffer >> element->at.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroR.db1
bool assign_GovHydroR_db1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR*>(base_class_ptr))
	{
		buffer >> element->db1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroR.db2
bool assign_GovHydroR_db2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR*>(base_class_ptr))
	{
		buffer >> element->db2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroR.dturb
bool assign_GovHydroR_dturb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR*>(base_class_ptr))
	{
		buffer >> element->dturb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroR.eps
bool assign_GovHydroR_eps(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR*>(base_class_ptr))
	{
		buffer >> element->eps.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroR.gmax
bool assign_GovHydroR_gmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR*>(base_class_ptr))
	{
		buffer >> element->gmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroR.gmin
bool assign_GovHydroR_gmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR*>(base_class_ptr))
	{
		buffer >> element->gmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroR.gv1
bool assign_GovHydroR_gv1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR*>(base_class_ptr))
	{
		buffer >> element->gv1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroR.gv2
bool assign_GovHydroR_gv2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR*>(base_class_ptr))
	{
		buffer >> element->gv2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroR.gv3
bool assign_GovHydroR_gv3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR*>(base_class_ptr))
	{
		buffer >> element->gv3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroR.gv4
bool assign_GovHydroR_gv4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR*>(base_class_ptr))
	{
		buffer >> element->gv4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroR.gv5
bool assign_GovHydroR_gv5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR*>(base_class_ptr))
	{
		buffer >> element->gv5.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroR.gv6
bool assign_GovHydroR_gv6(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR*>(base_class_ptr))
	{
		buffer >> element->gv6.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroR.h0
bool assign_GovHydroR_h0(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR*>(base_class_ptr))
	{
		buffer >> element->h0.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroR.inputSignal
bool assign_GovHydroR_inputSignal(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR*>(base_class_ptr))
	{
		buffer >> element->inputSignal;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroR.kg
bool assign_GovHydroR_kg(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR*>(base_class_ptr))
	{
		buffer >> element->kg.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroR.ki
bool assign_GovHydroR_ki(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR*>(base_class_ptr))
	{
		buffer >> element->ki.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroR.mwbase
bool assign_GovHydroR_mwbase(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR*>(base_class_ptr))
	{
		buffer >> element->mwbase.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroR.pgv1
bool assign_GovHydroR_pgv1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR*>(base_class_ptr))
	{
		buffer >> element->pgv1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroR.pgv2
bool assign_GovHydroR_pgv2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR*>(base_class_ptr))
	{
		buffer >> element->pgv2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroR.pgv3
bool assign_GovHydroR_pgv3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR*>(base_class_ptr))
	{
		buffer >> element->pgv3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroR.pgv4
bool assign_GovHydroR_pgv4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR*>(base_class_ptr))
	{
		buffer >> element->pgv4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroR.pgv5
bool assign_GovHydroR_pgv5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR*>(base_class_ptr))
	{
		buffer >> element->pgv5.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroR.pgv6
bool assign_GovHydroR_pgv6(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR*>(base_class_ptr))
	{
		buffer >> element->pgv6.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroR.pmax
bool assign_GovHydroR_pmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR*>(base_class_ptr))
	{
		buffer >> element->pmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroR.pmin
bool assign_GovHydroR_pmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR*>(base_class_ptr))
	{
		buffer >> element->pmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroR.qnl
bool assign_GovHydroR_qnl(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR*>(base_class_ptr))
	{
		buffer >> element->qnl.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroR.r
bool assign_GovHydroR_r(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR*>(base_class_ptr))
	{
		buffer >> element->r.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroR.t1
bool assign_GovHydroR_t1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR*>(base_class_ptr))
	{
		buffer >> element->t1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroR.t2
bool assign_GovHydroR_t2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR*>(base_class_ptr))
	{
		buffer >> element->t2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroR.t3
bool assign_GovHydroR_t3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR*>(base_class_ptr))
	{
		buffer >> element->t3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroR.t4
bool assign_GovHydroR_t4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR*>(base_class_ptr))
	{
		buffer >> element->t4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroR.t5
bool assign_GovHydroR_t5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR*>(base_class_ptr))
	{
		buffer >> element->t5.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroR.t6
bool assign_GovHydroR_t6(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR*>(base_class_ptr))
	{
		buffer >> element->t6.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroR.t7
bool assign_GovHydroR_t7(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR*>(base_class_ptr))
	{
		buffer >> element->t7.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroR.t8
bool assign_GovHydroR_t8(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR*>(base_class_ptr))
	{
		buffer >> element->t8.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroR.td
bool assign_GovHydroR_td(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR*>(base_class_ptr))
	{
		buffer >> element->td.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroR.tp
bool assign_GovHydroR_tp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR*>(base_class_ptr))
	{
		buffer >> element->tp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroR.tt
bool assign_GovHydroR_tt(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR*>(base_class_ptr))
	{
		buffer >> element->tt.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroR.tw
bool assign_GovHydroR_tw(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR*>(base_class_ptr))
	{
		buffer >> element->tw.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroR.velcl
bool assign_GovHydroR_velcl(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR*>(base_class_ptr))
	{
		buffer >> element->velcl;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroR.velop
bool assign_GovHydroR_velop(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroR*>(base_class_ptr))
	{
		buffer >> element->velop;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWEH.db
bool assign_GovHydroWEH_db(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH*>(base_class_ptr))
	{
		buffer >> element->db.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWEH.dicn
bool assign_GovHydroWEH_dicn(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH*>(base_class_ptr))
	{
		buffer >> element->dicn.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWEH.dpv
bool assign_GovHydroWEH_dpv(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH*>(base_class_ptr))
	{
		buffer >> element->dpv.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWEH.dturb
bool assign_GovHydroWEH_dturb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH*>(base_class_ptr))
	{
		buffer >> element->dturb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWEH.feedbackSignal
bool assign_GovHydroWEH_feedbackSignal(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH*>(base_class_ptr))
	{
		buffer >> element->feedbackSignal;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWEH.fl1
bool assign_GovHydroWEH_fl1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH*>(base_class_ptr))
	{
		buffer >> element->fl1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWEH.fl2
bool assign_GovHydroWEH_fl2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH*>(base_class_ptr))
	{
		buffer >> element->fl2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWEH.fl3
bool assign_GovHydroWEH_fl3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH*>(base_class_ptr))
	{
		buffer >> element->fl3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWEH.fl4
bool assign_GovHydroWEH_fl4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH*>(base_class_ptr))
	{
		buffer >> element->fl4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWEH.fl5
bool assign_GovHydroWEH_fl5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH*>(base_class_ptr))
	{
		buffer >> element->fl5.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWEH.fp1
bool assign_GovHydroWEH_fp1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH*>(base_class_ptr))
	{
		buffer >> element->fp1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWEH.fp10
bool assign_GovHydroWEH_fp10(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH*>(base_class_ptr))
	{
		buffer >> element->fp10.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWEH.fp2
bool assign_GovHydroWEH_fp2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH*>(base_class_ptr))
	{
		buffer >> element->fp2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWEH.fp3
bool assign_GovHydroWEH_fp3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH*>(base_class_ptr))
	{
		buffer >> element->fp3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWEH.fp4
bool assign_GovHydroWEH_fp4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH*>(base_class_ptr))
	{
		buffer >> element->fp4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWEH.fp5
bool assign_GovHydroWEH_fp5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH*>(base_class_ptr))
	{
		buffer >> element->fp5.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWEH.fp6
bool assign_GovHydroWEH_fp6(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH*>(base_class_ptr))
	{
		buffer >> element->fp6.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWEH.fp7
bool assign_GovHydroWEH_fp7(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH*>(base_class_ptr))
	{
		buffer >> element->fp7.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWEH.fp8
bool assign_GovHydroWEH_fp8(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH*>(base_class_ptr))
	{
		buffer >> element->fp8.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWEH.fp9
bool assign_GovHydroWEH_fp9(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH*>(base_class_ptr))
	{
		buffer >> element->fp9.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWEH.gmax
bool assign_GovHydroWEH_gmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH*>(base_class_ptr))
	{
		buffer >> element->gmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWEH.gmin
bool assign_GovHydroWEH_gmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH*>(base_class_ptr))
	{
		buffer >> element->gmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWEH.gtmxcl
bool assign_GovHydroWEH_gtmxcl(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH*>(base_class_ptr))
	{
		buffer >> element->gtmxcl.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWEH.gtmxop
bool assign_GovHydroWEH_gtmxop(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH*>(base_class_ptr))
	{
		buffer >> element->gtmxop.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWEH.gv1
bool assign_GovHydroWEH_gv1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH*>(base_class_ptr))
	{
		buffer >> element->gv1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWEH.gv2
bool assign_GovHydroWEH_gv2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH*>(base_class_ptr))
	{
		buffer >> element->gv2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWEH.gv3
bool assign_GovHydroWEH_gv3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH*>(base_class_ptr))
	{
		buffer >> element->gv3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWEH.gv4
bool assign_GovHydroWEH_gv4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH*>(base_class_ptr))
	{
		buffer >> element->gv4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWEH.gv5
bool assign_GovHydroWEH_gv5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH*>(base_class_ptr))
	{
		buffer >> element->gv5.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWEH.kd
bool assign_GovHydroWEH_kd(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH*>(base_class_ptr))
	{
		buffer >> element->kd.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWEH.ki
bool assign_GovHydroWEH_ki(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH*>(base_class_ptr))
	{
		buffer >> element->ki.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWEH.kp
bool assign_GovHydroWEH_kp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH*>(base_class_ptr))
	{
		buffer >> element->kp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWEH.mwbase
bool assign_GovHydroWEH_mwbase(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH*>(base_class_ptr))
	{
		buffer >> element->mwbase.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWEH.pmss1
bool assign_GovHydroWEH_pmss1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH*>(base_class_ptr))
	{
		buffer >> element->pmss1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWEH.pmss10
bool assign_GovHydroWEH_pmss10(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH*>(base_class_ptr))
	{
		buffer >> element->pmss10.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWEH.pmss2
bool assign_GovHydroWEH_pmss2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH*>(base_class_ptr))
	{
		buffer >> element->pmss2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWEH.pmss3
bool assign_GovHydroWEH_pmss3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH*>(base_class_ptr))
	{
		buffer >> element->pmss3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWEH.pmss4
bool assign_GovHydroWEH_pmss4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH*>(base_class_ptr))
	{
		buffer >> element->pmss4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWEH.pmss5
bool assign_GovHydroWEH_pmss5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH*>(base_class_ptr))
	{
		buffer >> element->pmss5.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWEH.pmss6
bool assign_GovHydroWEH_pmss6(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH*>(base_class_ptr))
	{
		buffer >> element->pmss6.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWEH.pmss7
bool assign_GovHydroWEH_pmss7(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH*>(base_class_ptr))
	{
		buffer >> element->pmss7.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWEH.pmss8
bool assign_GovHydroWEH_pmss8(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH*>(base_class_ptr))
	{
		buffer >> element->pmss8.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWEH.pmss9
bool assign_GovHydroWEH_pmss9(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH*>(base_class_ptr))
	{
		buffer >> element->pmss9.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWEH.rpg
bool assign_GovHydroWEH_rpg(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH*>(base_class_ptr))
	{
		buffer >> element->rpg;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWEH.rpp
bool assign_GovHydroWEH_rpp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH*>(base_class_ptr))
	{
		buffer >> element->rpp;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWEH.td
bool assign_GovHydroWEH_td(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH*>(base_class_ptr))
	{
		buffer >> element->td.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWEH.tdv
bool assign_GovHydroWEH_tdv(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH*>(base_class_ptr))
	{
		buffer >> element->tdv.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWEH.tg
bool assign_GovHydroWEH_tg(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH*>(base_class_ptr))
	{
		buffer >> element->tg.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWEH.tp
bool assign_GovHydroWEH_tp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH*>(base_class_ptr))
	{
		buffer >> element->tp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWEH.tpe
bool assign_GovHydroWEH_tpe(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH*>(base_class_ptr))
	{
		buffer >> element->tpe.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWEH.tw
bool assign_GovHydroWEH_tw(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWEH*>(base_class_ptr))
	{
		buffer >> element->tw.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWPID.d
bool assign_GovHydroWPID_d(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWPID* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWPID*>(base_class_ptr))
	{
		buffer >> element->d.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWPID.gatmax
bool assign_GovHydroWPID_gatmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWPID* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWPID*>(base_class_ptr))
	{
		buffer >> element->gatmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWPID.gatmin
bool assign_GovHydroWPID_gatmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWPID* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWPID*>(base_class_ptr))
	{
		buffer >> element->gatmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWPID.gv1
bool assign_GovHydroWPID_gv1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWPID* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWPID*>(base_class_ptr))
	{
		buffer >> element->gv1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWPID.gv2
bool assign_GovHydroWPID_gv2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWPID* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWPID*>(base_class_ptr))
	{
		buffer >> element->gv2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWPID.gv3
bool assign_GovHydroWPID_gv3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWPID* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWPID*>(base_class_ptr))
	{
		buffer >> element->gv3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWPID.kd
bool assign_GovHydroWPID_kd(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWPID* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWPID*>(base_class_ptr))
	{
		buffer >> element->kd.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWPID.ki
bool assign_GovHydroWPID_ki(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWPID* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWPID*>(base_class_ptr))
	{
		buffer >> element->ki.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWPID.kp
bool assign_GovHydroWPID_kp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWPID* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWPID*>(base_class_ptr))
	{
		buffer >> element->kp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWPID.mwbase
bool assign_GovHydroWPID_mwbase(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWPID* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWPID*>(base_class_ptr))
	{
		buffer >> element->mwbase.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWPID.pgv1
bool assign_GovHydroWPID_pgv1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWPID* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWPID*>(base_class_ptr))
	{
		buffer >> element->pgv1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWPID.pgv2
bool assign_GovHydroWPID_pgv2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWPID* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWPID*>(base_class_ptr))
	{
		buffer >> element->pgv2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWPID.pgv3
bool assign_GovHydroWPID_pgv3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWPID* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWPID*>(base_class_ptr))
	{
		buffer >> element->pgv3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWPID.pmax
bool assign_GovHydroWPID_pmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWPID* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWPID*>(base_class_ptr))
	{
		buffer >> element->pmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWPID.pmin
bool assign_GovHydroWPID_pmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWPID* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWPID*>(base_class_ptr))
	{
		buffer >> element->pmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWPID.reg
bool assign_GovHydroWPID_reg(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWPID* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWPID*>(base_class_ptr))
	{
		buffer >> element->reg.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWPID.ta
bool assign_GovHydroWPID_ta(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWPID* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWPID*>(base_class_ptr))
	{
		buffer >> element->ta.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWPID.tb
bool assign_GovHydroWPID_tb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWPID* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWPID*>(base_class_ptr))
	{
		buffer >> element->tb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWPID.treg
bool assign_GovHydroWPID_treg(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWPID* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWPID*>(base_class_ptr))
	{
		buffer >> element->treg.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWPID.tw
bool assign_GovHydroWPID_tw(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWPID* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWPID*>(base_class_ptr))
	{
		buffer >> element->tw.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWPID.velmax
bool assign_GovHydroWPID_velmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWPID* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWPID*>(base_class_ptr))
	{
		buffer >> element->velmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovHydroWPID.velmin
bool assign_GovHydroWPID_velmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWPID* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovHydroWPID*>(base_class_ptr))
	{
		buffer >> element->velmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteam0.dt
bool assign_GovSteam0_dt(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam0* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam0*>(base_class_ptr))
	{
		buffer >> element->dt.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteam0.mwbase
bool assign_GovSteam0_mwbase(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam0* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam0*>(base_class_ptr))
	{
		buffer >> element->mwbase.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteam0.r
bool assign_GovSteam0_r(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam0* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam0*>(base_class_ptr))
	{
		buffer >> element->r.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteam0.t1
bool assign_GovSteam0_t1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam0* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam0*>(base_class_ptr))
	{
		buffer >> element->t1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteam0.t2
bool assign_GovSteam0_t2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam0* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam0*>(base_class_ptr))
	{
		buffer >> element->t2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteam0.t3
bool assign_GovSteam0_t3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam0* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam0*>(base_class_ptr))
	{
		buffer >> element->t3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteam0.vmax
bool assign_GovSteam0_vmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam0* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam0*>(base_class_ptr))
	{
		buffer >> element->vmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteam0.vmin
bool assign_GovSteam0_vmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam0* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam0*>(base_class_ptr))
	{
		buffer >> element->vmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteam1.db1
bool assign_GovSteam1_db1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1*>(base_class_ptr))
	{
		buffer >> element->db1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteam1.db2
bool assign_GovSteam1_db2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1*>(base_class_ptr))
	{
		buffer >> element->db2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteam1.eps
bool assign_GovSteam1_eps(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1*>(base_class_ptr))
	{
		buffer >> element->eps.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteam1.gv1
bool assign_GovSteam1_gv1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1*>(base_class_ptr))
	{
		buffer >> element->gv1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteam1.gv2
bool assign_GovSteam1_gv2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1*>(base_class_ptr))
	{
		buffer >> element->gv2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteam1.gv3
bool assign_GovSteam1_gv3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1*>(base_class_ptr))
	{
		buffer >> element->gv3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteam1.gv4
bool assign_GovSteam1_gv4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1*>(base_class_ptr))
	{
		buffer >> element->gv4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteam1.gv5
bool assign_GovSteam1_gv5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1*>(base_class_ptr))
	{
		buffer >> element->gv5.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteam1.gv6
bool assign_GovSteam1_gv6(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1*>(base_class_ptr))
	{
		buffer >> element->gv6.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteam1.k
bool assign_GovSteam1_k(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1*>(base_class_ptr))
	{
		buffer >> element->k.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteam1.k1
bool assign_GovSteam1_k1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1*>(base_class_ptr))
	{
		buffer >> element->k1;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteam1.k2
bool assign_GovSteam1_k2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1*>(base_class_ptr))
	{
		buffer >> element->k2;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteam1.k3
bool assign_GovSteam1_k3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1*>(base_class_ptr))
	{
		buffer >> element->k3;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteam1.k4
bool assign_GovSteam1_k4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1*>(base_class_ptr))
	{
		buffer >> element->k4;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteam1.k5
bool assign_GovSteam1_k5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1*>(base_class_ptr))
	{
		buffer >> element->k5;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteam1.k6
bool assign_GovSteam1_k6(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1*>(base_class_ptr))
	{
		buffer >> element->k6;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteam1.k7
bool assign_GovSteam1_k7(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1*>(base_class_ptr))
	{
		buffer >> element->k7;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteam1.k8
bool assign_GovSteam1_k8(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1*>(base_class_ptr))
	{
		buffer >> element->k8;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteam1.mwbase
bool assign_GovSteam1_mwbase(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1*>(base_class_ptr))
	{
		buffer >> element->mwbase.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteam1.pgv1
bool assign_GovSteam1_pgv1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1*>(base_class_ptr))
	{
		buffer >> element->pgv1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteam1.pgv2
bool assign_GovSteam1_pgv2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1*>(base_class_ptr))
	{
		buffer >> element->pgv2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteam1.pgv3
bool assign_GovSteam1_pgv3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1*>(base_class_ptr))
	{
		buffer >> element->pgv3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteam1.pgv4
bool assign_GovSteam1_pgv4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1*>(base_class_ptr))
	{
		buffer >> element->pgv4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteam1.pgv5
bool assign_GovSteam1_pgv5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1*>(base_class_ptr))
	{
		buffer >> element->pgv5.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteam1.pgv6
bool assign_GovSteam1_pgv6(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1*>(base_class_ptr))
	{
		buffer >> element->pgv6.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteam1.pmax
bool assign_GovSteam1_pmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1*>(base_class_ptr))
	{
		buffer >> element->pmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteam1.pmin
bool assign_GovSteam1_pmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1*>(base_class_ptr))
	{
		buffer >> element->pmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteam1.sdb1
bool assign_GovSteam1_sdb1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1*>(base_class_ptr))
	{
		buffer >> element->sdb1;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteam1.sdb2
bool assign_GovSteam1_sdb2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1*>(base_class_ptr))
	{
		buffer >> element->sdb2;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteam1.t1
bool assign_GovSteam1_t1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1*>(base_class_ptr))
	{
		buffer >> element->t1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteam1.t2
bool assign_GovSteam1_t2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1*>(base_class_ptr))
	{
		buffer >> element->t2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteam1.t3
bool assign_GovSteam1_t3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1*>(base_class_ptr))
	{
		buffer >> element->t3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteam1.t4
bool assign_GovSteam1_t4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1*>(base_class_ptr))
	{
		buffer >> element->t4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteam1.t5
bool assign_GovSteam1_t5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1*>(base_class_ptr))
	{
		buffer >> element->t5.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteam1.t6
bool assign_GovSteam1_t6(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1*>(base_class_ptr))
	{
		buffer >> element->t6.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteam1.t7
bool assign_GovSteam1_t7(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1*>(base_class_ptr))
	{
		buffer >> element->t7.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteam1.uc
bool assign_GovSteam1_uc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1*>(base_class_ptr))
	{
		buffer >> element->uc;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteam1.uo
bool assign_GovSteam1_uo(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1*>(base_class_ptr))
	{
		buffer >> element->uo;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteam1.valve
bool assign_GovSteam1_valve(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam1*>(base_class_ptr))
	{
		buffer >> element->valve;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteam2.dbf
bool assign_GovSteam2_dbf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam2*>(base_class_ptr))
	{
		buffer >> element->dbf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteam2.k
bool assign_GovSteam2_k(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam2*>(base_class_ptr))
	{
		buffer >> element->k;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteam2.mnef
bool assign_GovSteam2_mnef(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam2*>(base_class_ptr))
	{
		buffer >> element->mnef.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteam2.mxef
bool assign_GovSteam2_mxef(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam2*>(base_class_ptr))
	{
		buffer >> element->mxef.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteam2.pmax
bool assign_GovSteam2_pmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam2*>(base_class_ptr))
	{
		buffer >> element->pmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteam2.pmin
bool assign_GovSteam2_pmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam2*>(base_class_ptr))
	{
		buffer >> element->pmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteam2.t1
bool assign_GovSteam2_t1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam2*>(base_class_ptr))
	{
		buffer >> element->t1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteam2.t2
bool assign_GovSteam2_t2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteam2*>(base_class_ptr))
	{
		buffer >> element->t2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamCC.dhp
bool assign_GovSteamCC_dhp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamCC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamCC*>(base_class_ptr))
	{
		buffer >> element->dhp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamCC.dlp
bool assign_GovSteamCC_dlp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamCC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamCC*>(base_class_ptr))
	{
		buffer >> element->dlp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamCC.fhp
bool assign_GovSteamCC_fhp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamCC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamCC*>(base_class_ptr))
	{
		buffer >> element->fhp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamCC.flp
bool assign_GovSteamCC_flp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamCC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamCC*>(base_class_ptr))
	{
		buffer >> element->flp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamCC.mwbase
bool assign_GovSteamCC_mwbase(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamCC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamCC*>(base_class_ptr))
	{
		buffer >> element->mwbase.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamCC.pmaxhp
bool assign_GovSteamCC_pmaxhp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamCC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamCC*>(base_class_ptr))
	{
		buffer >> element->pmaxhp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamCC.pmaxlp
bool assign_GovSteamCC_pmaxlp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamCC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamCC*>(base_class_ptr))
	{
		buffer >> element->pmaxlp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamCC.rhp
bool assign_GovSteamCC_rhp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamCC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamCC*>(base_class_ptr))
	{
		buffer >> element->rhp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamCC.rlp
bool assign_GovSteamCC_rlp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamCC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamCC*>(base_class_ptr))
	{
		buffer >> element->rlp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamCC.t1hp
bool assign_GovSteamCC_t1hp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamCC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamCC*>(base_class_ptr))
	{
		buffer >> element->t1hp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamCC.t1lp
bool assign_GovSteamCC_t1lp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamCC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamCC*>(base_class_ptr))
	{
		buffer >> element->t1lp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamCC.t3hp
bool assign_GovSteamCC_t3hp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamCC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamCC*>(base_class_ptr))
	{
		buffer >> element->t3hp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamCC.t3lp
bool assign_GovSteamCC_t3lp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamCC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamCC*>(base_class_ptr))
	{
		buffer >> element->t3lp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamCC.t4hp
bool assign_GovSteamCC_t4hp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamCC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamCC*>(base_class_ptr))
	{
		buffer >> element->t4hp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamCC.t4lp
bool assign_GovSteamCC_t4lp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamCC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamCC*>(base_class_ptr))
	{
		buffer >> element->t4lp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamCC.t5hp
bool assign_GovSteamCC_t5hp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamCC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamCC*>(base_class_ptr))
	{
		buffer >> element->t5hp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamCC.t5lp
bool assign_GovSteamCC_t5lp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamCC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamCC*>(base_class_ptr))
	{
		buffer >> element->t5lp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamEU.chc
bool assign_GovSteamEU_chc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU*>(base_class_ptr))
	{
		buffer >> element->chc;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamEU.cho
bool assign_GovSteamEU_cho(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU*>(base_class_ptr))
	{
		buffer >> element->cho;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamEU.cic
bool assign_GovSteamEU_cic(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU*>(base_class_ptr))
	{
		buffer >> element->cic.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamEU.cio
bool assign_GovSteamEU_cio(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU*>(base_class_ptr))
	{
		buffer >> element->cio.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamEU.db1
bool assign_GovSteamEU_db1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU*>(base_class_ptr))
	{
		buffer >> element->db1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamEU.db2
bool assign_GovSteamEU_db2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU*>(base_class_ptr))
	{
		buffer >> element->db2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamEU.hhpmax
bool assign_GovSteamEU_hhpmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU*>(base_class_ptr))
	{
		buffer >> element->hhpmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamEU.ke
bool assign_GovSteamEU_ke(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU*>(base_class_ptr))
	{
		buffer >> element->ke.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamEU.kfcor
bool assign_GovSteamEU_kfcor(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU*>(base_class_ptr))
	{
		buffer >> element->kfcor.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamEU.khp
bool assign_GovSteamEU_khp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU*>(base_class_ptr))
	{
		buffer >> element->khp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamEU.klp
bool assign_GovSteamEU_klp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU*>(base_class_ptr))
	{
		buffer >> element->klp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamEU.kwcor
bool assign_GovSteamEU_kwcor(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU*>(base_class_ptr))
	{
		buffer >> element->kwcor.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamEU.mwbase
bool assign_GovSteamEU_mwbase(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU*>(base_class_ptr))
	{
		buffer >> element->mwbase.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamEU.pmax
bool assign_GovSteamEU_pmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU*>(base_class_ptr))
	{
		buffer >> element->pmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamEU.prhmax
bool assign_GovSteamEU_prhmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU*>(base_class_ptr))
	{
		buffer >> element->prhmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamEU.simx
bool assign_GovSteamEU_simx(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU*>(base_class_ptr))
	{
		buffer >> element->simx.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamEU.tb
bool assign_GovSteamEU_tb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU*>(base_class_ptr))
	{
		buffer >> element->tb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamEU.tdp
bool assign_GovSteamEU_tdp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU*>(base_class_ptr))
	{
		buffer >> element->tdp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamEU.ten
bool assign_GovSteamEU_ten(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU*>(base_class_ptr))
	{
		buffer >> element->ten.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamEU.tf
bool assign_GovSteamEU_tf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU*>(base_class_ptr))
	{
		buffer >> element->tf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamEU.tfp
bool assign_GovSteamEU_tfp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU*>(base_class_ptr))
	{
		buffer >> element->tfp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamEU.thp
bool assign_GovSteamEU_thp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU*>(base_class_ptr))
	{
		buffer >> element->thp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamEU.tip
bool assign_GovSteamEU_tip(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU*>(base_class_ptr))
	{
		buffer >> element->tip.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamEU.tlp
bool assign_GovSteamEU_tlp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU*>(base_class_ptr))
	{
		buffer >> element->tlp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamEU.tp
bool assign_GovSteamEU_tp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU*>(base_class_ptr))
	{
		buffer >> element->tp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamEU.trh
bool assign_GovSteamEU_trh(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU*>(base_class_ptr))
	{
		buffer >> element->trh.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamEU.tvhp
bool assign_GovSteamEU_tvhp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU*>(base_class_ptr))
	{
		buffer >> element->tvhp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamEU.tvip
bool assign_GovSteamEU_tvip(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU*>(base_class_ptr))
	{
		buffer >> element->tvip.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamEU.tw
bool assign_GovSteamEU_tw(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU*>(base_class_ptr))
	{
		buffer >> element->tw.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamEU.wfmax
bool assign_GovSteamEU_wfmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU*>(base_class_ptr))
	{
		buffer >> element->wfmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamEU.wfmin
bool assign_GovSteamEU_wfmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU*>(base_class_ptr))
	{
		buffer >> element->wfmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamEU.wmax1
bool assign_GovSteamEU_wmax1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU*>(base_class_ptr))
	{
		buffer >> element->wmax1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamEU.wmax2
bool assign_GovSteamEU_wmax2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU*>(base_class_ptr))
	{
		buffer >> element->wmax2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamEU.wwmax
bool assign_GovSteamEU_wwmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU*>(base_class_ptr))
	{
		buffer >> element->wwmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamEU.wwmin
bool assign_GovSteamEU_wwmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamEU*>(base_class_ptr))
	{
		buffer >> element->wwmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV2.dt
bool assign_GovSteamFV2_dt(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV2*>(base_class_ptr))
	{
		buffer >> element->dt.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV2.k
bool assign_GovSteamFV2_k(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV2*>(base_class_ptr))
	{
		buffer >> element->k.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV2.mwbase
bool assign_GovSteamFV2_mwbase(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV2*>(base_class_ptr))
	{
		buffer >> element->mwbase.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV2.r
bool assign_GovSteamFV2_r(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV2*>(base_class_ptr))
	{
		buffer >> element->r.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV2.t1
bool assign_GovSteamFV2_t1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV2*>(base_class_ptr))
	{
		buffer >> element->t1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV2.t3
bool assign_GovSteamFV2_t3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV2*>(base_class_ptr))
	{
		buffer >> element->t3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV2.ta
bool assign_GovSteamFV2_ta(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV2*>(base_class_ptr))
	{
		buffer >> element->ta.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV2.tb
bool assign_GovSteamFV2_tb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV2*>(base_class_ptr))
	{
		buffer >> element->tb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV2.tc
bool assign_GovSteamFV2_tc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV2*>(base_class_ptr))
	{
		buffer >> element->tc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV2.ti
bool assign_GovSteamFV2_ti(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV2*>(base_class_ptr))
	{
		buffer >> element->ti.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV2.tt
bool assign_GovSteamFV2_tt(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV2*>(base_class_ptr))
	{
		buffer >> element->tt.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV2.vmax
bool assign_GovSteamFV2_vmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV2*>(base_class_ptr))
	{
		buffer >> element->vmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV2.vmin
bool assign_GovSteamFV2_vmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV2*>(base_class_ptr))
	{
		buffer >> element->vmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV3.k
bool assign_GovSteamFV3_k(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV3*>(base_class_ptr))
	{
		buffer >> element->k.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV3.k1
bool assign_GovSteamFV3_k1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV3*>(base_class_ptr))
	{
		buffer >> element->k1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV3.k2
bool assign_GovSteamFV3_k2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV3*>(base_class_ptr))
	{
		buffer >> element->k2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV3.k3
bool assign_GovSteamFV3_k3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV3*>(base_class_ptr))
	{
		buffer >> element->k3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV3.mwbase
bool assign_GovSteamFV3_mwbase(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV3*>(base_class_ptr))
	{
		buffer >> element->mwbase.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV3.pmax
bool assign_GovSteamFV3_pmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV3*>(base_class_ptr))
	{
		buffer >> element->pmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV3.pmin
bool assign_GovSteamFV3_pmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV3*>(base_class_ptr))
	{
		buffer >> element->pmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV3.prmax
bool assign_GovSteamFV3_prmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV3*>(base_class_ptr))
	{
		buffer >> element->prmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV3.t1
bool assign_GovSteamFV3_t1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV3*>(base_class_ptr))
	{
		buffer >> element->t1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV3.t2
bool assign_GovSteamFV3_t2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV3*>(base_class_ptr))
	{
		buffer >> element->t2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV3.t3
bool assign_GovSteamFV3_t3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV3*>(base_class_ptr))
	{
		buffer >> element->t3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV3.t4
bool assign_GovSteamFV3_t4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV3*>(base_class_ptr))
	{
		buffer >> element->t4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV3.t5
bool assign_GovSteamFV3_t5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV3*>(base_class_ptr))
	{
		buffer >> element->t5.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV3.t6
bool assign_GovSteamFV3_t6(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV3*>(base_class_ptr))
	{
		buffer >> element->t6.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV3.ta
bool assign_GovSteamFV3_ta(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV3*>(base_class_ptr))
	{
		buffer >> element->ta.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV3.tb
bool assign_GovSteamFV3_tb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV3*>(base_class_ptr))
	{
		buffer >> element->tb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV3.tc
bool assign_GovSteamFV3_tc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV3*>(base_class_ptr))
	{
		buffer >> element->tc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV3.uc
bool assign_GovSteamFV3_uc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV3*>(base_class_ptr))
	{
		buffer >> element->uc;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV3.uo
bool assign_GovSteamFV3_uo(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV3* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV3*>(base_class_ptr))
	{
		buffer >> element->uo;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV4.cpsmn
bool assign_GovSteamFV4_cpsmn(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4*>(base_class_ptr))
	{
		buffer >> element->cpsmn.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV4.cpsmx
bool assign_GovSteamFV4_cpsmx(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4*>(base_class_ptr))
	{
		buffer >> element->cpsmx.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV4.crmn
bool assign_GovSteamFV4_crmn(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4*>(base_class_ptr))
	{
		buffer >> element->crmn.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV4.crmx
bool assign_GovSteamFV4_crmx(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4*>(base_class_ptr))
	{
		buffer >> element->crmx.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV4.kdc
bool assign_GovSteamFV4_kdc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4*>(base_class_ptr))
	{
		buffer >> element->kdc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV4.kf1
bool assign_GovSteamFV4_kf1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4*>(base_class_ptr))
	{
		buffer >> element->kf1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV4.kf3
bool assign_GovSteamFV4_kf3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4*>(base_class_ptr))
	{
		buffer >> element->kf3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV4.khp
bool assign_GovSteamFV4_khp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4*>(base_class_ptr))
	{
		buffer >> element->khp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV4.kic
bool assign_GovSteamFV4_kic(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4*>(base_class_ptr))
	{
		buffer >> element->kic.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV4.kip
bool assign_GovSteamFV4_kip(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4*>(base_class_ptr))
	{
		buffer >> element->kip.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV4.kit
bool assign_GovSteamFV4_kit(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4*>(base_class_ptr))
	{
		buffer >> element->kit.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV4.kmp1
bool assign_GovSteamFV4_kmp1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4*>(base_class_ptr))
	{
		buffer >> element->kmp1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV4.kmp2
bool assign_GovSteamFV4_kmp2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4*>(base_class_ptr))
	{
		buffer >> element->kmp2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV4.kpc
bool assign_GovSteamFV4_kpc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4*>(base_class_ptr))
	{
		buffer >> element->kpc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV4.kpp
bool assign_GovSteamFV4_kpp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4*>(base_class_ptr))
	{
		buffer >> element->kpp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV4.kpt
bool assign_GovSteamFV4_kpt(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4*>(base_class_ptr))
	{
		buffer >> element->kpt.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV4.krc
bool assign_GovSteamFV4_krc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4*>(base_class_ptr))
	{
		buffer >> element->krc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV4.ksh
bool assign_GovSteamFV4_ksh(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4*>(base_class_ptr))
	{
		buffer >> element->ksh.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV4.lpi
bool assign_GovSteamFV4_lpi(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4*>(base_class_ptr))
	{
		buffer >> element->lpi.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV4.lps
bool assign_GovSteamFV4_lps(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4*>(base_class_ptr))
	{
		buffer >> element->lps.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV4.mnef
bool assign_GovSteamFV4_mnef(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4*>(base_class_ptr))
	{
		buffer >> element->mnef.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV4.mxef
bool assign_GovSteamFV4_mxef(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4*>(base_class_ptr))
	{
		buffer >> element->mxef.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV4.pr1
bool assign_GovSteamFV4_pr1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4*>(base_class_ptr))
	{
		buffer >> element->pr1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV4.pr2
bool assign_GovSteamFV4_pr2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4*>(base_class_ptr))
	{
		buffer >> element->pr2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV4.psmn
bool assign_GovSteamFV4_psmn(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4*>(base_class_ptr))
	{
		buffer >> element->psmn.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV4.rsmimn
bool assign_GovSteamFV4_rsmimn(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4*>(base_class_ptr))
	{
		buffer >> element->rsmimn.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV4.rsmimx
bool assign_GovSteamFV4_rsmimx(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4*>(base_class_ptr))
	{
		buffer >> element->rsmimx.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV4.rvgmn
bool assign_GovSteamFV4_rvgmn(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4*>(base_class_ptr))
	{
		buffer >> element->rvgmn.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV4.rvgmx
bool assign_GovSteamFV4_rvgmx(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4*>(base_class_ptr))
	{
		buffer >> element->rvgmx.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV4.srmn
bool assign_GovSteamFV4_srmn(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4*>(base_class_ptr))
	{
		buffer >> element->srmn.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV4.srmx
bool assign_GovSteamFV4_srmx(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4*>(base_class_ptr))
	{
		buffer >> element->srmx.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV4.srsmp
bool assign_GovSteamFV4_srsmp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4*>(base_class_ptr))
	{
		buffer >> element->srsmp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV4.svmn
bool assign_GovSteamFV4_svmn(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4*>(base_class_ptr))
	{
		buffer >> element->svmn;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV4.svmx
bool assign_GovSteamFV4_svmx(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4*>(base_class_ptr))
	{
		buffer >> element->svmx;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV4.ta
bool assign_GovSteamFV4_ta(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4*>(base_class_ptr))
	{
		buffer >> element->ta.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV4.tam
bool assign_GovSteamFV4_tam(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4*>(base_class_ptr))
	{
		buffer >> element->tam.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV4.tc
bool assign_GovSteamFV4_tc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4*>(base_class_ptr))
	{
		buffer >> element->tc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV4.tcm
bool assign_GovSteamFV4_tcm(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4*>(base_class_ptr))
	{
		buffer >> element->tcm.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV4.tdc
bool assign_GovSteamFV4_tdc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4*>(base_class_ptr))
	{
		buffer >> element->tdc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV4.tf1
bool assign_GovSteamFV4_tf1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4*>(base_class_ptr))
	{
		buffer >> element->tf1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV4.tf2
bool assign_GovSteamFV4_tf2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4*>(base_class_ptr))
	{
		buffer >> element->tf2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV4.thp
bool assign_GovSteamFV4_thp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4*>(base_class_ptr))
	{
		buffer >> element->thp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV4.tmp
bool assign_GovSteamFV4_tmp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4*>(base_class_ptr))
	{
		buffer >> element->tmp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV4.trh
bool assign_GovSteamFV4_trh(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4*>(base_class_ptr))
	{
		buffer >> element->trh.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV4.tv
bool assign_GovSteamFV4_tv(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4*>(base_class_ptr))
	{
		buffer >> element->tv.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV4.ty
bool assign_GovSteamFV4_ty(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4*>(base_class_ptr))
	{
		buffer >> element->ty.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV4.y
bool assign_GovSteamFV4_y(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4*>(base_class_ptr))
	{
		buffer >> element->y.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV4.yhpmn
bool assign_GovSteamFV4_yhpmn(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4*>(base_class_ptr))
	{
		buffer >> element->yhpmn.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV4.yhpmx
bool assign_GovSteamFV4_yhpmx(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4*>(base_class_ptr))
	{
		buffer >> element->yhpmx.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV4.ympmn
bool assign_GovSteamFV4_ympmn(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4*>(base_class_ptr))
	{
		buffer >> element->ympmn.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamFV4.ympmx
bool assign_GovSteamFV4_ympmx(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamFV4*>(base_class_ptr))
	{
		buffer >> element->ympmx.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamIEEE1.k
bool assign_GovSteamIEEE1_k(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamIEEE1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamIEEE1*>(base_class_ptr))
	{
		buffer >> element->k.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamIEEE1.k1
bool assign_GovSteamIEEE1_k1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamIEEE1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamIEEE1*>(base_class_ptr))
	{
		buffer >> element->k1;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamIEEE1.k2
bool assign_GovSteamIEEE1_k2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamIEEE1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamIEEE1*>(base_class_ptr))
	{
		buffer >> element->k2;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamIEEE1.k3
bool assign_GovSteamIEEE1_k3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamIEEE1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamIEEE1*>(base_class_ptr))
	{
		buffer >> element->k3;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamIEEE1.k4
bool assign_GovSteamIEEE1_k4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamIEEE1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamIEEE1*>(base_class_ptr))
	{
		buffer >> element->k4;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamIEEE1.k5
bool assign_GovSteamIEEE1_k5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamIEEE1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamIEEE1*>(base_class_ptr))
	{
		buffer >> element->k5;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamIEEE1.k6
bool assign_GovSteamIEEE1_k6(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamIEEE1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamIEEE1*>(base_class_ptr))
	{
		buffer >> element->k6;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamIEEE1.k7
bool assign_GovSteamIEEE1_k7(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamIEEE1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamIEEE1*>(base_class_ptr))
	{
		buffer >> element->k7;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamIEEE1.k8
bool assign_GovSteamIEEE1_k8(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamIEEE1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamIEEE1*>(base_class_ptr))
	{
		buffer >> element->k8;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamIEEE1.mwbase
bool assign_GovSteamIEEE1_mwbase(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamIEEE1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamIEEE1*>(base_class_ptr))
	{
		buffer >> element->mwbase.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamIEEE1.pmax
bool assign_GovSteamIEEE1_pmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamIEEE1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamIEEE1*>(base_class_ptr))
	{
		buffer >> element->pmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamIEEE1.pmin
bool assign_GovSteamIEEE1_pmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamIEEE1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamIEEE1*>(base_class_ptr))
	{
		buffer >> element->pmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamIEEE1.t1
bool assign_GovSteamIEEE1_t1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamIEEE1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamIEEE1*>(base_class_ptr))
	{
		buffer >> element->t1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamIEEE1.t2
bool assign_GovSteamIEEE1_t2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamIEEE1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamIEEE1*>(base_class_ptr))
	{
		buffer >> element->t2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamIEEE1.t3
bool assign_GovSteamIEEE1_t3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamIEEE1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamIEEE1*>(base_class_ptr))
	{
		buffer >> element->t3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamIEEE1.t4
bool assign_GovSteamIEEE1_t4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamIEEE1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamIEEE1*>(base_class_ptr))
	{
		buffer >> element->t4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamIEEE1.t5
bool assign_GovSteamIEEE1_t5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamIEEE1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamIEEE1*>(base_class_ptr))
	{
		buffer >> element->t5.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamIEEE1.t6
bool assign_GovSteamIEEE1_t6(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamIEEE1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamIEEE1*>(base_class_ptr))
	{
		buffer >> element->t6.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamIEEE1.t7
bool assign_GovSteamIEEE1_t7(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamIEEE1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamIEEE1*>(base_class_ptr))
	{
		buffer >> element->t7.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamIEEE1.uc
bool assign_GovSteamIEEE1_uc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamIEEE1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamIEEE1*>(base_class_ptr))
	{
		buffer >> element->uc;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamIEEE1.uo
bool assign_GovSteamIEEE1_uo(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamIEEE1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamIEEE1*>(base_class_ptr))
	{
		buffer >> element->uo;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamSGO.k1
bool assign_GovSteamSGO_k1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamSGO* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamSGO*>(base_class_ptr))
	{
		buffer >> element->k1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamSGO.k2
bool assign_GovSteamSGO_k2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamSGO* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamSGO*>(base_class_ptr))
	{
		buffer >> element->k2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamSGO.k3
bool assign_GovSteamSGO_k3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamSGO* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamSGO*>(base_class_ptr))
	{
		buffer >> element->k3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamSGO.mwbase
bool assign_GovSteamSGO_mwbase(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamSGO* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamSGO*>(base_class_ptr))
	{
		buffer >> element->mwbase.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamSGO.pmax
bool assign_GovSteamSGO_pmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamSGO* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamSGO*>(base_class_ptr))
	{
		buffer >> element->pmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamSGO.pmin
bool assign_GovSteamSGO_pmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamSGO* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamSGO*>(base_class_ptr))
	{
		buffer >> element->pmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamSGO.t1
bool assign_GovSteamSGO_t1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamSGO* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamSGO*>(base_class_ptr))
	{
		buffer >> element->t1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamSGO.t2
bool assign_GovSteamSGO_t2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamSGO* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamSGO*>(base_class_ptr))
	{
		buffer >> element->t2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamSGO.t3
bool assign_GovSteamSGO_t3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamSGO* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamSGO*>(base_class_ptr))
	{
		buffer >> element->t3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamSGO.t4
bool assign_GovSteamSGO_t4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamSGO* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamSGO*>(base_class_ptr))
	{
		buffer >> element->t4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamSGO.t5
bool assign_GovSteamSGO_t5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamSGO* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamSGO*>(base_class_ptr))
	{
		buffer >> element->t5.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GovSteamSGO.t6
bool assign_GovSteamSGO_t6(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamSGO* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineGovernorDynamics::GovSteamSGO*>(base_class_ptr))
	{
		buffer >> element->t6.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TurbLCFB1.db
bool assign_TurbLCFB1_db(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineLoadControllerDynamics::TurbLCFB1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineLoadControllerDynamics::TurbLCFB1*>(base_class_ptr))
	{
		buffer >> element->db.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TurbLCFB1.emax
bool assign_TurbLCFB1_emax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineLoadControllerDynamics::TurbLCFB1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineLoadControllerDynamics::TurbLCFB1*>(base_class_ptr))
	{
		buffer >> element->emax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TurbLCFB1.fb
bool assign_TurbLCFB1_fb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineLoadControllerDynamics::TurbLCFB1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineLoadControllerDynamics::TurbLCFB1*>(base_class_ptr))
	{
		buffer >> element->fb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TurbLCFB1.fbf
bool assign_TurbLCFB1_fbf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineLoadControllerDynamics::TurbLCFB1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineLoadControllerDynamics::TurbLCFB1*>(base_class_ptr))
	{
		buffer >> element->fbf;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TurbLCFB1.irmax
bool assign_TurbLCFB1_irmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineLoadControllerDynamics::TurbLCFB1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineLoadControllerDynamics::TurbLCFB1*>(base_class_ptr))
	{
		buffer >> element->irmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TurbLCFB1.ki
bool assign_TurbLCFB1_ki(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineLoadControllerDynamics::TurbLCFB1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineLoadControllerDynamics::TurbLCFB1*>(base_class_ptr))
	{
		buffer >> element->ki.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TurbLCFB1.kp
bool assign_TurbLCFB1_kp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineLoadControllerDynamics::TurbLCFB1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineLoadControllerDynamics::TurbLCFB1*>(base_class_ptr))
	{
		buffer >> element->kp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TurbLCFB1.mwbase
bool assign_TurbLCFB1_mwbase(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineLoadControllerDynamics::TurbLCFB1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineLoadControllerDynamics::TurbLCFB1*>(base_class_ptr))
	{
		buffer >> element->mwbase.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TurbLCFB1.pbf
bool assign_TurbLCFB1_pbf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineLoadControllerDynamics::TurbLCFB1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineLoadControllerDynamics::TurbLCFB1*>(base_class_ptr))
	{
		buffer >> element->pbf;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TurbLCFB1.pmwset
bool assign_TurbLCFB1_pmwset(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineLoadControllerDynamics::TurbLCFB1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineLoadControllerDynamics::TurbLCFB1*>(base_class_ptr))
	{
		buffer >> element->pmwset.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TurbLCFB1.speedReferenceGovernor
bool assign_TurbLCFB1_speedReferenceGovernor(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineLoadControllerDynamics::TurbLCFB1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineLoadControllerDynamics::TurbLCFB1*>(base_class_ptr))
	{
		buffer >> element->speedReferenceGovernor;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TurbLCFB1.tpelec
bool assign_TurbLCFB1_tpelec(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::TurbineLoadControllerDynamics::TurbLCFB1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::TurbineLoadControllerDynamics::TurbLCFB1*>(base_class_ptr))
	{
		buffer >> element->tpelec.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLim2Simplified.kui
bool assign_UnderexcLim2Simplified_kui(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLim2Simplified* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLim2Simplified*>(base_class_ptr))
	{
		buffer >> element->kui.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLim2Simplified.p0
bool assign_UnderexcLim2Simplified_p0(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLim2Simplified* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLim2Simplified*>(base_class_ptr))
	{
		buffer >> element->p0.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLim2Simplified.p1
bool assign_UnderexcLim2Simplified_p1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLim2Simplified* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLim2Simplified*>(base_class_ptr))
	{
		buffer >> element->p1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLim2Simplified.q0
bool assign_UnderexcLim2Simplified_q0(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLim2Simplified* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLim2Simplified*>(base_class_ptr))
	{
		buffer >> element->q0.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLim2Simplified.q1
bool assign_UnderexcLim2Simplified_q1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLim2Simplified* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLim2Simplified*>(base_class_ptr))
	{
		buffer >> element->q1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLim2Simplified.vuimax
bool assign_UnderexcLim2Simplified_vuimax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLim2Simplified* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLim2Simplified*>(base_class_ptr))
	{
		buffer >> element->vuimax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLim2Simplified.vuimin
bool assign_UnderexcLim2Simplified_vuimin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLim2Simplified* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLim2Simplified*>(base_class_ptr))
	{
		buffer >> element->vuimin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimIEEE1.kuc
bool assign_UnderexcLimIEEE1_kuc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE1*>(base_class_ptr))
	{
		buffer >> element->kuc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimIEEE1.kuf
bool assign_UnderexcLimIEEE1_kuf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE1*>(base_class_ptr))
	{
		buffer >> element->kuf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimIEEE1.kui
bool assign_UnderexcLimIEEE1_kui(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE1*>(base_class_ptr))
	{
		buffer >> element->kui.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimIEEE1.kul
bool assign_UnderexcLimIEEE1_kul(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE1*>(base_class_ptr))
	{
		buffer >> element->kul.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimIEEE1.kur
bool assign_UnderexcLimIEEE1_kur(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE1*>(base_class_ptr))
	{
		buffer >> element->kur.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimIEEE1.tu1
bool assign_UnderexcLimIEEE1_tu1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE1*>(base_class_ptr))
	{
		buffer >> element->tu1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimIEEE1.tu2
bool assign_UnderexcLimIEEE1_tu2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE1*>(base_class_ptr))
	{
		buffer >> element->tu2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimIEEE1.tu3
bool assign_UnderexcLimIEEE1_tu3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE1*>(base_class_ptr))
	{
		buffer >> element->tu3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimIEEE1.tu4
bool assign_UnderexcLimIEEE1_tu4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE1*>(base_class_ptr))
	{
		buffer >> element->tu4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimIEEE1.vucmax
bool assign_UnderexcLimIEEE1_vucmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE1*>(base_class_ptr))
	{
		buffer >> element->vucmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimIEEE1.vuimax
bool assign_UnderexcLimIEEE1_vuimax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE1*>(base_class_ptr))
	{
		buffer >> element->vuimax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimIEEE1.vuimin
bool assign_UnderexcLimIEEE1_vuimin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE1*>(base_class_ptr))
	{
		buffer >> element->vuimin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimIEEE1.vulmax
bool assign_UnderexcLimIEEE1_vulmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE1*>(base_class_ptr))
	{
		buffer >> element->vulmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimIEEE1.vulmin
bool assign_UnderexcLimIEEE1_vulmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE1*>(base_class_ptr))
	{
		buffer >> element->vulmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimIEEE1.vurmax
bool assign_UnderexcLimIEEE1_vurmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE1*>(base_class_ptr))
	{
		buffer >> element->vurmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimIEEE2.k1
bool assign_UnderexcLimIEEE2_k1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2*>(base_class_ptr))
	{
		buffer >> element->k1;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimIEEE2.k2
bool assign_UnderexcLimIEEE2_k2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2*>(base_class_ptr))
	{
		buffer >> element->k2;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimIEEE2.kfb
bool assign_UnderexcLimIEEE2_kfb(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2*>(base_class_ptr))
	{
		buffer >> element->kfb.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimIEEE2.kuf
bool assign_UnderexcLimIEEE2_kuf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2*>(base_class_ptr))
	{
		buffer >> element->kuf.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimIEEE2.kui
bool assign_UnderexcLimIEEE2_kui(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2*>(base_class_ptr))
	{
		buffer >> element->kui.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimIEEE2.kul
bool assign_UnderexcLimIEEE2_kul(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2*>(base_class_ptr))
	{
		buffer >> element->kul.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimIEEE2.p0
bool assign_UnderexcLimIEEE2_p0(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2*>(base_class_ptr))
	{
		buffer >> element->p0.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimIEEE2.p1
bool assign_UnderexcLimIEEE2_p1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2*>(base_class_ptr))
	{
		buffer >> element->p1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimIEEE2.p10
bool assign_UnderexcLimIEEE2_p10(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2*>(base_class_ptr))
	{
		buffer >> element->p10.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimIEEE2.p2
bool assign_UnderexcLimIEEE2_p2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2*>(base_class_ptr))
	{
		buffer >> element->p2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimIEEE2.p3
bool assign_UnderexcLimIEEE2_p3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2*>(base_class_ptr))
	{
		buffer >> element->p3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimIEEE2.p4
bool assign_UnderexcLimIEEE2_p4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2*>(base_class_ptr))
	{
		buffer >> element->p4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimIEEE2.p5
bool assign_UnderexcLimIEEE2_p5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2*>(base_class_ptr))
	{
		buffer >> element->p5.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimIEEE2.p6
bool assign_UnderexcLimIEEE2_p6(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2*>(base_class_ptr))
	{
		buffer >> element->p6.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimIEEE2.p7
bool assign_UnderexcLimIEEE2_p7(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2*>(base_class_ptr))
	{
		buffer >> element->p7.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimIEEE2.p8
bool assign_UnderexcLimIEEE2_p8(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2*>(base_class_ptr))
	{
		buffer >> element->p8.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimIEEE2.p9
bool assign_UnderexcLimIEEE2_p9(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2*>(base_class_ptr))
	{
		buffer >> element->p9.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimIEEE2.q0
bool assign_UnderexcLimIEEE2_q0(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2*>(base_class_ptr))
	{
		buffer >> element->q0.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimIEEE2.q1
bool assign_UnderexcLimIEEE2_q1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2*>(base_class_ptr))
	{
		buffer >> element->q1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimIEEE2.q10
bool assign_UnderexcLimIEEE2_q10(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2*>(base_class_ptr))
	{
		buffer >> element->q10.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimIEEE2.q2
bool assign_UnderexcLimIEEE2_q2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2*>(base_class_ptr))
	{
		buffer >> element->q2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimIEEE2.q3
bool assign_UnderexcLimIEEE2_q3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2*>(base_class_ptr))
	{
		buffer >> element->q3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimIEEE2.q4
bool assign_UnderexcLimIEEE2_q4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2*>(base_class_ptr))
	{
		buffer >> element->q4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimIEEE2.q5
bool assign_UnderexcLimIEEE2_q5(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2*>(base_class_ptr))
	{
		buffer >> element->q5.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimIEEE2.q6
bool assign_UnderexcLimIEEE2_q6(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2*>(base_class_ptr))
	{
		buffer >> element->q6.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimIEEE2.q7
bool assign_UnderexcLimIEEE2_q7(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2*>(base_class_ptr))
	{
		buffer >> element->q7.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimIEEE2.q8
bool assign_UnderexcLimIEEE2_q8(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2*>(base_class_ptr))
	{
		buffer >> element->q8.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimIEEE2.q9
bool assign_UnderexcLimIEEE2_q9(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2*>(base_class_ptr))
	{
		buffer >> element->q9.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimIEEE2.tu1
bool assign_UnderexcLimIEEE2_tu1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2*>(base_class_ptr))
	{
		buffer >> element->tu1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimIEEE2.tu2
bool assign_UnderexcLimIEEE2_tu2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2*>(base_class_ptr))
	{
		buffer >> element->tu2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimIEEE2.tu3
bool assign_UnderexcLimIEEE2_tu3(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2*>(base_class_ptr))
	{
		buffer >> element->tu3.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimIEEE2.tu4
bool assign_UnderexcLimIEEE2_tu4(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2*>(base_class_ptr))
	{
		buffer >> element->tu4.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimIEEE2.tul
bool assign_UnderexcLimIEEE2_tul(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2*>(base_class_ptr))
	{
		buffer >> element->tul.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimIEEE2.tup
bool assign_UnderexcLimIEEE2_tup(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2*>(base_class_ptr))
	{
		buffer >> element->tup.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimIEEE2.tuq
bool assign_UnderexcLimIEEE2_tuq(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2*>(base_class_ptr))
	{
		buffer >> element->tuq.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimIEEE2.tuv
bool assign_UnderexcLimIEEE2_tuv(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2*>(base_class_ptr))
	{
		buffer >> element->tuv.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimIEEE2.vuimax
bool assign_UnderexcLimIEEE2_vuimax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2*>(base_class_ptr))
	{
		buffer >> element->vuimax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimIEEE2.vuimin
bool assign_UnderexcLimIEEE2_vuimin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2*>(base_class_ptr))
	{
		buffer >> element->vuimin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimIEEE2.vulmax
bool assign_UnderexcLimIEEE2_vulmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2*>(base_class_ptr))
	{
		buffer >> element->vulmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimIEEE2.vulmin
bool assign_UnderexcLimIEEE2_vulmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimIEEE2*>(base_class_ptr))
	{
		buffer >> element->vulmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimX1.k
bool assign_UnderexcLimX1_k(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimX1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimX1*>(base_class_ptr))
	{
		buffer >> element->k.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimX1.kf2
bool assign_UnderexcLimX1_kf2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimX1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimX1*>(base_class_ptr))
	{
		buffer >> element->kf2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimX1.km
bool assign_UnderexcLimX1_km(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimX1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimX1*>(base_class_ptr))
	{
		buffer >> element->km.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimX1.melmax
bool assign_UnderexcLimX1_melmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimX1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimX1*>(base_class_ptr))
	{
		buffer >> element->melmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimX1.tf2
bool assign_UnderexcLimX1_tf2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimX1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimX1*>(base_class_ptr))
	{
		buffer >> element->tf2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimX1.tm
bool assign_UnderexcLimX1_tm(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimX1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimX1*>(base_class_ptr))
	{
		buffer >> element->tm.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimX2.kf2
bool assign_UnderexcLimX2_kf2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimX2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimX2*>(base_class_ptr))
	{
		buffer >> element->kf2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimX2.km
bool assign_UnderexcLimX2_km(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimX2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimX2*>(base_class_ptr))
	{
		buffer >> element->km.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimX2.melmax
bool assign_UnderexcLimX2_melmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimX2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimX2*>(base_class_ptr))
	{
		buffer >> element->melmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimX2.qo
bool assign_UnderexcLimX2_qo(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimX2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimX2*>(base_class_ptr))
	{
		buffer >> element->qo.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimX2.r
bool assign_UnderexcLimX2_r(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimX2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimX2*>(base_class_ptr))
	{
		buffer >> element->r.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimX2.tf2
bool assign_UnderexcLimX2_tf2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimX2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimX2*>(base_class_ptr))
	{
		buffer >> element->tf2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcLimX2.tm
bool assign_UnderexcLimX2_tm(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimX2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::UnderexcitationLimiterDynamics::UnderexcLimX2*>(base_class_ptr))
	{
		buffer >> element->tm.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:VAdjIEEE.adjslew
bool assign_VAdjIEEE_adjslew(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::VoltageAdjusterDynamics::VAdjIEEE* element = dynamic_cast<IEC61970::Dynamics::StandardModels::VoltageAdjusterDynamics::VAdjIEEE*>(base_class_ptr))
	{
		buffer >> element->adjslew;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:VAdjIEEE.taoff
bool assign_VAdjIEEE_taoff(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::VoltageAdjusterDynamics::VAdjIEEE* element = dynamic_cast<IEC61970::Dynamics::StandardModels::VoltageAdjusterDynamics::VAdjIEEE*>(base_class_ptr))
	{
		buffer >> element->taoff.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:VAdjIEEE.taon
bool assign_VAdjIEEE_taon(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::VoltageAdjusterDynamics::VAdjIEEE* element = dynamic_cast<IEC61970::Dynamics::StandardModels::VoltageAdjusterDynamics::VAdjIEEE*>(base_class_ptr))
	{
		buffer >> element->taon.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:VAdjIEEE.vadjf
bool assign_VAdjIEEE_vadjf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::VoltageAdjusterDynamics::VAdjIEEE* element = dynamic_cast<IEC61970::Dynamics::StandardModels::VoltageAdjusterDynamics::VAdjIEEE*>(base_class_ptr))
	{
		buffer >> element->vadjf;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:VAdjIEEE.vadjmax
bool assign_VAdjIEEE_vadjmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::VoltageAdjusterDynamics::VAdjIEEE* element = dynamic_cast<IEC61970::Dynamics::StandardModels::VoltageAdjusterDynamics::VAdjIEEE*>(base_class_ptr))
	{
		buffer >> element->vadjmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:VAdjIEEE.vadjmin
bool assign_VAdjIEEE_vadjmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::VoltageAdjusterDynamics::VAdjIEEE* element = dynamic_cast<IEC61970::Dynamics::StandardModels::VoltageAdjusterDynamics::VAdjIEEE*>(base_class_ptr))
	{
		buffer >> element->vadjmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:VCompIEEEType2.tr
bool assign_VCompIEEEType2_tr(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::VoltageCompensatorDynamics::VCompIEEEType2* element = dynamic_cast<IEC61970::Dynamics::StandardModels::VoltageCompensatorDynamics::VCompIEEEType2*>(base_class_ptr))
	{
		buffer >> element->tr.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GenICompensationForGenJ.rcij
bool assign_GenICompensationForGenJ_rcij(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::VoltageCompensatorDynamics::GenICompensationForGenJ* element = dynamic_cast<IEC61970::Dynamics::StandardModels::VoltageCompensatorDynamics::GenICompensationForGenJ*>(base_class_ptr))
	{
		buffer >> element->rcij.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:GenICompensationForGenJ.xcij
bool assign_GenICompensationForGenJ_xcij(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::VoltageCompensatorDynamics::GenICompensationForGenJ* element = dynamic_cast<IEC61970::Dynamics::StandardModels::VoltageCompensatorDynamics::GenICompensationForGenJ*>(base_class_ptr))
	{
		buffer >> element->xcij.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:VCompIEEEType1.rc
bool assign_VCompIEEEType1_rc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::VoltageCompensatorDynamics::VCompIEEEType1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::VoltageCompensatorDynamics::VCompIEEEType1*>(base_class_ptr))
	{
		buffer >> element->rc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:VCompIEEEType1.tr
bool assign_VCompIEEEType1_tr(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::VoltageCompensatorDynamics::VCompIEEEType1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::VoltageCompensatorDynamics::VCompIEEEType1*>(base_class_ptr))
	{
		buffer >> element->tr.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:VCompIEEEType1.xc
bool assign_VCompIEEEType1_xc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::VoltageCompensatorDynamics::VCompIEEEType1* element = dynamic_cast<IEC61970::Dynamics::StandardModels::VoltageCompensatorDynamics::VCompIEEEType1*>(base_class_ptr))
	{
		buffer >> element->xc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindGenTurbineType3IEC.dipmax
bool assign_WindGenTurbineType3IEC_dipmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindGenTurbineType3IEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindGenTurbineType3IEC*>(base_class_ptr))
	{
		buffer >> element->dipmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindGenTurbineType3IEC.diqmax
bool assign_WindGenTurbineType3IEC_diqmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindGenTurbineType3IEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindGenTurbineType3IEC*>(base_class_ptr))
	{
		buffer >> element->diqmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindAeroLinearIEC.dpomega
bool assign_WindAeroLinearIEC_dpomega(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindAeroLinearIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindAeroLinearIEC*>(base_class_ptr))
	{
		buffer >> element->dpomega.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindAeroLinearIEC.dptheta
bool assign_WindAeroLinearIEC_dptheta(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindAeroLinearIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindAeroLinearIEC*>(base_class_ptr))
	{
		buffer >> element->dptheta.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindAeroLinearIEC.omegazero
bool assign_WindAeroLinearIEC_omegazero(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindAeroLinearIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindAeroLinearIEC*>(base_class_ptr))
	{
		buffer >> element->omegazero.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindAeroLinearIEC.pavail
bool assign_WindAeroLinearIEC_pavail(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindAeroLinearIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindAeroLinearIEC*>(base_class_ptr))
	{
		buffer >> element->pavail.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindAeroLinearIEC.thetazero
bool assign_WindAeroLinearIEC_thetazero(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindAeroLinearIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindAeroLinearIEC*>(base_class_ptr))
	{
		buffer >> element->thetazero.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContCurrLimIEC.imax
bool assign_WindContCurrLimIEC_imax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContCurrLimIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContCurrLimIEC*>(base_class_ptr))
	{
		buffer >> element->imax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContCurrLimIEC.imaxdip
bool assign_WindContCurrLimIEC_imaxdip(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContCurrLimIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContCurrLimIEC*>(base_class_ptr))
	{
		buffer >> element->imaxdip.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContCurrLimIEC.mdfslim
bool assign_WindContCurrLimIEC_mdfslim(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContCurrLimIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContCurrLimIEC*>(base_class_ptr))
	{
		buffer >> element->mdfslim;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContCurrLimIEC.mqpri
bool assign_WindContCurrLimIEC_mqpri(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContCurrLimIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContCurrLimIEC*>(base_class_ptr))
	{
		buffer >> element->mqpri;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContCurrLimIEC.tufilt
bool assign_WindContCurrLimIEC_tufilt(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContCurrLimIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContCurrLimIEC*>(base_class_ptr))
	{
		buffer >> element->tufilt.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContPitchAngleIEC.dthetamax
bool assign_WindContPitchAngleIEC_dthetamax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContPitchAngleIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContPitchAngleIEC*>(base_class_ptr))
	{
		buffer >> element->dthetamax;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContPitchAngleIEC.dthetamin
bool assign_WindContPitchAngleIEC_dthetamin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContPitchAngleIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContPitchAngleIEC*>(base_class_ptr))
	{
		buffer >> element->dthetamin;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContPitchAngleIEC.kic
bool assign_WindContPitchAngleIEC_kic(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContPitchAngleIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContPitchAngleIEC*>(base_class_ptr))
	{
		buffer >> element->kic.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContPitchAngleIEC.kiomega
bool assign_WindContPitchAngleIEC_kiomega(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContPitchAngleIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContPitchAngleIEC*>(base_class_ptr))
	{
		buffer >> element->kiomega.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContPitchAngleIEC.kpc
bool assign_WindContPitchAngleIEC_kpc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContPitchAngleIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContPitchAngleIEC*>(base_class_ptr))
	{
		buffer >> element->kpc.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContPitchAngleIEC.kpomega
bool assign_WindContPitchAngleIEC_kpomega(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContPitchAngleIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContPitchAngleIEC*>(base_class_ptr))
	{
		buffer >> element->kpomega.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContPitchAngleIEC.kpx
bool assign_WindContPitchAngleIEC_kpx(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContPitchAngleIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContPitchAngleIEC*>(base_class_ptr))
	{
		buffer >> element->kpx.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContPitchAngleIEC.thetamax
bool assign_WindContPitchAngleIEC_thetamax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContPitchAngleIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContPitchAngleIEC*>(base_class_ptr))
	{
		buffer >> element->thetamax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContPitchAngleIEC.thetamin
bool assign_WindContPitchAngleIEC_thetamin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContPitchAngleIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContPitchAngleIEC*>(base_class_ptr))
	{
		buffer >> element->thetamin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContPitchAngleIEC.ttheta
bool assign_WindContPitchAngleIEC_ttheta(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContPitchAngleIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContPitchAngleIEC*>(base_class_ptr))
	{
		buffer >> element->ttheta.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContPType3IEC.dpmax
bool assign_WindContPType3IEC_dpmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContPType3IEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContPType3IEC*>(base_class_ptr))
	{
		buffer >> element->dpmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContPType3IEC.dtrisemaxlvrt
bool assign_WindContPType3IEC_dtrisemaxlvrt(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContPType3IEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContPType3IEC*>(base_class_ptr))
	{
		buffer >> element->dtrisemaxlvrt.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContPType3IEC.kdtd
bool assign_WindContPType3IEC_kdtd(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContPType3IEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContPType3IEC*>(base_class_ptr))
	{
		buffer >> element->kdtd.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContPType3IEC.kip
bool assign_WindContPType3IEC_kip(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContPType3IEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContPType3IEC*>(base_class_ptr))
	{
		buffer >> element->kip.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContPType3IEC.kpp
bool assign_WindContPType3IEC_kpp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContPType3IEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContPType3IEC*>(base_class_ptr))
	{
		buffer >> element->kpp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContPType3IEC.mplvrt
bool assign_WindContPType3IEC_mplvrt(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContPType3IEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContPType3IEC*>(base_class_ptr))
	{
		buffer >> element->mplvrt;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContPType3IEC.omegaoffset
bool assign_WindContPType3IEC_omegaoffset(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContPType3IEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContPType3IEC*>(base_class_ptr))
	{
		buffer >> element->omegaoffset.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContPType3IEC.pdtdmax
bool assign_WindContPType3IEC_pdtdmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContPType3IEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContPType3IEC*>(base_class_ptr))
	{
		buffer >> element->pdtdmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContPType3IEC.rramp
bool assign_WindContPType3IEC_rramp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContPType3IEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContPType3IEC*>(base_class_ptr))
	{
		buffer >> element->rramp.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContPType3IEC.tdvs
bool assign_WindContPType3IEC_tdvs(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContPType3IEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContPType3IEC*>(base_class_ptr))
	{
		buffer >> element->tdvs.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContPType3IEC.temin
bool assign_WindContPType3IEC_temin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContPType3IEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContPType3IEC*>(base_class_ptr))
	{
		buffer >> element->temin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContPType3IEC.tomegafilt
bool assign_WindContPType3IEC_tomegafilt(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContPType3IEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContPType3IEC*>(base_class_ptr))
	{
		buffer >> element->tomegafilt.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContPType3IEC.tpfilt
bool assign_WindContPType3IEC_tpfilt(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContPType3IEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContPType3IEC*>(base_class_ptr))
	{
		buffer >> element->tpfilt.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContPType3IEC.tpord
bool assign_WindContPType3IEC_tpord(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContPType3IEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContPType3IEC*>(base_class_ptr))
	{
		buffer >> element->tpord.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContPType3IEC.tufilt
bool assign_WindContPType3IEC_tufilt(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContPType3IEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContPType3IEC*>(base_class_ptr))
	{
		buffer >> element->tufilt.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContPType3IEC.tuscale
bool assign_WindContPType3IEC_tuscale(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContPType3IEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContPType3IEC*>(base_class_ptr))
	{
		buffer >> element->tuscale.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContPType3IEC.twref
bool assign_WindContPType3IEC_twref(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContPType3IEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContPType3IEC*>(base_class_ptr))
	{
		buffer >> element->twref.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContPType3IEC.udvs
bool assign_WindContPType3IEC_udvs(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContPType3IEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContPType3IEC*>(base_class_ptr))
	{
		buffer >> element->udvs.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContPType3IEC.updip
bool assign_WindContPType3IEC_updip(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContPType3IEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContPType3IEC*>(base_class_ptr))
	{
		buffer >> element->updip.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContPType3IEC.wdtd
bool assign_WindContPType3IEC_wdtd(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContPType3IEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContPType3IEC*>(base_class_ptr))
	{
		buffer >> element->wdtd.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContPType3IEC.zeta
bool assign_WindContPType3IEC_zeta(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContPType3IEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContPType3IEC*>(base_class_ptr))
	{
		buffer >> element->zeta;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindGenType4IEC.dipmax
bool assign_WindGenType4IEC_dipmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindGenType4IEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindGenType4IEC*>(base_class_ptr))
	{
		buffer >> element->dipmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindGenType4IEC.diqmax
bool assign_WindGenType4IEC_diqmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindGenType4IEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindGenType4IEC*>(base_class_ptr))
	{
		buffer >> element->diqmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindGenType4IEC.diqmin
bool assign_WindGenType4IEC_diqmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindGenType4IEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindGenType4IEC*>(base_class_ptr))
	{
		buffer >> element->diqmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindGenType4IEC.tg
bool assign_WindGenType4IEC_tg(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindGenType4IEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindGenType4IEC*>(base_class_ptr))
	{
		buffer >> element->tg.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContPType4aIEC.dpmax
bool assign_WindContPType4aIEC_dpmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContPType4aIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContPType4aIEC*>(base_class_ptr))
	{
		buffer >> element->dpmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContPType4aIEC.tpord
bool assign_WindContPType4aIEC_tpord(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContPType4aIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContPType4aIEC*>(base_class_ptr))
	{
		buffer >> element->tpord.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContPType4aIEC.tufilt
bool assign_WindContPType4aIEC_tufilt(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContPType4aIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContPType4aIEC*>(base_class_ptr))
	{
		buffer >> element->tufilt.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContPType4bIEC.dpmax
bool assign_WindContPType4bIEC_dpmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContPType4bIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContPType4bIEC*>(base_class_ptr))
	{
		buffer >> element->dpmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContPType4bIEC.tpaero
bool assign_WindContPType4bIEC_tpaero(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContPType4bIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContPType4bIEC*>(base_class_ptr))
	{
		buffer >> element->tpaero.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContPType4bIEC.tpord
bool assign_WindContPType4bIEC_tpord(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContPType4bIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContPType4bIEC*>(base_class_ptr))
	{
		buffer >> element->tpord.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContPType4bIEC.tufilt
bool assign_WindContPType4bIEC_tufilt(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContPType4bIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContPType4bIEC*>(base_class_ptr))
	{
		buffer >> element->tufilt.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContQIEC.iqh1
bool assign_WindContQIEC_iqh1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContQIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContQIEC*>(base_class_ptr))
	{
		buffer >> element->iqh1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContQIEC.iqmax
bool assign_WindContQIEC_iqmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContQIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContQIEC*>(base_class_ptr))
	{
		buffer >> element->iqmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContQIEC.iqmin
bool assign_WindContQIEC_iqmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContQIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContQIEC*>(base_class_ptr))
	{
		buffer >> element->iqmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContQIEC.iqpost
bool assign_WindContQIEC_iqpost(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContQIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContQIEC*>(base_class_ptr))
	{
		buffer >> element->iqpost.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContQIEC.kiq
bool assign_WindContQIEC_kiq(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContQIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContQIEC*>(base_class_ptr))
	{
		buffer >> element->kiq.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContQIEC.kiu
bool assign_WindContQIEC_kiu(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContQIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContQIEC*>(base_class_ptr))
	{
		buffer >> element->kiu.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContQIEC.kpq
bool assign_WindContQIEC_kpq(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContQIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContQIEC*>(base_class_ptr))
	{
		buffer >> element->kpq.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContQIEC.kpu
bool assign_WindContQIEC_kpu(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContQIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContQIEC*>(base_class_ptr))
	{
		buffer >> element->kpu.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContQIEC.kqv
bool assign_WindContQIEC_kqv(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContQIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContQIEC*>(base_class_ptr))
	{
		buffer >> element->kqv.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContQIEC.qmax
bool assign_WindContQIEC_qmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContQIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContQIEC*>(base_class_ptr))
	{
		buffer >> element->qmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContQIEC.qmin
bool assign_WindContQIEC_qmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContQIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContQIEC*>(base_class_ptr))
	{
		buffer >> element->qmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContQIEC.rdroop
bool assign_WindContQIEC_rdroop(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContQIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContQIEC*>(base_class_ptr))
	{
		buffer >> element->rdroop.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContQIEC.tiq
bool assign_WindContQIEC_tiq(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContQIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContQIEC*>(base_class_ptr))
	{
		buffer >> element->tiq.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContQIEC.tpfilt
bool assign_WindContQIEC_tpfilt(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContQIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContQIEC*>(base_class_ptr))
	{
		buffer >> element->tpfilt.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContQIEC.tpost
bool assign_WindContQIEC_tpost(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContQIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContQIEC*>(base_class_ptr))
	{
		buffer >> element->tpost.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContQIEC.tqord
bool assign_WindContQIEC_tqord(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContQIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContQIEC*>(base_class_ptr))
	{
		buffer >> element->tqord.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContQIEC.tufilt
bool assign_WindContQIEC_tufilt(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContQIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContQIEC*>(base_class_ptr))
	{
		buffer >> element->tufilt.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContQIEC.udb1
bool assign_WindContQIEC_udb1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContQIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContQIEC*>(base_class_ptr))
	{
		buffer >> element->udb1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContQIEC.udb2
bool assign_WindContQIEC_udb2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContQIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContQIEC*>(base_class_ptr))
	{
		buffer >> element->udb2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContQIEC.umax
bool assign_WindContQIEC_umax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContQIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContQIEC*>(base_class_ptr))
	{
		buffer >> element->umax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContQIEC.umin
bool assign_WindContQIEC_umin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContQIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContQIEC*>(base_class_ptr))
	{
		buffer >> element->umin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContQIEC.uqdip
bool assign_WindContQIEC_uqdip(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContQIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContQIEC*>(base_class_ptr))
	{
		buffer >> element->uqdip.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContQIEC.uref0
bool assign_WindContQIEC_uref0(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContQIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContQIEC*>(base_class_ptr))
	{
		buffer >> element->uref0.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContQIEC.windLVRTQcontrolModesType
bool assign_WindContQIEC_windLVRTQcontrolModesType(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContQIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContQIEC*>(base_class_ptr))
	{
		buffer >> element->windLVRTQcontrolModesType;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContQIEC.windQcontrolModesType
bool assign_WindContQIEC_windQcontrolModesType(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContQIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContQIEC*>(base_class_ptr))
	{
		buffer >> element->windQcontrolModesType;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContQIEC.xdroop
bool assign_WindContQIEC_xdroop(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContQIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContQIEC*>(base_class_ptr))
	{
		buffer >> element->xdroop.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContRotorRIEC.kirr
bool assign_WindContRotorRIEC_kirr(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContRotorRIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContRotorRIEC*>(base_class_ptr))
	{
		buffer >> element->kirr.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContRotorRIEC.komegafilt
bool assign_WindContRotorRIEC_komegafilt(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContRotorRIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContRotorRIEC*>(base_class_ptr))
	{
		buffer >> element->komegafilt;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContRotorRIEC.kpfilt
bool assign_WindContRotorRIEC_kpfilt(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContRotorRIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContRotorRIEC*>(base_class_ptr))
	{
		buffer >> element->kpfilt;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContRotorRIEC.kprr
bool assign_WindContRotorRIEC_kprr(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContRotorRIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContRotorRIEC*>(base_class_ptr))
	{
		buffer >> element->kprr.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContRotorRIEC.rmax
bool assign_WindContRotorRIEC_rmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContRotorRIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContRotorRIEC*>(base_class_ptr))
	{
		buffer >> element->rmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContRotorRIEC.rmin
bool assign_WindContRotorRIEC_rmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContRotorRIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContRotorRIEC*>(base_class_ptr))
	{
		buffer >> element->rmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContRotorRIEC.tomegafilt
bool assign_WindContRotorRIEC_tomegafilt(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContRotorRIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContRotorRIEC*>(base_class_ptr))
	{
		buffer >> element->tomegafilt.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindContRotorRIEC.tpfilt
bool assign_WindContRotorRIEC_tpfilt(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindContRotorRIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindContRotorRIEC*>(base_class_ptr))
	{
		buffer >> element->tpfilt.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindPlantReactiveControlIEC.kiwpx
bool assign_WindPlantReactiveControlIEC_kiwpx(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindPlantReactiveControlIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindPlantReactiveControlIEC*>(base_class_ptr))
	{
		buffer >> element->kiwpx;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindPlantReactiveControlIEC.kpwpx
bool assign_WindPlantReactiveControlIEC_kpwpx(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindPlantReactiveControlIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindPlantReactiveControlIEC*>(base_class_ptr))
	{
		buffer >> element->kpwpx;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindPlantReactiveControlIEC.kwpqu
bool assign_WindPlantReactiveControlIEC_kwpqu(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindPlantReactiveControlIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindPlantReactiveControlIEC*>(base_class_ptr))
	{
		buffer >> element->kwpqu.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindPlantReactiveControlIEC.mwppf
bool assign_WindPlantReactiveControlIEC_mwppf(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindPlantReactiveControlIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindPlantReactiveControlIEC*>(base_class_ptr))
	{
		buffer >> element->mwppf;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindPlantReactiveControlIEC.mwpu
bool assign_WindPlantReactiveControlIEC_mwpu(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindPlantReactiveControlIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindPlantReactiveControlIEC*>(base_class_ptr))
	{
		buffer >> element->mwpu;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindPlantReactiveControlIEC.twppfilt
bool assign_WindPlantReactiveControlIEC_twppfilt(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindPlantReactiveControlIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindPlantReactiveControlIEC*>(base_class_ptr))
	{
		buffer >> element->twppfilt.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindPlantReactiveControlIEC.twpqfilt
bool assign_WindPlantReactiveControlIEC_twpqfilt(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindPlantReactiveControlIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindPlantReactiveControlIEC*>(base_class_ptr))
	{
		buffer >> element->twpqfilt.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindPlantReactiveControlIEC.twpufilt
bool assign_WindPlantReactiveControlIEC_twpufilt(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindPlantReactiveControlIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindPlantReactiveControlIEC*>(base_class_ptr))
	{
		buffer >> element->twpufilt.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindPlantReactiveControlIEC.txft
bool assign_WindPlantReactiveControlIEC_txft(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindPlantReactiveControlIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindPlantReactiveControlIEC*>(base_class_ptr))
	{
		buffer >> element->txft.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindPlantReactiveControlIEC.txfv
bool assign_WindPlantReactiveControlIEC_txfv(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindPlantReactiveControlIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindPlantReactiveControlIEC*>(base_class_ptr))
	{
		buffer >> element->txfv.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindPlantReactiveControlIEC.uwpqdip
bool assign_WindPlantReactiveControlIEC_uwpqdip(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindPlantReactiveControlIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindPlantReactiveControlIEC*>(base_class_ptr))
	{
		buffer >> element->uwpqdip.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindPlantReactiveControlIEC.xrefmax
bool assign_WindPlantReactiveControlIEC_xrefmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindPlantReactiveControlIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindPlantReactiveControlIEC*>(base_class_ptr))
	{
		buffer >> element->xrefmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindPlantReactiveControlIEC.xrefmin
bool assign_WindPlantReactiveControlIEC_xrefmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindPlantReactiveControlIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindPlantReactiveControlIEC*>(base_class_ptr))
	{
		buffer >> element->xrefmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindPlantFreqPcontrolIEC.dprefmax
bool assign_WindPlantFreqPcontrolIEC_dprefmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindPlantFreqPcontrolIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindPlantFreqPcontrolIEC*>(base_class_ptr))
	{
		buffer >> element->dprefmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindPlantFreqPcontrolIEC.dprefmin
bool assign_WindPlantFreqPcontrolIEC_dprefmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindPlantFreqPcontrolIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindPlantFreqPcontrolIEC*>(base_class_ptr))
	{
		buffer >> element->dprefmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindPlantFreqPcontrolIEC.kiwpp
bool assign_WindPlantFreqPcontrolIEC_kiwpp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindPlantFreqPcontrolIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindPlantFreqPcontrolIEC*>(base_class_ptr))
	{
		buffer >> element->kiwpp;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindPlantFreqPcontrolIEC.kpwpp
bool assign_WindPlantFreqPcontrolIEC_kpwpp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindPlantFreqPcontrolIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindPlantFreqPcontrolIEC*>(base_class_ptr))
	{
		buffer >> element->kpwpp;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindPlantFreqPcontrolIEC.prefmax
bool assign_WindPlantFreqPcontrolIEC_prefmax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindPlantFreqPcontrolIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindPlantFreqPcontrolIEC*>(base_class_ptr))
	{
		buffer >> element->prefmax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindPlantFreqPcontrolIEC.prefmin
bool assign_WindPlantFreqPcontrolIEC_prefmin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindPlantFreqPcontrolIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindPlantFreqPcontrolIEC*>(base_class_ptr))
	{
		buffer >> element->prefmin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindPlantFreqPcontrolIEC.tpft
bool assign_WindPlantFreqPcontrolIEC_tpft(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindPlantFreqPcontrolIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindPlantFreqPcontrolIEC*>(base_class_ptr))
	{
		buffer >> element->tpft.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindPlantFreqPcontrolIEC.tpfv
bool assign_WindPlantFreqPcontrolIEC_tpfv(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindPlantFreqPcontrolIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindPlantFreqPcontrolIEC*>(base_class_ptr))
	{
		buffer >> element->tpfv.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindPlantFreqPcontrolIEC.twpffilt
bool assign_WindPlantFreqPcontrolIEC_twpffilt(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindPlantFreqPcontrolIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindPlantFreqPcontrolIEC*>(base_class_ptr))
	{
		buffer >> element->twpffilt.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindPlantFreqPcontrolIEC.twppfilt
bool assign_WindPlantFreqPcontrolIEC_twppfilt(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindPlantFreqPcontrolIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindPlantFreqPcontrolIEC*>(base_class_ptr))
	{
		buffer >> element->twppfilt.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindDynamicsLookupTable.input
bool assign_WindDynamicsLookupTable_input(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindDynamicsLookupTable* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindDynamicsLookupTable*>(base_class_ptr))
	{
		buffer >> element->input;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindDynamicsLookupTable.lookupTableFunctionType
bool assign_WindDynamicsLookupTable_lookupTableFunctionType(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindDynamicsLookupTable* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindDynamicsLookupTable*>(base_class_ptr))
	{
		buffer >> element->lookupTableFunctionType;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindDynamicsLookupTable.output
bool assign_WindDynamicsLookupTable_output(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindDynamicsLookupTable* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindDynamicsLookupTable*>(base_class_ptr))
	{
		buffer >> element->output;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindDynamicsLookupTable.sequence
bool assign_WindDynamicsLookupTable_sequence(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindDynamicsLookupTable* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindDynamicsLookupTable*>(base_class_ptr))
	{
		buffer >> element->sequence;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindGenTurbineType3aIEC.kpc
bool assign_WindGenTurbineType3aIEC_kpc(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindGenTurbineType3aIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindGenTurbineType3aIEC*>(base_class_ptr))
	{
		buffer >> element->kpc;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindGenTurbineType3aIEC.tic
bool assign_WindGenTurbineType3aIEC_tic(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindGenTurbineType3aIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindGenTurbineType3aIEC*>(base_class_ptr))
	{
		buffer >> element->tic.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindGenTurbineType3aIEC.xs
bool assign_WindGenTurbineType3aIEC_xs(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindGenTurbineType3aIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindGenTurbineType3aIEC*>(base_class_ptr))
	{
		buffer >> element->xs.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindGenTurbineType3bIEC.fducw
bool assign_WindGenTurbineType3bIEC_fducw(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindGenTurbineType3bIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindGenTurbineType3bIEC*>(base_class_ptr))
	{
		buffer >> element->fducw;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindGenTurbineType3bIEC.mwtcwp
bool assign_WindGenTurbineType3bIEC_mwtcwp(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindGenTurbineType3bIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindGenTurbineType3bIEC*>(base_class_ptr))
	{
		buffer >> element->mwtcwp;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindGenTurbineType3bIEC.tg
bool assign_WindGenTurbineType3bIEC_tg(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindGenTurbineType3bIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindGenTurbineType3bIEC*>(base_class_ptr))
	{
		buffer >> element->tg.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindGenTurbineType3bIEC.two
bool assign_WindGenTurbineType3bIEC_two(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindGenTurbineType3bIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindGenTurbineType3bIEC*>(base_class_ptr))
	{
		buffer >> element->two.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindGenTurbineType3bIEC.xs
bool assign_WindGenTurbineType3bIEC_xs(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindGenTurbineType3bIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindGenTurbineType3bIEC*>(base_class_ptr))
	{
		buffer >> element->xs.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindMechIEC.cdrt
bool assign_WindMechIEC_cdrt(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindMechIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindMechIEC*>(base_class_ptr))
	{
		buffer >> element->cdrt.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindMechIEC.hgen
bool assign_WindMechIEC_hgen(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindMechIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindMechIEC*>(base_class_ptr))
	{
		buffer >> element->hgen.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindMechIEC.hwtr
bool assign_WindMechIEC_hwtr(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindMechIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindMechIEC*>(base_class_ptr))
	{
		buffer >> element->hwtr.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindMechIEC.kdrt
bool assign_WindMechIEC_kdrt(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindMechIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindMechIEC*>(base_class_ptr))
	{
		buffer >> element->kdrt.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindPitchContEmulIEC.kdroop
bool assign_WindPitchContEmulIEC_kdroop(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindPitchContEmulIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindPitchContEmulIEC*>(base_class_ptr))
	{
		buffer >> element->kdroop;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindPitchContEmulIEC.kipce
bool assign_WindPitchContEmulIEC_kipce(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindPitchContEmulIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindPitchContEmulIEC*>(base_class_ptr))
	{
		buffer >> element->kipce;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindPitchContEmulIEC.komegaaero
bool assign_WindPitchContEmulIEC_komegaaero(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindPitchContEmulIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindPitchContEmulIEC*>(base_class_ptr))
	{
		buffer >> element->komegaaero.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindPitchContEmulIEC.kppce
bool assign_WindPitchContEmulIEC_kppce(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindPitchContEmulIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindPitchContEmulIEC*>(base_class_ptr))
	{
		buffer >> element->kppce;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindPitchContEmulIEC.omegaref
bool assign_WindPitchContEmulIEC_omegaref(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindPitchContEmulIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindPitchContEmulIEC*>(base_class_ptr))
	{
		buffer >> element->omegaref.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindPitchContEmulIEC.pimax
bool assign_WindPitchContEmulIEC_pimax(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindPitchContEmulIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindPitchContEmulIEC*>(base_class_ptr))
	{
		buffer >> element->pimax.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindPitchContEmulIEC.pimin
bool assign_WindPitchContEmulIEC_pimin(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindPitchContEmulIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindPitchContEmulIEC*>(base_class_ptr))
	{
		buffer >> element->pimin.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindPitchContEmulIEC.t1
bool assign_WindPitchContEmulIEC_t1(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindPitchContEmulIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindPitchContEmulIEC*>(base_class_ptr))
	{
		buffer >> element->t1.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindPitchContEmulIEC.t2
bool assign_WindPitchContEmulIEC_t2(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindPitchContEmulIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindPitchContEmulIEC*>(base_class_ptr))
	{
		buffer >> element->t2.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindPitchContEmulIEC.tpe
bool assign_WindPitchContEmulIEC_tpe(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindPitchContEmulIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindPitchContEmulIEC*>(base_class_ptr))
	{
		buffer >> element->tpe.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindProtectionIEC.fover
bool assign_WindProtectionIEC_fover(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindProtectionIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindProtectionIEC*>(base_class_ptr))
	{
		buffer >> element->fover.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindProtectionIEC.funder
bool assign_WindProtectionIEC_funder(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindProtectionIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindProtectionIEC*>(base_class_ptr))
	{
		buffer >> element->funder.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindProtectionIEC.tfover
bool assign_WindProtectionIEC_tfover(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindProtectionIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindProtectionIEC*>(base_class_ptr))
	{
		buffer >> element->tfover.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindProtectionIEC.tfunder
bool assign_WindProtectionIEC_tfunder(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindProtectionIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindProtectionIEC*>(base_class_ptr))
	{
		buffer >> element->tfunder.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindProtectionIEC.tuover
bool assign_WindProtectionIEC_tuover(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindProtectionIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindProtectionIEC*>(base_class_ptr))
	{
		buffer >> element->tuover.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindProtectionIEC.tuunder
bool assign_WindProtectionIEC_tuunder(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindProtectionIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindProtectionIEC*>(base_class_ptr))
	{
		buffer >> element->tuunder.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindProtectionIEC.uover
bool assign_WindProtectionIEC_uover(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindProtectionIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindProtectionIEC*>(base_class_ptr))
	{
		buffer >> element->uover.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindProtectionIEC.uunder
bool assign_WindProtectionIEC_uunder(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::StandardModels::WindDynamics::WindProtectionIEC* element = dynamic_cast<IEC61970::Dynamics::StandardModels::WindDynamics::WindProtectionIEC*>(base_class_ptr))
	{
		buffer >> element->uunder.value;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:AsynchronousMachineUserDefined.proprietary
bool assign_AsynchronousMachineUserDefined_proprietary(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::UserDefinedModels::AsynchronousMachineUserDefined* element = dynamic_cast<IEC61970::Dynamics::UserDefinedModels::AsynchronousMachineUserDefined*>(base_class_ptr))
	{
		buffer >> element->proprietary;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:DiscontinuousExcitationControlUserDefined.proprietary
bool assign_DiscontinuousExcitationControlUserDefined_proprietary(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::UserDefinedModels::DiscontinuousExcitationControlUserDefined* element = dynamic_cast<IEC61970::Dynamics::UserDefinedModels::DiscontinuousExcitationControlUserDefined*>(base_class_ptr))
	{
		buffer >> element->proprietary;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ExcitationSystemUserDefined.proprietary
bool assign_ExcitationSystemUserDefined_proprietary(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::UserDefinedModels::ExcitationSystemUserDefined* element = dynamic_cast<IEC61970::Dynamics::UserDefinedModels::ExcitationSystemUserDefined*>(base_class_ptr))
	{
		buffer >> element->proprietary;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:LoadUserDefined.proprietary
bool assign_LoadUserDefined_proprietary(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::UserDefinedModels::LoadUserDefined* element = dynamic_cast<IEC61970::Dynamics::UserDefinedModels::LoadUserDefined*>(base_class_ptr))
	{
		buffer >> element->proprietary;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:MechanicalLoadUserDefined.proprietary
bool assign_MechanicalLoadUserDefined_proprietary(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::UserDefinedModels::MechanicalLoadUserDefined* element = dynamic_cast<IEC61970::Dynamics::UserDefinedModels::MechanicalLoadUserDefined*>(base_class_ptr))
	{
		buffer >> element->proprietary;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:OverexcitationLimiterUserDefined.proprietary
bool assign_OverexcitationLimiterUserDefined_proprietary(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::UserDefinedModels::OverexcitationLimiterUserDefined* element = dynamic_cast<IEC61970::Dynamics::UserDefinedModels::OverexcitationLimiterUserDefined*>(base_class_ptr))
	{
		buffer >> element->proprietary;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PFVArControllerType1UserDefined.proprietary
bool assign_PFVArControllerType1UserDefined_proprietary(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::UserDefinedModels::PFVArControllerType1UserDefined* element = dynamic_cast<IEC61970::Dynamics::UserDefinedModels::PFVArControllerType1UserDefined*>(base_class_ptr))
	{
		buffer >> element->proprietary;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PFVArControllerType2UserDefined.proprietary
bool assign_PFVArControllerType2UserDefined_proprietary(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::UserDefinedModels::PFVArControllerType2UserDefined* element = dynamic_cast<IEC61970::Dynamics::UserDefinedModels::PFVArControllerType2UserDefined*>(base_class_ptr))
	{
		buffer >> element->proprietary;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:PowerSystemStabilizerUserDefined.proprietary
bool assign_PowerSystemStabilizerUserDefined_proprietary(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::UserDefinedModels::PowerSystemStabilizerUserDefined* element = dynamic_cast<IEC61970::Dynamics::UserDefinedModels::PowerSystemStabilizerUserDefined*>(base_class_ptr))
	{
		buffer >> element->proprietary;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TurbineGovernorUserDefined.proprietary
bool assign_TurbineGovernorUserDefined_proprietary(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::UserDefinedModels::TurbineGovernorUserDefined* element = dynamic_cast<IEC61970::Dynamics::UserDefinedModels::TurbineGovernorUserDefined*>(base_class_ptr))
	{
		buffer >> element->proprietary;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:VoltageAdjusterUserDefined.proprietary
bool assign_VoltageAdjusterUserDefined_proprietary(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::UserDefinedModels::VoltageAdjusterUserDefined* element = dynamic_cast<IEC61970::Dynamics::UserDefinedModels::VoltageAdjusterUserDefined*>(base_class_ptr))
	{
		buffer >> element->proprietary;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:UnderexcitationLimiterUserDefined.proprietary
bool assign_UnderexcitationLimiterUserDefined_proprietary(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::UserDefinedModels::UnderexcitationLimiterUserDefined* element = dynamic_cast<IEC61970::Dynamics::UserDefinedModels::UnderexcitationLimiterUserDefined*>(base_class_ptr))
	{
		buffer >> element->proprietary;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:VoltageCompensatorUserDefined.proprietary
bool assign_VoltageCompensatorUserDefined_proprietary(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::UserDefinedModels::VoltageCompensatorUserDefined* element = dynamic_cast<IEC61970::Dynamics::UserDefinedModels::VoltageCompensatorUserDefined*>(base_class_ptr))
	{
		buffer >> element->proprietary;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:SynchronousMachineUserDefined.proprietary
bool assign_SynchronousMachineUserDefined_proprietary(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::UserDefinedModels::SynchronousMachineUserDefined* element = dynamic_cast<IEC61970::Dynamics::UserDefinedModels::SynchronousMachineUserDefined*>(base_class_ptr))
	{
		buffer >> element->proprietary;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:TurbineLoadControllerUserDefined.proprietary
bool assign_TurbineLoadControllerUserDefined_proprietary(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::UserDefinedModels::TurbineLoadControllerUserDefined* element = dynamic_cast<IEC61970::Dynamics::UserDefinedModels::TurbineLoadControllerUserDefined*>(base_class_ptr))
	{
		buffer >> element->proprietary;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ProprietaryParameterDynamics.booleanParameterValue
bool assign_ProprietaryParameterDynamics_booleanParameterValue(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::UserDefinedModels::ProprietaryParameterDynamics* element = dynamic_cast<IEC61970::Dynamics::UserDefinedModels::ProprietaryParameterDynamics*>(base_class_ptr))
	{
		buffer >> element->booleanParameterValue;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ProprietaryParameterDynamics.floatParameterValue
bool assign_ProprietaryParameterDynamics_floatParameterValue(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::UserDefinedModels::ProprietaryParameterDynamics* element = dynamic_cast<IEC61970::Dynamics::UserDefinedModels::ProprietaryParameterDynamics*>(base_class_ptr))
	{
		buffer >> element->floatParameterValue;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ProprietaryParameterDynamics.integerParameterValue
bool assign_ProprietaryParameterDynamics_integerParameterValue(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::UserDefinedModels::ProprietaryParameterDynamics* element = dynamic_cast<IEC61970::Dynamics::UserDefinedModels::ProprietaryParameterDynamics*>(base_class_ptr))
	{
		buffer >> element->integerParameterValue;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:ProprietaryParameterDynamics.parameterNumber
bool assign_ProprietaryParameterDynamics_parameterNumber(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::UserDefinedModels::ProprietaryParameterDynamics* element = dynamic_cast<IEC61970::Dynamics::UserDefinedModels::ProprietaryParameterDynamics*>(base_class_ptr))
	{
		buffer >> element->parameterNumber;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindPlantUserDefined.proprietary
bool assign_WindPlantUserDefined_proprietary(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::UserDefinedModels::WindPlantUserDefined* element = dynamic_cast<IEC61970::Dynamics::UserDefinedModels::WindPlantUserDefined*>(base_class_ptr))
	{
		buffer >> element->proprietary;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindType1or2UserDefined.proprietary
bool assign_WindType1or2UserDefined_proprietary(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::UserDefinedModels::WindType1or2UserDefined* element = dynamic_cast<IEC61970::Dynamics::UserDefinedModels::WindType1or2UserDefined*>(base_class_ptr))
	{
		buffer >> element->proprietary;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}

// cim:WindType3or4UserDefined.proprietary
bool assign_WindType3or4UserDefined_proprietary(std::stringstream& buffer, BaseClass* base_class_ptr)
{
	if(IEC61970::Dynamics::UserDefinedModels::WindType3or4UserDefined* element = dynamic_cast<IEC61970::Dynamics::UserDefinedModels::WindType3or4UserDefined*>(base_class_ptr))
	{
		buffer >> element->proprietary;
		if(buffer.fail())
			return false;
		else
			return true;
	}
	else
		return false;
}


// Dynamic Switch Factory
std::unordered_map<std::string, assign_function> dynamic_switch_factory()
{
	std::unordered_map<std::string, assign_function> dynamic_switch;

	dynamic_switch.insert(std::make_pair("cim:IdentifiedObject.aliasName", &assign_IdentifiedObject_aliasName));
	dynamic_switch.insert(std::make_pair("cim:IdentifiedObject.description", &assign_IdentifiedObject_description));
	dynamic_switch.insert(std::make_pair("cim:IdentifiedObject.mRID", &assign_IdentifiedObject_mRID));
	dynamic_switch.insert(std::make_pair("cim:IdentifiedObject.name", &assign_IdentifiedObject_name));
	dynamic_switch.insert(std::make_pair("cim:Control.controlType", &assign_Control_controlType));
	dynamic_switch.insert(std::make_pair("cim:Control.operationInProgress", &assign_Control_operationInProgress));
	dynamic_switch.insert(std::make_pair("cim:Control.timeStamp", &assign_Control_timeStamp));
	dynamic_switch.insert(std::make_pair("cim:Control.unitMultiplier", &assign_Control_unitMultiplier));
	dynamic_switch.insert(std::make_pair("cim:Control.unitSymbol", &assign_Control_unitSymbol));
	dynamic_switch.insert(std::make_pair("cim:ACDCTerminal.connected", &assign_ACDCTerminal_connected));
	dynamic_switch.insert(std::make_pair("cim:ACDCTerminal.sequenceNumber", &assign_ACDCTerminal_sequenceNumber));
	dynamic_switch.insert(std::make_pair("cim:Measurement.measurementType", &assign_Measurement_measurementType));
	dynamic_switch.insert(std::make_pair("cim:Measurement.phases", &assign_Measurement_phases));
	dynamic_switch.insert(std::make_pair("cim:Measurement.unitMultiplier", &assign_Measurement_unitMultiplier));
	dynamic_switch.insert(std::make_pair("cim:Measurement.unitSymbol", &assign_Measurement_unitSymbol));
	dynamic_switch.insert(std::make_pair("cim:Equipment.aggregate", &assign_Equipment_aggregate));
	dynamic_switch.insert(std::make_pair("cim:Equipment.inService", &assign_Equipment_inService));
	dynamic_switch.insert(std::make_pair("cim:Equipment.normallyInService", &assign_Equipment_normallyInService));
	dynamic_switch.insert(std::make_pair("cim:RegulatingControl.discrete", &assign_RegulatingControl_discrete));
	dynamic_switch.insert(std::make_pair("cim:RegulatingControl.enabled", &assign_RegulatingControl_enabled));
	dynamic_switch.insert(std::make_pair("cim:RegulatingControl.mode", &assign_RegulatingControl_mode));
	dynamic_switch.insert(std::make_pair("cim:RegulatingControl.monitoredPhase", &assign_RegulatingControl_monitoredPhase));
	dynamic_switch.insert(std::make_pair("cim:RegulatingControl.targetDeadband", &assign_RegulatingControl_targetDeadband));
	dynamic_switch.insert(std::make_pair("cim:RegulatingControl.targetValue", &assign_RegulatingControl_targetValue));
	dynamic_switch.insert(std::make_pair("cim:RegulatingControl.targetValueUnitMultiplier", &assign_RegulatingControl_targetValueUnitMultiplier));
	dynamic_switch.insert(std::make_pair("cim:Terminal.phases", &assign_Terminal_phases));
	dynamic_switch.insert(std::make_pair("cim:ActivePower.multiplier", &assign_ActivePower_multiplier));
	dynamic_switch.insert(std::make_pair("cim:CurrentTransformer.accuracyClass", &assign_CurrentTransformer_accuracyClass));
	dynamic_switch.insert(std::make_pair("cim:CurrentTransformer.accuracyLimit", &assign_CurrentTransformer_accuracyLimit));
	dynamic_switch.insert(std::make_pair("cim:CurrentTransformer.coreBurden", &assign_CurrentTransformer_coreBurden));
	dynamic_switch.insert(std::make_pair("cim:CurrentTransformer.ctClass", &assign_CurrentTransformer_ctClass));
	dynamic_switch.insert(std::make_pair("cim:CurrentTransformer.usage", &assign_CurrentTransformer_usage));
	dynamic_switch.insert(std::make_pair("cim:PotentialTransformer.accuracyClass", &assign_PotentialTransformer_accuracyClass));
	dynamic_switch.insert(std::make_pair("cim:PotentialTransformer.nominalRatio", &assign_PotentialTransformer_nominalRatio));
	dynamic_switch.insert(std::make_pair("cim:PotentialTransformer.ptClass", &assign_PotentialTransformer_ptClass));
	dynamic_switch.insert(std::make_pair("cim:PotentialTransformer.type", &assign_PotentialTransformer_type));
	dynamic_switch.insert(std::make_pair("cim:Contingency.mustStudy", &assign_Contingency_mustStudy));
	dynamic_switch.insert(std::make_pair("cim:ContingencyEquipment.contingentStatus", &assign_ContingencyEquipment_contingentStatus));
	dynamic_switch.insert(std::make_pair("cim:RemoteSource.deadband", &assign_RemoteSource_deadband));
	dynamic_switch.insert(std::make_pair("cim:RemoteSource.scanInterval", &assign_RemoteSource_scanInterval));
	dynamic_switch.insert(std::make_pair("cim:RemoteSource.sensorMaximum", &assign_RemoteSource_sensorMaximum));
	dynamic_switch.insert(std::make_pair("cim:RemoteSource.sensorMinimum", &assign_RemoteSource_sensorMinimum));
	dynamic_switch.insert(std::make_pair("cim:Quality61850.badReference", &assign_Quality61850_badReference));
	dynamic_switch.insert(std::make_pair("cim:Quality61850.estimatorReplaced", &assign_Quality61850_estimatorReplaced));
	dynamic_switch.insert(std::make_pair("cim:Quality61850.failure", &assign_Quality61850_failure));
	dynamic_switch.insert(std::make_pair("cim:Quality61850.oldData", &assign_Quality61850_oldData));
	dynamic_switch.insert(std::make_pair("cim:Quality61850.operatorBlocked", &assign_Quality61850_operatorBlocked));
	dynamic_switch.insert(std::make_pair("cim:Quality61850.oscillatory", &assign_Quality61850_oscillatory));
	dynamic_switch.insert(std::make_pair("cim:Quality61850.outOfRange", &assign_Quality61850_outOfRange));
	dynamic_switch.insert(std::make_pair("cim:Quality61850.overFlow", &assign_Quality61850_overFlow));
	dynamic_switch.insert(std::make_pair("cim:Quality61850.source", &assign_Quality61850_source));
	dynamic_switch.insert(std::make_pair("cim:Quality61850.suspect", &assign_Quality61850_suspect));
	dynamic_switch.insert(std::make_pair("cim:Quality61850.test", &assign_Quality61850_test));
	dynamic_switch.insert(std::make_pair("cim:Quality61850.validity", &assign_Quality61850_validity));
	dynamic_switch.insert(std::make_pair("cim:MeasurementValue.sensorAccuracy", &assign_MeasurementValue_sensorAccuracy));
	dynamic_switch.insert(std::make_pair("cim:MeasurementValue.timeStamp", &assign_MeasurementValue_timeStamp));
	dynamic_switch.insert(std::make_pair("cim:AnalogControl.maxValue", &assign_AnalogControl_maxValue));
	dynamic_switch.insert(std::make_pair("cim:AnalogControl.minValue", &assign_AnalogControl_minValue));
	dynamic_switch.insert(std::make_pair("cim:AnalogValue.value", &assign_AnalogValue_value));
	dynamic_switch.insert(std::make_pair("cim:AltGeneratingUnitMeas.priority", &assign_AltGeneratingUnitMeas_priority));
	dynamic_switch.insert(std::make_pair("cim:AltTieMeas.priority", &assign_AltTieMeas_priority));
	dynamic_switch.insert(std::make_pair("cim:ActivePowerChangeRate.multiplier", &assign_ActivePowerChangeRate_multiplier));
	dynamic_switch.insert(std::make_pair("cim:Money.multiplier", &assign_Money_multiplier));
	dynamic_switch.insert(std::make_pair("cim:Money.unit", &assign_Money_unit));
	dynamic_switch.insert(std::make_pair("cim:RegularTimePoint.sequenceNumber", &assign_RegularTimePoint_sequenceNumber));
	dynamic_switch.insert(std::make_pair("cim:RegularTimePoint.value1", &assign_RegularTimePoint_value1));
	dynamic_switch.insert(std::make_pair("cim:RegularTimePoint.value2", &assign_RegularTimePoint_value2));
	dynamic_switch.insert(std::make_pair("cim:BasicIntervalSchedule.startTime", &assign_BasicIntervalSchedule_startTime));
	dynamic_switch.insert(std::make_pair("cim:BasicIntervalSchedule.value1Multiplier", &assign_BasicIntervalSchedule_value1Multiplier));
	dynamic_switch.insert(std::make_pair("cim:BasicIntervalSchedule.value1Unit", &assign_BasicIntervalSchedule_value1Unit));
	dynamic_switch.insert(std::make_pair("cim:BasicIntervalSchedule.value2Multiplier", &assign_BasicIntervalSchedule_value2Multiplier));
	dynamic_switch.insert(std::make_pair("cim:BasicIntervalSchedule.value2Unit", &assign_BasicIntervalSchedule_value2Unit));
	dynamic_switch.insert(std::make_pair("cim:RegularIntervalSchedule.endTime", &assign_RegularIntervalSchedule_endTime));
	dynamic_switch.insert(std::make_pair("cim:RegularIntervalSchedule.timeStep", &assign_RegularIntervalSchedule_timeStep));
	dynamic_switch.insert(std::make_pair("cim:CurveData.xvalue", &assign_CurveData_xvalue));
	dynamic_switch.insert(std::make_pair("cim:CurveData.y1value", &assign_CurveData_y1value));
	dynamic_switch.insert(std::make_pair("cim:CurveData.y2value", &assign_CurveData_y2value));
	dynamic_switch.insert(std::make_pair("cim:CurveData.y3value", &assign_CurveData_y3value));
	dynamic_switch.insert(std::make_pair("cim:Curve.curveStyle", &assign_Curve_curveStyle));
	dynamic_switch.insert(std::make_pair("cim:Curve.xMultiplier", &assign_Curve_xMultiplier));
	dynamic_switch.insert(std::make_pair("cim:Curve.xUnit", &assign_Curve_xUnit));
	dynamic_switch.insert(std::make_pair("cim:Curve.y1Multiplier", &assign_Curve_y1Multiplier));
	dynamic_switch.insert(std::make_pair("cim:Curve.y1Unit", &assign_Curve_y1Unit));
	dynamic_switch.insert(std::make_pair("cim:Curve.y2Multiplier", &assign_Curve_y2Multiplier));
	dynamic_switch.insert(std::make_pair("cim:Curve.y2Unit", &assign_Curve_y2Unit));
	dynamic_switch.insert(std::make_pair("cim:Curve.y3Multiplier", &assign_Curve_y3Multiplier));
	dynamic_switch.insert(std::make_pair("cim:Curve.y3Unit", &assign_Curve_y3Unit));
	dynamic_switch.insert(std::make_pair("cim:GenUnitOpCostCurve.isNetGrossP", &assign_GenUnitOpCostCurve_isNetGrossP));
	dynamic_switch.insert(std::make_pair("cim:ReactivePower.multiplier", &assign_ReactivePower_multiplier));
	dynamic_switch.insert(std::make_pair("cim:ApparentPower.multiplier", &assign_ApparentPower_multiplier));
	dynamic_switch.insert(std::make_pair("cim:Voltage.multiplier", &assign_Voltage_multiplier));
	dynamic_switch.insert(std::make_pair("cim:HydroPump.pumpDischAtMaxHead", &assign_HydroPump_pumpDischAtMaxHead));
	dynamic_switch.insert(std::make_pair("cim:HydroPump.pumpDischAtMinHead", &assign_HydroPump_pumpDischAtMinHead));
	dynamic_switch.insert(std::make_pair("cim:HydroPump.pumpPowerAtMaxHead", &assign_HydroPump_pumpPowerAtMaxHead));
	dynamic_switch.insert(std::make_pair("cim:HydroPump.pumpPowerAtMinHead", &assign_HydroPump_pumpPowerAtMinHead));
	dynamic_switch.insert(std::make_pair("cim:RegulatingCondEq.controlEnabled", &assign_RegulatingCondEq_controlEnabled));
	dynamic_switch.insert(std::make_pair("cim:RotatingMachine.p", &assign_RotatingMachine_p));
	dynamic_switch.insert(std::make_pair("cim:RotatingMachine.q", &assign_RotatingMachine_q));
	dynamic_switch.insert(std::make_pair("cim:RotatingMachine.ratedPowerFactor", &assign_RotatingMachine_ratedPowerFactor));
	dynamic_switch.insert(std::make_pair("cim:RotatingMachine.ratedS", &assign_RotatingMachine_ratedS));
	dynamic_switch.insert(std::make_pair("cim:RotatingMachine.ratedU", &assign_RotatingMachine_ratedU));
	dynamic_switch.insert(std::make_pair("cim:GeneratingUnit.allocSpinResP", &assign_GeneratingUnit_allocSpinResP));
	dynamic_switch.insert(std::make_pair("cim:GeneratingUnit.autoCntrlMarginP", &assign_GeneratingUnit_autoCntrlMarginP));
	dynamic_switch.insert(std::make_pair("cim:GeneratingUnit.baseP", &assign_GeneratingUnit_baseP));
	dynamic_switch.insert(std::make_pair("cim:GeneratingUnit.controlDeadband", &assign_GeneratingUnit_controlDeadband));
	dynamic_switch.insert(std::make_pair("cim:GeneratingUnit.controlPulseHigh", &assign_GeneratingUnit_controlPulseHigh));
	dynamic_switch.insert(std::make_pair("cim:GeneratingUnit.controlPulseLow", &assign_GeneratingUnit_controlPulseLow));
	dynamic_switch.insert(std::make_pair("cim:GeneratingUnit.controlResponseRate", &assign_GeneratingUnit_controlResponseRate));
	dynamic_switch.insert(std::make_pair("cim:GeneratingUnit.efficiency", &assign_GeneratingUnit_efficiency));
	dynamic_switch.insert(std::make_pair("cim:GeneratingUnit.genControlMode", &assign_GeneratingUnit_genControlMode));
	dynamic_switch.insert(std::make_pair("cim:GeneratingUnit.genControlSource", &assign_GeneratingUnit_genControlSource));
	dynamic_switch.insert(std::make_pair("cim:GeneratingUnit.governorMPL", &assign_GeneratingUnit_governorMPL));
	dynamic_switch.insert(std::make_pair("cim:GeneratingUnit.governorSCD", &assign_GeneratingUnit_governorSCD));
	dynamic_switch.insert(std::make_pair("cim:GeneratingUnit.highControlLimit", &assign_GeneratingUnit_highControlLimit));
	dynamic_switch.insert(std::make_pair("cim:GeneratingUnit.initialP", &assign_GeneratingUnit_initialP));
	dynamic_switch.insert(std::make_pair("cim:GeneratingUnit.longPF", &assign_GeneratingUnit_longPF));
	dynamic_switch.insert(std::make_pair("cim:GeneratingUnit.lowControlLimit", &assign_GeneratingUnit_lowControlLimit));
	dynamic_switch.insert(std::make_pair("cim:GeneratingUnit.lowerRampRate", &assign_GeneratingUnit_lowerRampRate));
	dynamic_switch.insert(std::make_pair("cim:GeneratingUnit.maxEconomicP", &assign_GeneratingUnit_maxEconomicP));
	dynamic_switch.insert(std::make_pair("cim:GeneratingUnit.maximumAllowableSpinningReserve", &assign_GeneratingUnit_maximumAllowableSpinningReserve));
	dynamic_switch.insert(std::make_pair("cim:GeneratingUnit.maxOperatingP", &assign_GeneratingUnit_maxOperatingP));
	dynamic_switch.insert(std::make_pair("cim:GeneratingUnit.minEconomicP", &assign_GeneratingUnit_minEconomicP));
	dynamic_switch.insert(std::make_pair("cim:GeneratingUnit.minimumOffTime", &assign_GeneratingUnit_minimumOffTime));
	dynamic_switch.insert(std::make_pair("cim:GeneratingUnit.minOperatingP", &assign_GeneratingUnit_minOperatingP));
	dynamic_switch.insert(std::make_pair("cim:GeneratingUnit.modelDetail", &assign_GeneratingUnit_modelDetail));
	dynamic_switch.insert(std::make_pair("cim:GeneratingUnit.nominalP", &assign_GeneratingUnit_nominalP));
	dynamic_switch.insert(std::make_pair("cim:GeneratingUnit.normalPF", &assign_GeneratingUnit_normalPF));
	dynamic_switch.insert(std::make_pair("cim:GeneratingUnit.penaltyFactor", &assign_GeneratingUnit_penaltyFactor));
	dynamic_switch.insert(std::make_pair("cim:GeneratingUnit.raiseRampRate", &assign_GeneratingUnit_raiseRampRate));
	dynamic_switch.insert(std::make_pair("cim:GeneratingUnit.ratedGrossMaxP", &assign_GeneratingUnit_ratedGrossMaxP));
	dynamic_switch.insert(std::make_pair("cim:GeneratingUnit.ratedGrossMinP", &assign_GeneratingUnit_ratedGrossMinP));
	dynamic_switch.insert(std::make_pair("cim:GeneratingUnit.ratedNetMaxP", &assign_GeneratingUnit_ratedNetMaxP));
	dynamic_switch.insert(std::make_pair("cim:GeneratingUnit.shortPF", &assign_GeneratingUnit_shortPF));
	dynamic_switch.insert(std::make_pair("cim:GeneratingUnit.startupCost", &assign_GeneratingUnit_startupCost));
	dynamic_switch.insert(std::make_pair("cim:GeneratingUnit.startupTime", &assign_GeneratingUnit_startupTime));
	dynamic_switch.insert(std::make_pair("cim:GeneratingUnit.tieLinePF", &assign_GeneratingUnit_tieLinePF));
	dynamic_switch.insert(std::make_pair("cim:GeneratingUnit.totalEfficiency", &assign_GeneratingUnit_totalEfficiency));
	dynamic_switch.insert(std::make_pair("cim:GeneratingUnit.variableCost", &assign_GeneratingUnit_variableCost));
	dynamic_switch.insert(std::make_pair("cim:TieFlow.positiveFlowIn", &assign_TieFlow_positiveFlowIn));
	dynamic_switch.insert(std::make_pair("cim:ControlArea.netInterchange", &assign_ControlArea_netInterchange));
	dynamic_switch.insert(std::make_pair("cim:ControlArea.pTolerance", &assign_ControlArea_pTolerance));
	dynamic_switch.insert(std::make_pair("cim:ControlArea.type", &assign_ControlArea_type));
	dynamic_switch.insert(std::make_pair("cim:Frequency.multiplier", &assign_Frequency_multiplier));
	dynamic_switch.insert(std::make_pair("cim:BaseFrequency.frequency", &assign_BaseFrequency_frequency));
	dynamic_switch.insert(std::make_pair("cim:BasePower.basePower", &assign_BasePower_basePower));
	dynamic_switch.insert(std::make_pair("cim:BaseVoltage.nominalVoltage", &assign_BaseVoltage_nominalVoltage));
	dynamic_switch.insert(std::make_pair("cim:Bay.bayEnergyMeasFlag", &assign_Bay_bayEnergyMeasFlag));
	dynamic_switch.insert(std::make_pair("cim:Bay.bayPowerMeasFlag", &assign_Bay_bayPowerMeasFlag));
	dynamic_switch.insert(std::make_pair("cim:Bay.breakerConfiguration", &assign_Bay_breakerConfiguration));
	dynamic_switch.insert(std::make_pair("cim:Bay.busBarConfiguration", &assign_Bay_busBarConfiguration));
	dynamic_switch.insert(std::make_pair("cim:VoltageLevel.highVoltageLimit", &assign_VoltageLevel_highVoltageLimit));
	dynamic_switch.insert(std::make_pair("cim:VoltageLevel.lowVoltageLimit", &assign_VoltageLevel_lowVoltageLimit));
	dynamic_switch.insert(std::make_pair("cim:DCConverterUnit.operationMode", &assign_DCConverterUnit_operationMode));
	dynamic_switch.insert(std::make_pair("cim:IrregularTimePoint.time", &assign_IrregularTimePoint_time));
	dynamic_switch.insert(std::make_pair("cim:IrregularTimePoint.value1", &assign_IrregularTimePoint_value1));
	dynamic_switch.insert(std::make_pair("cim:IrregularTimePoint.value2", &assign_IrregularTimePoint_value2));
	dynamic_switch.insert(std::make_pair("cim:NameTypeAuthority.description", &assign_NameTypeAuthority_description));
	dynamic_switch.insert(std::make_pair("cim:NameTypeAuthority.name", &assign_NameTypeAuthority_name));
	dynamic_switch.insert(std::make_pair("cim:NameType.description", &assign_NameType_description));
	dynamic_switch.insert(std::make_pair("cim:NameType.name", &assign_NameType_name));
	dynamic_switch.insert(std::make_pair("cim:Name.name", &assign_Name_name));
	dynamic_switch.insert(std::make_pair("cim:OperatingShare.percentage", &assign_OperatingShare_percentage));
	dynamic_switch.insert(std::make_pair("cim:CurrentFlow.multiplier", &assign_CurrentFlow_multiplier));
	dynamic_switch.insert(std::make_pair("cim:Resistance.multiplier", &assign_Resistance_multiplier));
	dynamic_switch.insert(std::make_pair("cim:ActivePowerPerCurrentFlow.multiplier", &assign_ActivePowerPerCurrentFlow_multiplier));
	dynamic_switch.insert(std::make_pair("cim:ACDCConverter.baseS", &assign_ACDCConverter_baseS));
	dynamic_switch.insert(std::make_pair("cim:ACDCConverter.idc", &assign_ACDCConverter_idc));
	dynamic_switch.insert(std::make_pair("cim:ACDCConverter.idleLoss", &assign_ACDCConverter_idleLoss));
	dynamic_switch.insert(std::make_pair("cim:ACDCConverter.maxUdc", &assign_ACDCConverter_maxUdc));
	dynamic_switch.insert(std::make_pair("cim:ACDCConverter.minUdc", &assign_ACDCConverter_minUdc));
	dynamic_switch.insert(std::make_pair("cim:ACDCConverter.numberOfValves", &assign_ACDCConverter_numberOfValves));
	dynamic_switch.insert(std::make_pair("cim:ACDCConverter.p", &assign_ACDCConverter_p));
	dynamic_switch.insert(std::make_pair("cim:ACDCConverter.poleLossP", &assign_ACDCConverter_poleLossP));
	dynamic_switch.insert(std::make_pair("cim:ACDCConverter.q", &assign_ACDCConverter_q));
	dynamic_switch.insert(std::make_pair("cim:ACDCConverter.ratedUdc", &assign_ACDCConverter_ratedUdc));
	dynamic_switch.insert(std::make_pair("cim:ACDCConverter.resistiveLoss", &assign_ACDCConverter_resistiveLoss));
	dynamic_switch.insert(std::make_pair("cim:ACDCConverter.switchingLoss", &assign_ACDCConverter_switchingLoss));
	dynamic_switch.insert(std::make_pair("cim:ACDCConverter.targetPpcc", &assign_ACDCConverter_targetPpcc));
	dynamic_switch.insert(std::make_pair("cim:ACDCConverter.targetUdc", &assign_ACDCConverter_targetUdc));
	dynamic_switch.insert(std::make_pair("cim:ACDCConverter.uc", &assign_ACDCConverter_uc));
	dynamic_switch.insert(std::make_pair("cim:ACDCConverter.udc", &assign_ACDCConverter_udc));
	dynamic_switch.insert(std::make_pair("cim:ACDCConverter.valveU0", &assign_ACDCConverter_valveU0));
	dynamic_switch.insert(std::make_pair("cim:ACDCConverterDCTerminal.polarity", &assign_ACDCConverterDCTerminal_polarity));
	dynamic_switch.insert(std::make_pair("cim:CsConverter.alpha", &assign_CsConverter_alpha));
	dynamic_switch.insert(std::make_pair("cim:CsConverter.gamma", &assign_CsConverter_gamma));
	dynamic_switch.insert(std::make_pair("cim:CsConverter.maxAlpha", &assign_CsConverter_maxAlpha));
	dynamic_switch.insert(std::make_pair("cim:CsConverter.maxGamma", &assign_CsConverter_maxGamma));
	dynamic_switch.insert(std::make_pair("cim:CsConverter.maxIdc", &assign_CsConverter_maxIdc));
	dynamic_switch.insert(std::make_pair("cim:CsConverter.minAlpha", &assign_CsConverter_minAlpha));
	dynamic_switch.insert(std::make_pair("cim:CsConverter.minGamma", &assign_CsConverter_minGamma));
	dynamic_switch.insert(std::make_pair("cim:CsConverter.minIdc", &assign_CsConverter_minIdc));
	dynamic_switch.insert(std::make_pair("cim:CsConverter.operatingMode", &assign_CsConverter_operatingMode));
	dynamic_switch.insert(std::make_pair("cim:CsConverter.pPccControl", &assign_CsConverter_pPccControl));
	dynamic_switch.insert(std::make_pair("cim:CsConverter.ratedIdc", &assign_CsConverter_ratedIdc));
	dynamic_switch.insert(std::make_pair("cim:CsConverter.targetAlpha", &assign_CsConverter_targetAlpha));
	dynamic_switch.insert(std::make_pair("cim:CsConverter.targetGamma", &assign_CsConverter_targetGamma));
	dynamic_switch.insert(std::make_pair("cim:CsConverter.targetIdc", &assign_CsConverter_targetIdc));
	dynamic_switch.insert(std::make_pair("cim:Inductance.multiplier", &assign_Inductance_multiplier));
	dynamic_switch.insert(std::make_pair("cim:DCGround.inductance", &assign_DCGround_inductance));
	dynamic_switch.insert(std::make_pair("cim:DCGround.r", &assign_DCGround_r));
	dynamic_switch.insert(std::make_pair("cim:Capacitance.multiplier", &assign_Capacitance_multiplier));
	dynamic_switch.insert(std::make_pair("cim:Length.multiplier", &assign_Length_multiplier));
	dynamic_switch.insert(std::make_pair("cim:DCLineSegment.capacitance", &assign_DCLineSegment_capacitance));
	dynamic_switch.insert(std::make_pair("cim:DCLineSegment.inductance", &assign_DCLineSegment_inductance));
	dynamic_switch.insert(std::make_pair("cim:DCLineSegment.length", &assign_DCLineSegment_length));
	dynamic_switch.insert(std::make_pair("cim:DCLineSegment.resistance", &assign_DCLineSegment_resistance));
	dynamic_switch.insert(std::make_pair("cim:DCSeriesDevice.inductance", &assign_DCSeriesDevice_inductance));
	dynamic_switch.insert(std::make_pair("cim:DCSeriesDevice.ratedUdc", &assign_DCSeriesDevice_ratedUdc));
	dynamic_switch.insert(std::make_pair("cim:DCSeriesDevice.resistance", &assign_DCSeriesDevice_resistance));
	dynamic_switch.insert(std::make_pair("cim:DCShunt.capacitance", &assign_DCShunt_capacitance));
	dynamic_switch.insert(std::make_pair("cim:DCShunt.ratedUdc", &assign_DCShunt_ratedUdc));
	dynamic_switch.insert(std::make_pair("cim:DCShunt.resistance", &assign_DCShunt_resistance));
	dynamic_switch.insert(std::make_pair("cim:PerLengthDCLineParameter.capacitance", &assign_PerLengthDCLineParameter_capacitance));
	dynamic_switch.insert(std::make_pair("cim:PerLengthDCLineParameter.inductance", &assign_PerLengthDCLineParameter_inductance));
	dynamic_switch.insert(std::make_pair("cim:PerLengthDCLineParameter.resistance", &assign_PerLengthDCLineParameter_resistance));
	dynamic_switch.insert(std::make_pair("cim:VsConverter.delta", &assign_VsConverter_delta));
	dynamic_switch.insert(std::make_pair("cim:VsConverter.droop", &assign_VsConverter_droop));
	dynamic_switch.insert(std::make_pair("cim:VsConverter.droopCompensation", &assign_VsConverter_droopCompensation));
	dynamic_switch.insert(std::make_pair("cim:VsConverter.maxModulationIndex", &assign_VsConverter_maxModulationIndex));
	dynamic_switch.insert(std::make_pair("cim:VsConverter.maxValveCurrent", &assign_VsConverter_maxValveCurrent));
	dynamic_switch.insert(std::make_pair("cim:VsConverter.pPccControl", &assign_VsConverter_pPccControl));
	dynamic_switch.insert(std::make_pair("cim:VsConverter.qPccControl", &assign_VsConverter_qPccControl));
	dynamic_switch.insert(std::make_pair("cim:VsConverter.qShare", &assign_VsConverter_qShare));
	dynamic_switch.insert(std::make_pair("cim:VsConverter.targetQpcc", &assign_VsConverter_targetQpcc));
	dynamic_switch.insert(std::make_pair("cim:VsConverter.targetUpcc", &assign_VsConverter_targetUpcc));
	dynamic_switch.insert(std::make_pair("cim:VsConverter.uf", &assign_VsConverter_uf));
	dynamic_switch.insert(std::make_pair("cim:Diagram.orientation", &assign_Diagram_orientation));
	dynamic_switch.insert(std::make_pair("cim:Diagram.x1InitialView", &assign_Diagram_x1InitialView));
	dynamic_switch.insert(std::make_pair("cim:Diagram.x2InitialView", &assign_Diagram_x2InitialView));
	dynamic_switch.insert(std::make_pair("cim:Diagram.y1InitialView", &assign_Diagram_y1InitialView));
	dynamic_switch.insert(std::make_pair("cim:Diagram.y2InitialView", &assign_Diagram_y2InitialView));
	dynamic_switch.insert(std::make_pair("cim:VisibilityLayer.drawingOrder", &assign_VisibilityLayer_drawingOrder));
	dynamic_switch.insert(std::make_pair("cim:DiagramObjectPoint.sequenceNumber", &assign_DiagramObjectPoint_sequenceNumber));
	dynamic_switch.insert(std::make_pair("cim:DiagramObjectPoint.xPosition", &assign_DiagramObjectPoint_xPosition));
	dynamic_switch.insert(std::make_pair("cim:DiagramObjectPoint.yPosition", &assign_DiagramObjectPoint_yPosition));
	dynamic_switch.insert(std::make_pair("cim:DiagramObjectPoint.zPosition", &assign_DiagramObjectPoint_zPosition));
	dynamic_switch.insert(std::make_pair("cim:DiagramObject.drawingOrder", &assign_DiagramObject_drawingOrder));
	dynamic_switch.insert(std::make_pair("cim:DiagramObject.isPolygon", &assign_DiagramObject_isPolygon));
	dynamic_switch.insert(std::make_pair("cim:DiagramObject.offsetX", &assign_DiagramObject_offsetX));
	dynamic_switch.insert(std::make_pair("cim:DiagramObject.offsetY", &assign_DiagramObject_offsetY));
	dynamic_switch.insert(std::make_pair("cim:DiagramObject.rotation", &assign_DiagramObject_rotation));
	dynamic_switch.insert(std::make_pair("cim:TextDiagramObject.text", &assign_TextDiagramObject_text));
	dynamic_switch.insert(std::make_pair("cim:ActivePowerPerFrequency.multiplier", &assign_ActivePowerPerFrequency_multiplier));
	dynamic_switch.insert(std::make_pair("cim:Admittance.multiplier", &assign_Admittance_multiplier));
	dynamic_switch.insert(std::make_pair("cim:Area.multiplier", &assign_Area_multiplier));
	dynamic_switch.insert(std::make_pair("cim:Conductance.multiplier", &assign_Conductance_multiplier));
	dynamic_switch.insert(std::make_pair("cim:CostPerEnergyUnit.multiplier", &assign_CostPerEnergyUnit_multiplier));
	dynamic_switch.insert(std::make_pair("cim:CostPerEnergyUnit.unit", &assign_CostPerEnergyUnit_unit));
	dynamic_switch.insert(std::make_pair("cim:CostPerVolume.multiplier", &assign_CostPerVolume_multiplier));
	dynamic_switch.insert(std::make_pair("cim:CostPerVolume.unit", &assign_CostPerVolume_unit));
	dynamic_switch.insert(std::make_pair("cim:CostRate.multiplier", &assign_CostRate_multiplier));
	dynamic_switch.insert(std::make_pair("cim:CostRate.unit", &assign_CostRate_unit));
	dynamic_switch.insert(std::make_pair("cim:DateInterval.end", &assign_DateInterval_end));
	dynamic_switch.insert(std::make_pair("cim:DateInterval.start", &assign_DateInterval_start));
	dynamic_switch.insert(std::make_pair("cim:DateTimeInterval.end", &assign_DateTimeInterval_end));
	dynamic_switch.insert(std::make_pair("cim:DateTimeInterval.start", &assign_DateTimeInterval_start));
	dynamic_switch.insert(std::make_pair("cim:DecimalQuantity.currency", &assign_DecimalQuantity_currency));
	dynamic_switch.insert(std::make_pair("cim:DecimalQuantity.multiplier", &assign_DecimalQuantity_multiplier));
	dynamic_switch.insert(std::make_pair("cim:DecimalQuantity.unit", &assign_DecimalQuantity_unit));
	dynamic_switch.insert(std::make_pair("cim:FloatQuantity.multiplier", &assign_FloatQuantity_multiplier));
	dynamic_switch.insert(std::make_pair("cim:FloatQuantity.unit", &assign_FloatQuantity_unit));
	dynamic_switch.insert(std::make_pair("cim:Impedance.multiplier", &assign_Impedance_multiplier));
	dynamic_switch.insert(std::make_pair("cim:IntegerQuantity.multiplier", &assign_IntegerQuantity_multiplier));
	dynamic_switch.insert(std::make_pair("cim:IntegerQuantity.unit", &assign_IntegerQuantity_unit));
	dynamic_switch.insert(std::make_pair("cim:MonthDayInterval.end", &assign_MonthDayInterval_end));
	dynamic_switch.insert(std::make_pair("cim:MonthDayInterval.start", &assign_MonthDayInterval_start));
	dynamic_switch.insert(std::make_pair("cim:Pressure.multiplier", &assign_Pressure_multiplier));
	dynamic_switch.insert(std::make_pair("cim:Reactance.multiplier", &assign_Reactance_multiplier));
	dynamic_switch.insert(std::make_pair("cim:RealEnergy.multiplier", &assign_RealEnergy_multiplier));
	dynamic_switch.insert(std::make_pair("cim:StringQuantity.multiplier", &assign_StringQuantity_multiplier));
	dynamic_switch.insert(std::make_pair("cim:StringQuantity.unit", &assign_StringQuantity_unit));
	dynamic_switch.insert(std::make_pair("cim:Susceptance.multiplier", &assign_Susceptance_multiplier));
	dynamic_switch.insert(std::make_pair("cim:TimeInterval.end", &assign_TimeInterval_end));
	dynamic_switch.insert(std::make_pair("cim:TimeInterval.start", &assign_TimeInterval_start));
	dynamic_switch.insert(std::make_pair("cim:VoltagePerReactivePower.multiplier", &assign_VoltagePerReactivePower_multiplier));
	dynamic_switch.insert(std::make_pair("cim:Volume.multiplier", &assign_Volume_multiplier));
	dynamic_switch.insert(std::make_pair("cim:WaterLevel.multiplier", &assign_WaterLevel_multiplier));
	dynamic_switch.insert(std::make_pair("cim:Weight.multiplier", &assign_Weight_multiplier));
	dynamic_switch.insert(std::make_pair("cim:EquivalentBranch.negativeR12", &assign_EquivalentBranch_negativeR12));
	dynamic_switch.insert(std::make_pair("cim:EquivalentBranch.negativeR21", &assign_EquivalentBranch_negativeR21));
	dynamic_switch.insert(std::make_pair("cim:EquivalentBranch.negativeX12", &assign_EquivalentBranch_negativeX12));
	dynamic_switch.insert(std::make_pair("cim:EquivalentBranch.negativeX21", &assign_EquivalentBranch_negativeX21));
	dynamic_switch.insert(std::make_pair("cim:EquivalentBranch.positiveR12", &assign_EquivalentBranch_positiveR12));
	dynamic_switch.insert(std::make_pair("cim:EquivalentBranch.positiveR21", &assign_EquivalentBranch_positiveR21));
	dynamic_switch.insert(std::make_pair("cim:EquivalentBranch.positiveX12", &assign_EquivalentBranch_positiveX12));
	dynamic_switch.insert(std::make_pair("cim:EquivalentBranch.positiveX21", &assign_EquivalentBranch_positiveX21));
	dynamic_switch.insert(std::make_pair("cim:EquivalentBranch.r", &assign_EquivalentBranch_r));
	dynamic_switch.insert(std::make_pair("cim:EquivalentBranch.r21", &assign_EquivalentBranch_r21));
	dynamic_switch.insert(std::make_pair("cim:EquivalentBranch.x", &assign_EquivalentBranch_x));
	dynamic_switch.insert(std::make_pair("cim:EquivalentBranch.x21", &assign_EquivalentBranch_x21));
	dynamic_switch.insert(std::make_pair("cim:EquivalentBranch.zeroR12", &assign_EquivalentBranch_zeroR12));
	dynamic_switch.insert(std::make_pair("cim:EquivalentBranch.zeroR21", &assign_EquivalentBranch_zeroR21));
	dynamic_switch.insert(std::make_pair("cim:EquivalentBranch.zeroX12", &assign_EquivalentBranch_zeroX12));
	dynamic_switch.insert(std::make_pair("cim:EquivalentBranch.zeroX21", &assign_EquivalentBranch_zeroX21));
	dynamic_switch.insert(std::make_pair("cim:EquivalentInjection.maxP", &assign_EquivalentInjection_maxP));
	dynamic_switch.insert(std::make_pair("cim:EquivalentInjection.maxQ", &assign_EquivalentInjection_maxQ));
	dynamic_switch.insert(std::make_pair("cim:EquivalentInjection.minP", &assign_EquivalentInjection_minP));
	dynamic_switch.insert(std::make_pair("cim:EquivalentInjection.minQ", &assign_EquivalentInjection_minQ));
	dynamic_switch.insert(std::make_pair("cim:EquivalentInjection.p", &assign_EquivalentInjection_p));
	dynamic_switch.insert(std::make_pair("cim:EquivalentInjection.q", &assign_EquivalentInjection_q));
	dynamic_switch.insert(std::make_pair("cim:EquivalentInjection.r", &assign_EquivalentInjection_r));
	dynamic_switch.insert(std::make_pair("cim:EquivalentInjection.r0", &assign_EquivalentInjection_r0));
	dynamic_switch.insert(std::make_pair("cim:EquivalentInjection.r2", &assign_EquivalentInjection_r2));
	dynamic_switch.insert(std::make_pair("cim:EquivalentInjection.regulationCapability", &assign_EquivalentInjection_regulationCapability));
	dynamic_switch.insert(std::make_pair("cim:EquivalentInjection.regulationStatus", &assign_EquivalentInjection_regulationStatus));
	dynamic_switch.insert(std::make_pair("cim:EquivalentInjection.regulationTarget", &assign_EquivalentInjection_regulationTarget));
	dynamic_switch.insert(std::make_pair("cim:EquivalentInjection.x", &assign_EquivalentInjection_x));
	dynamic_switch.insert(std::make_pair("cim:EquivalentInjection.x0", &assign_EquivalentInjection_x0));
	dynamic_switch.insert(std::make_pair("cim:EquivalentInjection.x2", &assign_EquivalentInjection_x2));
	dynamic_switch.insert(std::make_pair("cim:EquivalentShunt.b", &assign_EquivalentShunt_b));
	dynamic_switch.insert(std::make_pair("cim:EquivalentShunt.g", &assign_EquivalentShunt_g));
	dynamic_switch.insert(std::make_pair("cim:FaultImpedance.rGround", &assign_FaultImpedance_rGround));
	dynamic_switch.insert(std::make_pair("cim:FaultImpedance.rLineToLine", &assign_FaultImpedance_rLineToLine));
	dynamic_switch.insert(std::make_pair("cim:FaultImpedance.xGround", &assign_FaultImpedance_xGround));
	dynamic_switch.insert(std::make_pair("cim:FaultImpedance.xLineToLine", &assign_FaultImpedance_xLineToLine));
	dynamic_switch.insert(std::make_pair("cim:Fault.kind", &assign_Fault_kind));
	dynamic_switch.insert(std::make_pair("cim:Fault.phases", &assign_Fault_phases));
	dynamic_switch.insert(std::make_pair("cim:Conductor.length", &assign_Conductor_length));
	dynamic_switch.insert(std::make_pair("cim:Clamp.lengthFromTerminal1", &assign_Clamp_lengthFromTerminal1));
	dynamic_switch.insert(std::make_pair("cim:ACLineSegment.b0ch", &assign_ACLineSegment_b0ch));
	dynamic_switch.insert(std::make_pair("cim:ACLineSegment.bch", &assign_ACLineSegment_bch));
	dynamic_switch.insert(std::make_pair("cim:ACLineSegment.g0ch", &assign_ACLineSegment_g0ch));
	dynamic_switch.insert(std::make_pair("cim:ACLineSegment.gch", &assign_ACLineSegment_gch));
	dynamic_switch.insert(std::make_pair("cim:ACLineSegment.r", &assign_ACLineSegment_r));
	dynamic_switch.insert(std::make_pair("cim:ACLineSegment.r0", &assign_ACLineSegment_r0));
	dynamic_switch.insert(std::make_pair("cim:ACLineSegment.shortCircuitEndTemperature", &assign_ACLineSegment_shortCircuitEndTemperature));
	dynamic_switch.insert(std::make_pair("cim:ACLineSegment.x", &assign_ACLineSegment_x));
	dynamic_switch.insert(std::make_pair("cim:ACLineSegment.x0", &assign_ACLineSegment_x0));
	dynamic_switch.insert(std::make_pair("cim:LineFault.lengthFromTerminal1", &assign_LineFault_lengthFromTerminal1));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachine.aVRToManualLag", &assign_SynchronousMachine_aVRToManualLag));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachine.aVRToManualLead", &assign_SynchronousMachine_aVRToManualLead));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachine.baseQ", &assign_SynchronousMachine_baseQ));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachine.condenserP", &assign_SynchronousMachine_condenserP));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachine.coolantCondition", &assign_SynchronousMachine_coolantCondition));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachine.coolantType", &assign_SynchronousMachine_coolantType));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachine.earthing", &assign_SynchronousMachine_earthing));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachine.earthingStarPointR", &assign_SynchronousMachine_earthingStarPointR));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachine.earthingStarPointX", &assign_SynchronousMachine_earthingStarPointX));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachine.ikk", &assign_SynchronousMachine_ikk));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachine.manualToAVR", &assign_SynchronousMachine_manualToAVR));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachine.maxQ", &assign_SynchronousMachine_maxQ));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachine.maxU", &assign_SynchronousMachine_maxU));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachine.minQ", &assign_SynchronousMachine_minQ));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachine.minU", &assign_SynchronousMachine_minU));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachine.mu", &assign_SynchronousMachine_mu));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachine.operatingMode", &assign_SynchronousMachine_operatingMode));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachine.qPercent", &assign_SynchronousMachine_qPercent));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachine.r", &assign_SynchronousMachine_r));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachine.r0", &assign_SynchronousMachine_r0));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachine.r2", &assign_SynchronousMachine_r2));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachine.referencePriority", &assign_SynchronousMachine_referencePriority));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachine.satDirectSubtransX", &assign_SynchronousMachine_satDirectSubtransX));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachine.satDirectSyncX", &assign_SynchronousMachine_satDirectSyncX));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachine.satDirectTransX", &assign_SynchronousMachine_satDirectTransX));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachine.shortCircuitRotorType", &assign_SynchronousMachine_shortCircuitRotorType));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachine.type", &assign_SynchronousMachine_type));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachine.voltageRegulationRange", &assign_SynchronousMachine_voltageRegulationRange));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachine.x0", &assign_SynchronousMachine_x0));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachine.x2", &assign_SynchronousMachine_x2));
	dynamic_switch.insert(std::make_pair("cim:PrimeMover.primeMoverRating", &assign_PrimeMover_primeMoverRating));
	dynamic_switch.insert(std::make_pair("cim:SteamTurbine.crossoverTC", &assign_SteamTurbine_crossoverTC));
	dynamic_switch.insert(std::make_pair("cim:SteamTurbine.reheater1TC", &assign_SteamTurbine_reheater1TC));
	dynamic_switch.insert(std::make_pair("cim:SteamTurbine.reheater2TC", &assign_SteamTurbine_reheater2TC));
	dynamic_switch.insert(std::make_pair("cim:SteamTurbine.shaft1PowerHP", &assign_SteamTurbine_shaft1PowerHP));
	dynamic_switch.insert(std::make_pair("cim:SteamTurbine.shaft1PowerIP", &assign_SteamTurbine_shaft1PowerIP));
	dynamic_switch.insert(std::make_pair("cim:SteamTurbine.shaft1PowerLP1", &assign_SteamTurbine_shaft1PowerLP1));
	dynamic_switch.insert(std::make_pair("cim:SteamTurbine.shaft1PowerLP2", &assign_SteamTurbine_shaft1PowerLP2));
	dynamic_switch.insert(std::make_pair("cim:SteamTurbine.shaft2PowerHP", &assign_SteamTurbine_shaft2PowerHP));
	dynamic_switch.insert(std::make_pair("cim:SteamTurbine.shaft2PowerIP", &assign_SteamTurbine_shaft2PowerIP));
	dynamic_switch.insert(std::make_pair("cim:SteamTurbine.shaft2PowerLP1", &assign_SteamTurbine_shaft2PowerLP1));
	dynamic_switch.insert(std::make_pair("cim:SteamTurbine.shaft2PowerLP2", &assign_SteamTurbine_shaft2PowerLP2));
	dynamic_switch.insert(std::make_pair("cim:SteamTurbine.steamChestTC", &assign_SteamTurbine_steamChestTC));
	dynamic_switch.insert(std::make_pair("cim:SteamSupply.steamSupplyRating", &assign_SteamSupply_steamSupplyRating));
	dynamic_switch.insert(std::make_pair("cim:BWRSteamSupply.highPowerLimit", &assign_BWRSteamSupply_highPowerLimit));
	dynamic_switch.insert(std::make_pair("cim:BWRSteamSupply.inCoreThermalTC", &assign_BWRSteamSupply_inCoreThermalTC));
	dynamic_switch.insert(std::make_pair("cim:BWRSteamSupply.integralGain", &assign_BWRSteamSupply_integralGain));
	dynamic_switch.insert(std::make_pair("cim:BWRSteamSupply.lowerLimit", &assign_BWRSteamSupply_lowerLimit));
	dynamic_switch.insert(std::make_pair("cim:BWRSteamSupply.lowPowerLimit", &assign_BWRSteamSupply_lowPowerLimit));
	dynamic_switch.insert(std::make_pair("cim:BWRSteamSupply.pressureLimit", &assign_BWRSteamSupply_pressureLimit));
	dynamic_switch.insert(std::make_pair("cim:BWRSteamSupply.pressureSetpointGA", &assign_BWRSteamSupply_pressureSetpointGA));
	dynamic_switch.insert(std::make_pair("cim:BWRSteamSupply.pressureSetpointTC1", &assign_BWRSteamSupply_pressureSetpointTC1));
	dynamic_switch.insert(std::make_pair("cim:BWRSteamSupply.pressureSetpointTC2", &assign_BWRSteamSupply_pressureSetpointTC2));
	dynamic_switch.insert(std::make_pair("cim:BWRSteamSupply.proportionalGain", &assign_BWRSteamSupply_proportionalGain));
	dynamic_switch.insert(std::make_pair("cim:BWRSteamSupply.rfAux1", &assign_BWRSteamSupply_rfAux1));
	dynamic_switch.insert(std::make_pair("cim:BWRSteamSupply.rfAux2", &assign_BWRSteamSupply_rfAux2));
	dynamic_switch.insert(std::make_pair("cim:BWRSteamSupply.rfAux3", &assign_BWRSteamSupply_rfAux3));
	dynamic_switch.insert(std::make_pair("cim:BWRSteamSupply.rfAux4", &assign_BWRSteamSupply_rfAux4));
	dynamic_switch.insert(std::make_pair("cim:BWRSteamSupply.rfAux5", &assign_BWRSteamSupply_rfAux5));
	dynamic_switch.insert(std::make_pair("cim:BWRSteamSupply.rfAux6", &assign_BWRSteamSupply_rfAux6));
	dynamic_switch.insert(std::make_pair("cim:BWRSteamSupply.rfAux7", &assign_BWRSteamSupply_rfAux7));
	dynamic_switch.insert(std::make_pair("cim:BWRSteamSupply.rfAux8", &assign_BWRSteamSupply_rfAux8));
	dynamic_switch.insert(std::make_pair("cim:BWRSteamSupply.rodPattern", &assign_BWRSteamSupply_rodPattern));
	dynamic_switch.insert(std::make_pair("cim:BWRSteamSupply.rodPatternConstant", &assign_BWRSteamSupply_rodPatternConstant));
	dynamic_switch.insert(std::make_pair("cim:BWRSteamSupply.upperLimit", &assign_BWRSteamSupply_upperLimit));
	dynamic_switch.insert(std::make_pair("cim:AirCompressor.airCompressorRating", &assign_AirCompressor_airCompressorRating));
	dynamic_switch.insert(std::make_pair("cim:CombustionTurbine.ambientTemp", &assign_CombustionTurbine_ambientTemp));
	dynamic_switch.insert(std::make_pair("cim:CombustionTurbine.auxPowerVersusFrequency", &assign_CombustionTurbine_auxPowerVersusFrequency));
	dynamic_switch.insert(std::make_pair("cim:CombustionTurbine.auxPowerVersusVoltage", &assign_CombustionTurbine_auxPowerVersusVoltage));
	dynamic_switch.insert(std::make_pair("cim:CombustionTurbine.capabilityVersusFrequency", &assign_CombustionTurbine_capabilityVersusFrequency));
	dynamic_switch.insert(std::make_pair("cim:CombustionTurbine.heatRecoveryFlag", &assign_CombustionTurbine_heatRecoveryFlag));
	dynamic_switch.insert(std::make_pair("cim:CombustionTurbine.powerVariationByTemp", &assign_CombustionTurbine_powerVariationByTemp));
	dynamic_switch.insert(std::make_pair("cim:CombustionTurbine.referenceTemp", &assign_CombustionTurbine_referenceTemp));
	dynamic_switch.insert(std::make_pair("cim:CombustionTurbine.timeConstant", &assign_CombustionTurbine_timeConstant));
	dynamic_switch.insert(std::make_pair("cim:FossilSteamSupply.auxPowerVersusFrequency", &assign_FossilSteamSupply_auxPowerVersusFrequency));
	dynamic_switch.insert(std::make_pair("cim:FossilSteamSupply.auxPowerVersusVoltage", &assign_FossilSteamSupply_auxPowerVersusVoltage));
	dynamic_switch.insert(std::make_pair("cim:FossilSteamSupply.boilerControlMode", &assign_FossilSteamSupply_boilerControlMode));
	dynamic_switch.insert(std::make_pair("cim:FossilSteamSupply.controlErrorBiasP", &assign_FossilSteamSupply_controlErrorBiasP));
	dynamic_switch.insert(std::make_pair("cim:FossilSteamSupply.controlIC", &assign_FossilSteamSupply_controlIC));
	dynamic_switch.insert(std::make_pair("cim:FossilSteamSupply.controlPC", &assign_FossilSteamSupply_controlPC));
	dynamic_switch.insert(std::make_pair("cim:FossilSteamSupply.controlPEB", &assign_FossilSteamSupply_controlPEB));
	dynamic_switch.insert(std::make_pair("cim:FossilSteamSupply.controlPED", &assign_FossilSteamSupply_controlPED));
	dynamic_switch.insert(std::make_pair("cim:FossilSteamSupply.controlTC", &assign_FossilSteamSupply_controlTC));
	dynamic_switch.insert(std::make_pair("cim:FossilSteamSupply.feedWaterIG", &assign_FossilSteamSupply_feedWaterIG));
	dynamic_switch.insert(std::make_pair("cim:FossilSteamSupply.feedWaterPG", &assign_FossilSteamSupply_feedWaterPG));
	dynamic_switch.insert(std::make_pair("cim:FossilSteamSupply.feedWaterTC", &assign_FossilSteamSupply_feedWaterTC));
	dynamic_switch.insert(std::make_pair("cim:FossilSteamSupply.fuelDemandLimit", &assign_FossilSteamSupply_fuelDemandLimit));
	dynamic_switch.insert(std::make_pair("cim:FossilSteamSupply.fuelSupplyDelay", &assign_FossilSteamSupply_fuelSupplyDelay));
	dynamic_switch.insert(std::make_pair("cim:FossilSteamSupply.fuelSupplyTC", &assign_FossilSteamSupply_fuelSupplyTC));
	dynamic_switch.insert(std::make_pair("cim:FossilSteamSupply.maxErrorRateP", &assign_FossilSteamSupply_maxErrorRateP));
	dynamic_switch.insert(std::make_pair("cim:FossilSteamSupply.mechPowerSensorLag", &assign_FossilSteamSupply_mechPowerSensorLag));
	dynamic_switch.insert(std::make_pair("cim:FossilSteamSupply.minErrorRateP", &assign_FossilSteamSupply_minErrorRateP));
	dynamic_switch.insert(std::make_pair("cim:FossilSteamSupply.pressureCtrlDG", &assign_FossilSteamSupply_pressureCtrlDG));
	dynamic_switch.insert(std::make_pair("cim:FossilSteamSupply.pressureCtrlIG", &assign_FossilSteamSupply_pressureCtrlIG));
	dynamic_switch.insert(std::make_pair("cim:FossilSteamSupply.pressureCtrlPG", &assign_FossilSteamSupply_pressureCtrlPG));
	dynamic_switch.insert(std::make_pair("cim:FossilSteamSupply.pressureFeedback", &assign_FossilSteamSupply_pressureFeedback));
	dynamic_switch.insert(std::make_pair("cim:FossilSteamSupply.superHeater1Capacity", &assign_FossilSteamSupply_superHeater1Capacity));
	dynamic_switch.insert(std::make_pair("cim:FossilSteamSupply.superHeater2Capacity", &assign_FossilSteamSupply_superHeater2Capacity));
	dynamic_switch.insert(std::make_pair("cim:FossilSteamSupply.superHeaterPipePD", &assign_FossilSteamSupply_superHeaterPipePD));
	dynamic_switch.insert(std::make_pair("cim:FossilSteamSupply.throttlePressureSP", &assign_FossilSteamSupply_throttlePressureSP));
	dynamic_switch.insert(std::make_pair("cim:DrumBoiler.drumBoilerRating", &assign_DrumBoiler_drumBoilerRating));
	dynamic_switch.insert(std::make_pair("cim:HeatRecoveryBoiler.steamSupplyRating2", &assign_HeatRecoveryBoiler_steamSupplyRating2));
	dynamic_switch.insert(std::make_pair("cim:HydroTurbine.gateRateLimit", &assign_HydroTurbine_gateRateLimit));
	dynamic_switch.insert(std::make_pair("cim:HydroTurbine.gateUpperLimit", &assign_HydroTurbine_gateUpperLimit));
	dynamic_switch.insert(std::make_pair("cim:HydroTurbine.maxHeadMaxP", &assign_HydroTurbine_maxHeadMaxP));
	dynamic_switch.insert(std::make_pair("cim:HydroTurbine.minHeadMaxP", &assign_HydroTurbine_minHeadMaxP));
	dynamic_switch.insert(std::make_pair("cim:HydroTurbine.speedRating", &assign_HydroTurbine_speedRating));
	dynamic_switch.insert(std::make_pair("cim:HydroTurbine.speedRegulation", &assign_HydroTurbine_speedRegulation));
	dynamic_switch.insert(std::make_pair("cim:HydroTurbine.transientDroopTime", &assign_HydroTurbine_transientDroopTime));
	dynamic_switch.insert(std::make_pair("cim:HydroTurbine.transientRegulation", &assign_HydroTurbine_transientRegulation));
	dynamic_switch.insert(std::make_pair("cim:HydroTurbine.turbineRating", &assign_HydroTurbine_turbineRating));
	dynamic_switch.insert(std::make_pair("cim:HydroTurbine.turbineType", &assign_HydroTurbine_turbineType));
	dynamic_switch.insert(std::make_pair("cim:HydroTurbine.waterStartingTime", &assign_HydroTurbine_waterStartingTime));
	dynamic_switch.insert(std::make_pair("cim:PWRSteamSupply.coldLegFBLagTC", &assign_PWRSteamSupply_coldLegFBLagTC));
	dynamic_switch.insert(std::make_pair("cim:PWRSteamSupply.coldLegFBLeadTC1", &assign_PWRSteamSupply_coldLegFBLeadTC1));
	dynamic_switch.insert(std::make_pair("cim:PWRSteamSupply.coldLegFBLeadTC2", &assign_PWRSteamSupply_coldLegFBLeadTC2));
	dynamic_switch.insert(std::make_pair("cim:PWRSteamSupply.coldLegFG1", &assign_PWRSteamSupply_coldLegFG1));
	dynamic_switch.insert(std::make_pair("cim:PWRSteamSupply.coldLegFG2", &assign_PWRSteamSupply_coldLegFG2));
	dynamic_switch.insert(std::make_pair("cim:PWRSteamSupply.coldLegLagTC", &assign_PWRSteamSupply_coldLegLagTC));
	dynamic_switch.insert(std::make_pair("cim:PWRSteamSupply.coreHTLagTC1", &assign_PWRSteamSupply_coreHTLagTC1));
	dynamic_switch.insert(std::make_pair("cim:PWRSteamSupply.coreHTLagTC2", &assign_PWRSteamSupply_coreHTLagTC2));
	dynamic_switch.insert(std::make_pair("cim:PWRSteamSupply.coreNeutronicsEffTC", &assign_PWRSteamSupply_coreNeutronicsEffTC));
	dynamic_switch.insert(std::make_pair("cim:PWRSteamSupply.coreNeutronicsHT", &assign_PWRSteamSupply_coreNeutronicsHT));
	dynamic_switch.insert(std::make_pair("cim:PWRSteamSupply.feedbackFactor", &assign_PWRSteamSupply_feedbackFactor));
	dynamic_switch.insert(std::make_pair("cim:PWRSteamSupply.hotLegLagTC", &assign_PWRSteamSupply_hotLegLagTC));
	dynamic_switch.insert(std::make_pair("cim:PWRSteamSupply.hotLegSteamGain", &assign_PWRSteamSupply_hotLegSteamGain));
	dynamic_switch.insert(std::make_pair("cim:PWRSteamSupply.hotLegToColdLegGain", &assign_PWRSteamSupply_hotLegToColdLegGain));
	dynamic_switch.insert(std::make_pair("cim:PWRSteamSupply.pressureCG", &assign_PWRSteamSupply_pressureCG));
	dynamic_switch.insert(std::make_pair("cim:PWRSteamSupply.steamFlowFG", &assign_PWRSteamSupply_steamFlowFG));
	dynamic_switch.insert(std::make_pair("cim:PWRSteamSupply.steamPressureDropLagTC", &assign_PWRSteamSupply_steamPressureDropLagTC));
	dynamic_switch.insert(std::make_pair("cim:PWRSteamSupply.steamPressureFG", &assign_PWRSteamSupply_steamPressureFG));
	dynamic_switch.insert(std::make_pair("cim:PWRSteamSupply.throttlePressureFactor", &assign_PWRSteamSupply_throttlePressureFactor));
	dynamic_switch.insert(std::make_pair("cim:PWRSteamSupply.throttlePressureSP", &assign_PWRSteamSupply_throttlePressureSP));
	dynamic_switch.insert(std::make_pair("cim:CostPerHeatUnit.multiplier", &assign_CostPerHeatUnit_multiplier));
	dynamic_switch.insert(std::make_pair("cim:CostPerHeatUnit.unit", &assign_CostPerHeatUnit_unit));
	dynamic_switch.insert(std::make_pair("cim:HeatRateCurve.isNetGrossP", &assign_HeatRateCurve_isNetGrossP));
	dynamic_switch.insert(std::make_pair("cim:FuelAllocationSchedule.fuelAllocationEndDate", &assign_FuelAllocationSchedule_fuelAllocationEndDate));
	dynamic_switch.insert(std::make_pair("cim:FuelAllocationSchedule.fuelAllocationStartDate", &assign_FuelAllocationSchedule_fuelAllocationStartDate));
	dynamic_switch.insert(std::make_pair("cim:FuelAllocationSchedule.fuelType", &assign_FuelAllocationSchedule_fuelType));
	dynamic_switch.insert(std::make_pair("cim:FuelAllocationSchedule.maxFuelAllocation", &assign_FuelAllocationSchedule_maxFuelAllocation));
	dynamic_switch.insert(std::make_pair("cim:FuelAllocationSchedule.minFuelAllocation", &assign_FuelAllocationSchedule_minFuelAllocation));
	dynamic_switch.insert(std::make_pair("cim:HeatRate.multiplier", &assign_HeatRate_multiplier));
	dynamic_switch.insert(std::make_pair("cim:StartRampCurve.hotStandbyRamp", &assign_StartRampCurve_hotStandbyRamp));
	dynamic_switch.insert(std::make_pair("cim:StartIgnFuelCurve.ignitionFuelType", &assign_StartIgnFuelCurve_ignitionFuelType));
	dynamic_switch.insert(std::make_pair("cim:StartMainFuelCurve.mainFuelType", &assign_StartMainFuelCurve_mainFuelType));
	dynamic_switch.insert(std::make_pair("cim:StartupModel.fixedMaintCost", &assign_StartupModel_fixedMaintCost));
	dynamic_switch.insert(std::make_pair("cim:StartupModel.hotStandbyHeat", &assign_StartupModel_hotStandbyHeat));
	dynamic_switch.insert(std::make_pair("cim:StartupModel.incrementalMaintCost", &assign_StartupModel_incrementalMaintCost));
	dynamic_switch.insert(std::make_pair("cim:StartupModel.minimumDownTime", &assign_StartupModel_minimumDownTime));
	dynamic_switch.insert(std::make_pair("cim:StartupModel.minimumRunTime", &assign_StartupModel_minimumRunTime));
	dynamic_switch.insert(std::make_pair("cim:StartupModel.riskFactorCost", &assign_StartupModel_riskFactorCost));
	dynamic_switch.insert(std::make_pair("cim:StartupModel.startupCost", &assign_StartupModel_startupCost));
	dynamic_switch.insert(std::make_pair("cim:StartupModel.startupDate", &assign_StartupModel_startupDate));
	dynamic_switch.insert(std::make_pair("cim:StartupModel.startupPriority", &assign_StartupModel_startupPriority));
	dynamic_switch.insert(std::make_pair("cim:StartupModel.stbyAuxP", &assign_StartupModel_stbyAuxP));
	dynamic_switch.insert(std::make_pair("cim:EmissionCurve.emissionContent", &assign_EmissionCurve_emissionContent));
	dynamic_switch.insert(std::make_pair("cim:EmissionCurve.emissionType", &assign_EmissionCurve_emissionType));
	dynamic_switch.insert(std::make_pair("cim:EmissionCurve.isNetGrossP", &assign_EmissionCurve_isNetGrossP));
	dynamic_switch.insert(std::make_pair("cim:ShutdownCurve.shutdownCost", &assign_ShutdownCurve_shutdownCost));
	dynamic_switch.insert(std::make_pair("cim:ShutdownCurve.shutdownDate", &assign_ShutdownCurve_shutdownDate));
	dynamic_switch.insert(std::make_pair("cim:IncrementalHeatRateCurve.isNetGrossP", &assign_IncrementalHeatRateCurve_isNetGrossP));
	dynamic_switch.insert(std::make_pair("cim:EmissionAccount.emissionType", &assign_EmissionAccount_emissionType));
	dynamic_switch.insert(std::make_pair("cim:EmissionAccount.emissionValueSource", &assign_EmissionAccount_emissionValueSource));
	dynamic_switch.insert(std::make_pair("cim:HeatInputCurve.auxPowerMult", &assign_HeatInputCurve_auxPowerMult));
	dynamic_switch.insert(std::make_pair("cim:HeatInputCurve.auxPowerOffset", &assign_HeatInputCurve_auxPowerOffset));
	dynamic_switch.insert(std::make_pair("cim:HeatInputCurve.heatInputEff", &assign_HeatInputCurve_heatInputEff));
	dynamic_switch.insert(std::make_pair("cim:HeatInputCurve.heatInputOffset", &assign_HeatInputCurve_heatInputOffset));
	dynamic_switch.insert(std::make_pair("cim:HeatInputCurve.isNetGrossP", &assign_HeatInputCurve_isNetGrossP));
	dynamic_switch.insert(std::make_pair("cim:ThermalGeneratingUnit.oMCost", &assign_ThermalGeneratingUnit_oMCost));
	dynamic_switch.insert(std::make_pair("cim:CAESPlant.energyStorageCapacity", &assign_CAESPlant_energyStorageCapacity));
	dynamic_switch.insert(std::make_pair("cim:CAESPlant.ratedCapacityP", &assign_CAESPlant_ratedCapacityP));
	dynamic_switch.insert(std::make_pair("cim:CogenerationPlant.cogenHPSendoutRating", &assign_CogenerationPlant_cogenHPSendoutRating));
	dynamic_switch.insert(std::make_pair("cim:CogenerationPlant.cogenHPSteamRating", &assign_CogenerationPlant_cogenHPSteamRating));
	dynamic_switch.insert(std::make_pair("cim:CogenerationPlant.cogenLPSendoutRating", &assign_CogenerationPlant_cogenLPSendoutRating));
	dynamic_switch.insert(std::make_pair("cim:CogenerationPlant.cogenLPSteamRating", &assign_CogenerationPlant_cogenLPSteamRating));
	dynamic_switch.insert(std::make_pair("cim:CogenerationPlant.ratedP", &assign_CogenerationPlant_ratedP));
	dynamic_switch.insert(std::make_pair("cim:CombinedCyclePlant.combCyclePlantRating", &assign_CombinedCyclePlant_combCyclePlantRating));
	dynamic_switch.insert(std::make_pair("cim:FossilFuel.fossilFuelType", &assign_FossilFuel_fossilFuelType));
	dynamic_switch.insert(std::make_pair("cim:FossilFuel.fuelCost", &assign_FossilFuel_fuelCost));
	dynamic_switch.insert(std::make_pair("cim:FossilFuel.fuelDispatchCost", &assign_FossilFuel_fuelDispatchCost));
	dynamic_switch.insert(std::make_pair("cim:FossilFuel.fuelEffFactor", &assign_FossilFuel_fuelEffFactor));
	dynamic_switch.insert(std::make_pair("cim:FossilFuel.fuelHandlingCost", &assign_FossilFuel_fuelHandlingCost));
	dynamic_switch.insert(std::make_pair("cim:FossilFuel.fuelHeatContent", &assign_FossilFuel_fuelHeatContent));
	dynamic_switch.insert(std::make_pair("cim:FossilFuel.fuelMixture", &assign_FossilFuel_fuelMixture));
	dynamic_switch.insert(std::make_pair("cim:FossilFuel.fuelSulfur", &assign_FossilFuel_fuelSulfur));
	dynamic_switch.insert(std::make_pair("cim:FossilFuel.highBreakpointP", &assign_FossilFuel_highBreakpointP));
	dynamic_switch.insert(std::make_pair("cim:FossilFuel.lowBreakpointP", &assign_FossilFuel_lowBreakpointP));
	dynamic_switch.insert(std::make_pair("cim:HydroGeneratingUnit.energyConversionCapability", &assign_HydroGeneratingUnit_energyConversionCapability));
	dynamic_switch.insert(std::make_pair("cim:HydroGeneratingUnit.hydroUnitWaterCost", &assign_HydroGeneratingUnit_hydroUnitWaterCost));
	dynamic_switch.insert(std::make_pair("cim:TargetLevelSchedule.highLevelLimit", &assign_TargetLevelSchedule_highLevelLimit));
	dynamic_switch.insert(std::make_pair("cim:TargetLevelSchedule.lowLevelLimit", &assign_TargetLevelSchedule_lowLevelLimit));
	dynamic_switch.insert(std::make_pair("cim:Reservoir.activeStorageCapacity", &assign_Reservoir_activeStorageCapacity));
	dynamic_switch.insert(std::make_pair("cim:Reservoir.energyStorageRating", &assign_Reservoir_energyStorageRating));
	dynamic_switch.insert(std::make_pair("cim:Reservoir.fullSupplyLevel", &assign_Reservoir_fullSupplyLevel));
	dynamic_switch.insert(std::make_pair("cim:Reservoir.grossCapacity", &assign_Reservoir_grossCapacity));
	dynamic_switch.insert(std::make_pair("cim:Reservoir.normalMinOperateLevel", &assign_Reservoir_normalMinOperateLevel));
	dynamic_switch.insert(std::make_pair("cim:Reservoir.riverOutletWorks", &assign_Reservoir_riverOutletWorks));
	dynamic_switch.insert(std::make_pair("cim:Reservoir.spillTravelDelay", &assign_Reservoir_spillTravelDelay));
	dynamic_switch.insert(std::make_pair("cim:Reservoir.spillwayCapacity", &assign_Reservoir_spillwayCapacity));
	dynamic_switch.insert(std::make_pair("cim:Reservoir.spillwayCrestLength", &assign_Reservoir_spillwayCrestLength));
	dynamic_switch.insert(std::make_pair("cim:Reservoir.spillwayCrestLevel", &assign_Reservoir_spillwayCrestLevel));
	dynamic_switch.insert(std::make_pair("cim:Reservoir.spillWayGateType", &assign_Reservoir_spillWayGateType));
	dynamic_switch.insert(std::make_pair("cim:HydroPowerPlant.dischargeTravelDelay", &assign_HydroPowerPlant_dischargeTravelDelay));
	dynamic_switch.insert(std::make_pair("cim:HydroPowerPlant.genRatedP", &assign_HydroPowerPlant_genRatedP));
	dynamic_switch.insert(std::make_pair("cim:HydroPowerPlant.hydroPlantStorageType", &assign_HydroPowerPlant_hydroPlantStorageType));
	dynamic_switch.insert(std::make_pair("cim:HydroPowerPlant.penstockType", &assign_HydroPowerPlant_penstockType));
	dynamic_switch.insert(std::make_pair("cim:HydroPowerPlant.plantDischargeCapacity", &assign_HydroPowerPlant_plantDischargeCapacity));
	dynamic_switch.insert(std::make_pair("cim:HydroPowerPlant.plantRatedHead", &assign_HydroPowerPlant_plantRatedHead));
	dynamic_switch.insert(std::make_pair("cim:HydroPowerPlant.pumpRatedP", &assign_HydroPowerPlant_pumpRatedP));
	dynamic_switch.insert(std::make_pair("cim:HydroPowerPlant.surgeTankCode", &assign_HydroPowerPlant_surgeTankCode));
	dynamic_switch.insert(std::make_pair("cim:HydroPowerPlant.surgeTankCrestLevel", &assign_HydroPowerPlant_surgeTankCrestLevel));
	dynamic_switch.insert(std::make_pair("cim:WindGeneratingUnit.windGenUnitType", &assign_WindGeneratingUnit_windGenUnitType));
	dynamic_switch.insert(std::make_pair("cim:LoadResponseCharacteristic.exponentModel", &assign_LoadResponseCharacteristic_exponentModel));
	dynamic_switch.insert(std::make_pair("cim:LoadResponseCharacteristic.pConstantCurrent", &assign_LoadResponseCharacteristic_pConstantCurrent));
	dynamic_switch.insert(std::make_pair("cim:LoadResponseCharacteristic.pConstantImpedance", &assign_LoadResponseCharacteristic_pConstantImpedance));
	dynamic_switch.insert(std::make_pair("cim:LoadResponseCharacteristic.pConstantPower", &assign_LoadResponseCharacteristic_pConstantPower));
	dynamic_switch.insert(std::make_pair("cim:LoadResponseCharacteristic.pFrequencyExponent", &assign_LoadResponseCharacteristic_pFrequencyExponent));
	dynamic_switch.insert(std::make_pair("cim:LoadResponseCharacteristic.pVoltageExponent", &assign_LoadResponseCharacteristic_pVoltageExponent));
	dynamic_switch.insert(std::make_pair("cim:LoadResponseCharacteristic.qConstantCurrent", &assign_LoadResponseCharacteristic_qConstantCurrent));
	dynamic_switch.insert(std::make_pair("cim:LoadResponseCharacteristic.qConstantImpedance", &assign_LoadResponseCharacteristic_qConstantImpedance));
	dynamic_switch.insert(std::make_pair("cim:LoadResponseCharacteristic.qConstantPower", &assign_LoadResponseCharacteristic_qConstantPower));
	dynamic_switch.insert(std::make_pair("cim:LoadResponseCharacteristic.qFrequencyExponent", &assign_LoadResponseCharacteristic_qFrequencyExponent));
	dynamic_switch.insert(std::make_pair("cim:LoadResponseCharacteristic.qVoltageExponent", &assign_LoadResponseCharacteristic_qVoltageExponent));
	dynamic_switch.insert(std::make_pair("cim:EnergyConsumerPhase.pfixed", &assign_EnergyConsumerPhase_pfixed));
	dynamic_switch.insert(std::make_pair("cim:EnergyConsumerPhase.pfixedPct", &assign_EnergyConsumerPhase_pfixedPct));
	dynamic_switch.insert(std::make_pair("cim:EnergyConsumerPhase.phase", &assign_EnergyConsumerPhase_phase));
	dynamic_switch.insert(std::make_pair("cim:EnergyConsumerPhase.qfixed", &assign_EnergyConsumerPhase_qfixed));
	dynamic_switch.insert(std::make_pair("cim:EnergyConsumerPhase.qfixedPct", &assign_EnergyConsumerPhase_qfixedPct));
	dynamic_switch.insert(std::make_pair("cim:EnergyConsumer.customerCount", &assign_EnergyConsumer_customerCount));
	dynamic_switch.insert(std::make_pair("cim:EnergyConsumer.grounded", &assign_EnergyConsumer_grounded));
	dynamic_switch.insert(std::make_pair("cim:EnergyConsumer.p", &assign_EnergyConsumer_p));
	dynamic_switch.insert(std::make_pair("cim:EnergyConsumer.pfixed", &assign_EnergyConsumer_pfixed));
	dynamic_switch.insert(std::make_pair("cim:EnergyConsumer.pfixedPct", &assign_EnergyConsumer_pfixedPct));
	dynamic_switch.insert(std::make_pair("cim:EnergyConsumer.phaseConnection", &assign_EnergyConsumer_phaseConnection));
	dynamic_switch.insert(std::make_pair("cim:EnergyConsumer.q", &assign_EnergyConsumer_q));
	dynamic_switch.insert(std::make_pair("cim:EnergyConsumer.qfixed", &assign_EnergyConsumer_qfixed));
	dynamic_switch.insert(std::make_pair("cim:EnergyConsumer.qfixedPct", &assign_EnergyConsumer_qfixedPct));
	dynamic_switch.insert(std::make_pair("cim:PowerCutZone.cutLevel1", &assign_PowerCutZone_cutLevel1));
	dynamic_switch.insert(std::make_pair("cim:PowerCutZone.cutLevel2", &assign_PowerCutZone_cutLevel2));
	dynamic_switch.insert(std::make_pair("cim:Season.endDate", &assign_Season_endDate));
	dynamic_switch.insert(std::make_pair("cim:Season.startDate", &assign_Season_startDate));
	dynamic_switch.insert(std::make_pair("cim:AccumulatorValue.value", &assign_AccumulatorValue_value));
	dynamic_switch.insert(std::make_pair("cim:AccumulatorLimit.value", &assign_AccumulatorLimit_value));
	dynamic_switch.insert(std::make_pair("cim:LimitSet.isPercentageLimits", &assign_LimitSet_isPercentageLimits));
	dynamic_switch.insert(std::make_pair("cim:Accumulator.maxValue", &assign_Accumulator_maxValue));
	dynamic_switch.insert(std::make_pair("cim:AnalogLimit.value", &assign_AnalogLimit_value));
	dynamic_switch.insert(std::make_pair("cim:Analog.maxValue", &assign_Analog_maxValue));
	dynamic_switch.insert(std::make_pair("cim:Analog.minValue", &assign_Analog_minValue));
	dynamic_switch.insert(std::make_pair("cim:Analog.normalValue", &assign_Analog_normalValue));
	dynamic_switch.insert(std::make_pair("cim:Analog.positiveFlowIn", &assign_Analog_positiveFlowIn));
	dynamic_switch.insert(std::make_pair("cim:ValueToAlias.value", &assign_ValueToAlias_value));
	dynamic_switch.insert(std::make_pair("cim:Command.normalValue", &assign_Command_normalValue));
	dynamic_switch.insert(std::make_pair("cim:Command.value", &assign_Command_value));
	dynamic_switch.insert(std::make_pair("cim:DiscreteValue.value", &assign_DiscreteValue_value));
	dynamic_switch.insert(std::make_pair("cim:Discrete.maxValue", &assign_Discrete_maxValue));
	dynamic_switch.insert(std::make_pair("cim:Discrete.minValue", &assign_Discrete_minValue));
	dynamic_switch.insert(std::make_pair("cim:Discrete.normalValue", &assign_Discrete_normalValue));
	dynamic_switch.insert(std::make_pair("cim:SetPoint.normalValue", &assign_SetPoint_normalValue));
	dynamic_switch.insert(std::make_pair("cim:SetPoint.value", &assign_SetPoint_value));
	dynamic_switch.insert(std::make_pair("cim:StringMeasurementValue.value", &assign_StringMeasurementValue_value));
	dynamic_switch.insert(std::make_pair("cim:OperationalLimitType.acceptableDuration", &assign_OperationalLimitType_acceptableDuration));
	dynamic_switch.insert(std::make_pair("cim:OperationalLimitType.direction", &assign_OperationalLimitType_direction));
	dynamic_switch.insert(std::make_pair("cim:ActivePowerLimit.value", &assign_ActivePowerLimit_value));
	dynamic_switch.insert(std::make_pair("cim:ApparentPowerLimit.value", &assign_ApparentPowerLimit_value));
	dynamic_switch.insert(std::make_pair("cim:BranchGroupTerminal.positiveFlowIn", &assign_BranchGroupTerminal_positiveFlowIn));
	dynamic_switch.insert(std::make_pair("cim:BranchGroup.maximumActivePower", &assign_BranchGroup_maximumActivePower));
	dynamic_switch.insert(std::make_pair("cim:BranchGroup.maximumReactivePower", &assign_BranchGroup_maximumReactivePower));
	dynamic_switch.insert(std::make_pair("cim:BranchGroup.minimumActivePower", &assign_BranchGroup_minimumActivePower));
	dynamic_switch.insert(std::make_pair("cim:BranchGroup.minimumReactivePower", &assign_BranchGroup_minimumReactivePower));
	dynamic_switch.insert(std::make_pair("cim:BranchGroup.monitorActivePower", &assign_BranchGroup_monitorActivePower));
	dynamic_switch.insert(std::make_pair("cim:BranchGroup.monitorReactivePower", &assign_BranchGroup_monitorReactivePower));
	dynamic_switch.insert(std::make_pair("cim:CurrentLimit.value", &assign_CurrentLimit_value));
	dynamic_switch.insert(std::make_pair("cim:VoltageLimit.value", &assign_VoltageLimit_value));
	dynamic_switch.insert(std::make_pair("cim:RecloseSequence.recloseDelay", &assign_RecloseSequence_recloseDelay));
	dynamic_switch.insert(std::make_pair("cim:RecloseSequence.recloseStep", &assign_RecloseSequence_recloseStep));
	dynamic_switch.insert(std::make_pair("cim:SwitchPhase.closed", &assign_SwitchPhase_closed));
	dynamic_switch.insert(std::make_pair("cim:SwitchPhase.normalOpen", &assign_SwitchPhase_normalOpen));
	dynamic_switch.insert(std::make_pair("cim:SwitchPhase.phaseSide1", &assign_SwitchPhase_phaseSide1));
	dynamic_switch.insert(std::make_pair("cim:SwitchPhase.phaseSide2", &assign_SwitchPhase_phaseSide2));
	dynamic_switch.insert(std::make_pair("cim:Switch.normalOpen", &assign_Switch_normalOpen));
	dynamic_switch.insert(std::make_pair("cim:Switch.open", &assign_Switch_open));
	dynamic_switch.insert(std::make_pair("cim:Switch.ratedCurrent", &assign_Switch_ratedCurrent));
	dynamic_switch.insert(std::make_pair("cim:Switch.retained", &assign_Switch_retained));
	dynamic_switch.insert(std::make_pair("cim:Switch.switchOnCount", &assign_Switch_switchOnCount));
	dynamic_switch.insert(std::make_pair("cim:Switch.switchOnDate", &assign_Switch_switchOnDate));
	dynamic_switch.insert(std::make_pair("cim:ProtectedSwitch.breakingCapacity", &assign_ProtectedSwitch_breakingCapacity));
	dynamic_switch.insert(std::make_pair("cim:ProtectionEquipment.highLimit", &assign_ProtectionEquipment_highLimit));
	dynamic_switch.insert(std::make_pair("cim:ProtectionEquipment.lowLimit", &assign_ProtectionEquipment_lowLimit));
	dynamic_switch.insert(std::make_pair("cim:ProtectionEquipment.powerDirectionFlag", &assign_ProtectionEquipment_powerDirectionFlag));
	dynamic_switch.insert(std::make_pair("cim:ProtectionEquipment.relayDelayTime", &assign_ProtectionEquipment_relayDelayTime));
	dynamic_switch.insert(std::make_pair("cim:ProtectionEquipment.unitMultiplier", &assign_ProtectionEquipment_unitMultiplier));
	dynamic_switch.insert(std::make_pair("cim:ProtectionEquipment.unitSymbol", &assign_ProtectionEquipment_unitSymbol));
	dynamic_switch.insert(std::make_pair("cim:CurrentRelay.currentLimit1", &assign_CurrentRelay_currentLimit1));
	dynamic_switch.insert(std::make_pair("cim:CurrentRelay.currentLimit2", &assign_CurrentRelay_currentLimit2));
	dynamic_switch.insert(std::make_pair("cim:CurrentRelay.currentLimit3", &assign_CurrentRelay_currentLimit3));
	dynamic_switch.insert(std::make_pair("cim:CurrentRelay.inverseTimeFlag", &assign_CurrentRelay_inverseTimeFlag));
	dynamic_switch.insert(std::make_pair("cim:CurrentRelay.timeDelay1", &assign_CurrentRelay_timeDelay1));
	dynamic_switch.insert(std::make_pair("cim:CurrentRelay.timeDelay2", &assign_CurrentRelay_timeDelay2));
	dynamic_switch.insert(std::make_pair("cim:CurrentRelay.timeDelay3", &assign_CurrentRelay_timeDelay3));
	dynamic_switch.insert(std::make_pair("cim:SynchrocheckRelay.maxAngleDiff", &assign_SynchrocheckRelay_maxAngleDiff));
	dynamic_switch.insert(std::make_pair("cim:SynchrocheckRelay.maxFreqDiff", &assign_SynchrocheckRelay_maxFreqDiff));
	dynamic_switch.insert(std::make_pair("cim:SynchrocheckRelay.maxVoltDiff", &assign_SynchrocheckRelay_maxVoltDiff));
	dynamic_switch.insert(std::make_pair("cim:RemoteUnit.remoteUnitType", &assign_RemoteUnit_remoteUnitType));
	dynamic_switch.insert(std::make_pair("cim:RemoteControl.actuatorMaximum", &assign_RemoteControl_actuatorMaximum));
	dynamic_switch.insert(std::make_pair("cim:RemoteControl.actuatorMinimum", &assign_RemoteControl_actuatorMinimum));
	dynamic_switch.insert(std::make_pair("cim:RemoteControl.remoteControlled", &assign_RemoteControl_remoteControlled));
	dynamic_switch.insert(std::make_pair("cim:TopologicalNode.pInjection", &assign_TopologicalNode_pInjection));
	dynamic_switch.insert(std::make_pair("cim:TopologicalNode.qInjection", &assign_TopologicalNode_qInjection));
	dynamic_switch.insert(std::make_pair("cim:SvInjection.phase", &assign_SvInjection_phase));
	dynamic_switch.insert(std::make_pair("cim:SvInjection.pInjection", &assign_SvInjection_pInjection));
	dynamic_switch.insert(std::make_pair("cim:SvInjection.qInjection", &assign_SvInjection_qInjection));
	dynamic_switch.insert(std::make_pair("cim:SvPowerFlow.p", &assign_SvPowerFlow_p));
	dynamic_switch.insert(std::make_pair("cim:SvPowerFlow.phase", &assign_SvPowerFlow_phase));
	dynamic_switch.insert(std::make_pair("cim:SvPowerFlow.q", &assign_SvPowerFlow_q));
	dynamic_switch.insert(std::make_pair("cim:ShuntCompensatorPhase.maximumSections", &assign_ShuntCompensatorPhase_maximumSections));
	dynamic_switch.insert(std::make_pair("cim:ShuntCompensatorPhase.normalSections", &assign_ShuntCompensatorPhase_normalSections));
	dynamic_switch.insert(std::make_pair("cim:ShuntCompensatorPhase.phase", &assign_ShuntCompensatorPhase_phase));
	dynamic_switch.insert(std::make_pair("cim:ShuntCompensator.aVRDelay", &assign_ShuntCompensator_aVRDelay));
	dynamic_switch.insert(std::make_pair("cim:ShuntCompensator.grounded", &assign_ShuntCompensator_grounded));
	dynamic_switch.insert(std::make_pair("cim:ShuntCompensator.maximumSections", &assign_ShuntCompensator_maximumSections));
	dynamic_switch.insert(std::make_pair("cim:ShuntCompensator.nomU", &assign_ShuntCompensator_nomU));
	dynamic_switch.insert(std::make_pair("cim:ShuntCompensator.normalSections", &assign_ShuntCompensator_normalSections));
	dynamic_switch.insert(std::make_pair("cim:ShuntCompensator.phaseConnection", &assign_ShuntCompensator_phaseConnection));
	dynamic_switch.insert(std::make_pair("cim:ShuntCompensator.sections", &assign_ShuntCompensator_sections));
	dynamic_switch.insert(std::make_pair("cim:ShuntCompensator.switchOnCount", &assign_ShuntCompensator_switchOnCount));
	dynamic_switch.insert(std::make_pair("cim:ShuntCompensator.switchOnDate", &assign_ShuntCompensator_switchOnDate));
	dynamic_switch.insert(std::make_pair("cim:ShuntCompensator.voltageSensitivity", &assign_ShuntCompensator_voltageSensitivity));
	dynamic_switch.insert(std::make_pair("cim:SvShuntCompensatorSections.sections", &assign_SvShuntCompensatorSections_sections));
	dynamic_switch.insert(std::make_pair("cim:SvStatus.inService", &assign_SvStatus_inService));
	dynamic_switch.insert(std::make_pair("cim:SvStatus.phase", &assign_SvStatus_phase));
	dynamic_switch.insert(std::make_pair("cim:TapChangerControl.limitVoltage", &assign_TapChangerControl_limitVoltage));
	dynamic_switch.insert(std::make_pair("cim:TapChangerControl.lineDropCompensation", &assign_TapChangerControl_lineDropCompensation));
	dynamic_switch.insert(std::make_pair("cim:TapChangerControl.lineDropR", &assign_TapChangerControl_lineDropR));
	dynamic_switch.insert(std::make_pair("cim:TapChangerControl.lineDropX", &assign_TapChangerControl_lineDropX));
	dynamic_switch.insert(std::make_pair("cim:TapChangerControl.reverseLineDropR", &assign_TapChangerControl_reverseLineDropR));
	dynamic_switch.insert(std::make_pair("cim:TapChangerControl.reverseLineDropX", &assign_TapChangerControl_reverseLineDropX));
	dynamic_switch.insert(std::make_pair("cim:TapChanger.controlEnabled", &assign_TapChanger_controlEnabled));
	dynamic_switch.insert(std::make_pair("cim:TapChanger.highStep", &assign_TapChanger_highStep));
	dynamic_switch.insert(std::make_pair("cim:TapChanger.initialDelay", &assign_TapChanger_initialDelay));
	dynamic_switch.insert(std::make_pair("cim:TapChanger.lowStep", &assign_TapChanger_lowStep));
	dynamic_switch.insert(std::make_pair("cim:TapChanger.ltcFlag", &assign_TapChanger_ltcFlag));
	dynamic_switch.insert(std::make_pair("cim:TapChanger.neutralStep", &assign_TapChanger_neutralStep));
	dynamic_switch.insert(std::make_pair("cim:TapChanger.neutralU", &assign_TapChanger_neutralU));
	dynamic_switch.insert(std::make_pair("cim:TapChanger.normalStep", &assign_TapChanger_normalStep));
	dynamic_switch.insert(std::make_pair("cim:TapChanger.step", &assign_TapChanger_step));
	dynamic_switch.insert(std::make_pair("cim:TapChanger.subsequentDelay", &assign_TapChanger_subsequentDelay));
	dynamic_switch.insert(std::make_pair("cim:SvTapStep.position", &assign_SvTapStep_position));
	dynamic_switch.insert(std::make_pair("cim:SvVoltage.angle", &assign_SvVoltage_angle));
	dynamic_switch.insert(std::make_pair("cim:SvVoltage.phase", &assign_SvVoltage_phase));
	dynamic_switch.insert(std::make_pair("cim:SvVoltage.v", &assign_SvVoltage_v));
	dynamic_switch.insert(std::make_pair("cim:BusNameMarker.priority", &assign_BusNameMarker_priority));
	dynamic_switch.insert(std::make_pair("cim:ACLineSegmentPhase.phase", &assign_ACLineSegmentPhase_phase));
	dynamic_switch.insert(std::make_pair("cim:ACLineSegmentPhase.sequenceNumber", &assign_ACLineSegmentPhase_sequenceNumber));
	dynamic_switch.insert(std::make_pair("cim:AsynchronousMachine.asynchronousMachineType", &assign_AsynchronousMachine_asynchronousMachineType));
	dynamic_switch.insert(std::make_pair("cim:AsynchronousMachine.converterFedDrive", &assign_AsynchronousMachine_converterFedDrive));
	dynamic_switch.insert(std::make_pair("cim:AsynchronousMachine.efficiency", &assign_AsynchronousMachine_efficiency));
	dynamic_switch.insert(std::make_pair("cim:AsynchronousMachine.iaIrRatio", &assign_AsynchronousMachine_iaIrRatio));
	dynamic_switch.insert(std::make_pair("cim:AsynchronousMachine.nominalFrequency", &assign_AsynchronousMachine_nominalFrequency));
	dynamic_switch.insert(std::make_pair("cim:AsynchronousMachine.nominalSpeed", &assign_AsynchronousMachine_nominalSpeed));
	dynamic_switch.insert(std::make_pair("cim:AsynchronousMachine.polePairNumber", &assign_AsynchronousMachine_polePairNumber));
	dynamic_switch.insert(std::make_pair("cim:AsynchronousMachine.ratedMechanicalPower", &assign_AsynchronousMachine_ratedMechanicalPower));
	dynamic_switch.insert(std::make_pair("cim:AsynchronousMachine.reversible", &assign_AsynchronousMachine_reversible));
	dynamic_switch.insert(std::make_pair("cim:AsynchronousMachine.rr1", &assign_AsynchronousMachine_rr1));
	dynamic_switch.insert(std::make_pair("cim:AsynchronousMachine.rr2", &assign_AsynchronousMachine_rr2));
	dynamic_switch.insert(std::make_pair("cim:AsynchronousMachine.rxLockedRotorRatio", &assign_AsynchronousMachine_rxLockedRotorRatio));
	dynamic_switch.insert(std::make_pair("cim:AsynchronousMachine.tpo", &assign_AsynchronousMachine_tpo));
	dynamic_switch.insert(std::make_pair("cim:AsynchronousMachine.tppo", &assign_AsynchronousMachine_tppo));
	dynamic_switch.insert(std::make_pair("cim:AsynchronousMachine.xlr1", &assign_AsynchronousMachine_xlr1));
	dynamic_switch.insert(std::make_pair("cim:AsynchronousMachine.xlr2", &assign_AsynchronousMachine_xlr2));
	dynamic_switch.insert(std::make_pair("cim:AsynchronousMachine.xm", &assign_AsynchronousMachine_xm));
	dynamic_switch.insert(std::make_pair("cim:AsynchronousMachine.xp", &assign_AsynchronousMachine_xp));
	dynamic_switch.insert(std::make_pair("cim:AsynchronousMachine.xpp", &assign_AsynchronousMachine_xpp));
	dynamic_switch.insert(std::make_pair("cim:AsynchronousMachine.xs", &assign_AsynchronousMachine_xs));
	dynamic_switch.insert(std::make_pair("cim:Breaker.inTransitTime", &assign_Breaker_inTransitTime));
	dynamic_switch.insert(std::make_pair("cim:BusbarSection.ipMax", &assign_BusbarSection_ipMax));
	dynamic_switch.insert(std::make_pair("cim:CompositeSwitch.compositeSwitchType", &assign_CompositeSwitch_compositeSwitchType));
	dynamic_switch.insert(std::make_pair("cim:Cut.lengthFromTerminal1", &assign_Cut_lengthFromTerminal1));
	dynamic_switch.insert(std::make_pair("cim:EarthFaultCompensator.r", &assign_EarthFaultCompensator_r));
	dynamic_switch.insert(std::make_pair("cim:EnergySource.activePower", &assign_EnergySource_activePower));
	dynamic_switch.insert(std::make_pair("cim:EnergySource.nominalVoltage", &assign_EnergySource_nominalVoltage));
	dynamic_switch.insert(std::make_pair("cim:EnergySource.r", &assign_EnergySource_r));
	dynamic_switch.insert(std::make_pair("cim:EnergySource.r0", &assign_EnergySource_r0));
	dynamic_switch.insert(std::make_pair("cim:EnergySource.reactivePower", &assign_EnergySource_reactivePower));
	dynamic_switch.insert(std::make_pair("cim:EnergySource.rn", &assign_EnergySource_rn));
	dynamic_switch.insert(std::make_pair("cim:EnergySource.voltageAngle", &assign_EnergySource_voltageAngle));
	dynamic_switch.insert(std::make_pair("cim:EnergySource.voltageMagnitude", &assign_EnergySource_voltageMagnitude));
	dynamic_switch.insert(std::make_pair("cim:EnergySource.x", &assign_EnergySource_x));
	dynamic_switch.insert(std::make_pair("cim:EnergySource.x0", &assign_EnergySource_x0));
	dynamic_switch.insert(std::make_pair("cim:EnergySource.xn", &assign_EnergySource_xn));
	dynamic_switch.insert(std::make_pair("cim:EnergySourcePhase.phase", &assign_EnergySourcePhase_phase));
	dynamic_switch.insert(std::make_pair("cim:ExternalNetworkInjection.governorSCD", &assign_ExternalNetworkInjection_governorSCD));
	dynamic_switch.insert(std::make_pair("cim:ExternalNetworkInjection.ikSecond", &assign_ExternalNetworkInjection_ikSecond));
	dynamic_switch.insert(std::make_pair("cim:ExternalNetworkInjection.maxInitialSymShCCurrent", &assign_ExternalNetworkInjection_maxInitialSymShCCurrent));
	dynamic_switch.insert(std::make_pair("cim:ExternalNetworkInjection.maxP", &assign_ExternalNetworkInjection_maxP));
	dynamic_switch.insert(std::make_pair("cim:ExternalNetworkInjection.maxQ", &assign_ExternalNetworkInjection_maxQ));
	dynamic_switch.insert(std::make_pair("cim:ExternalNetworkInjection.maxR0ToX0Ratio", &assign_ExternalNetworkInjection_maxR0ToX0Ratio));
	dynamic_switch.insert(std::make_pair("cim:ExternalNetworkInjection.maxR1ToX1Ratio", &assign_ExternalNetworkInjection_maxR1ToX1Ratio));
	dynamic_switch.insert(std::make_pair("cim:ExternalNetworkInjection.maxZ0ToZ1Ratio", &assign_ExternalNetworkInjection_maxZ0ToZ1Ratio));
	dynamic_switch.insert(std::make_pair("cim:ExternalNetworkInjection.minInitialSymShCCurrent", &assign_ExternalNetworkInjection_minInitialSymShCCurrent));
	dynamic_switch.insert(std::make_pair("cim:ExternalNetworkInjection.minP", &assign_ExternalNetworkInjection_minP));
	dynamic_switch.insert(std::make_pair("cim:ExternalNetworkInjection.minQ", &assign_ExternalNetworkInjection_minQ));
	dynamic_switch.insert(std::make_pair("cim:ExternalNetworkInjection.minR0ToX0Ratio", &assign_ExternalNetworkInjection_minR0ToX0Ratio));
	dynamic_switch.insert(std::make_pair("cim:ExternalNetworkInjection.minR1ToX1Ratio", &assign_ExternalNetworkInjection_minR1ToX1Ratio));
	dynamic_switch.insert(std::make_pair("cim:ExternalNetworkInjection.minZ0ToZ1Ratio", &assign_ExternalNetworkInjection_minZ0ToZ1Ratio));
	dynamic_switch.insert(std::make_pair("cim:ExternalNetworkInjection.p", &assign_ExternalNetworkInjection_p));
	dynamic_switch.insert(std::make_pair("cim:ExternalNetworkInjection.q", &assign_ExternalNetworkInjection_q));
	dynamic_switch.insert(std::make_pair("cim:ExternalNetworkInjection.referencePriority", &assign_ExternalNetworkInjection_referencePriority));
	dynamic_switch.insert(std::make_pair("cim:ExternalNetworkInjection.voltageFactor", &assign_ExternalNetworkInjection_voltageFactor));
	dynamic_switch.insert(std::make_pair("cim:FrequencyConverter.frequency", &assign_FrequencyConverter_frequency));
	dynamic_switch.insert(std::make_pair("cim:FrequencyConverter.maxP", &assign_FrequencyConverter_maxP));
	dynamic_switch.insert(std::make_pair("cim:FrequencyConverter.maxU", &assign_FrequencyConverter_maxU));
	dynamic_switch.insert(std::make_pair("cim:FrequencyConverter.minP", &assign_FrequencyConverter_minP));
	dynamic_switch.insert(std::make_pair("cim:FrequencyConverter.minU", &assign_FrequencyConverter_minU));
	dynamic_switch.insert(std::make_pair("cim:GroundingImpedance.x", &assign_GroundingImpedance_x));
	dynamic_switch.insert(std::make_pair("cim:LinearShuntCompensator.b0PerSection", &assign_LinearShuntCompensator_b0PerSection));
	dynamic_switch.insert(std::make_pair("cim:LinearShuntCompensator.bPerSection", &assign_LinearShuntCompensator_bPerSection));
	dynamic_switch.insert(std::make_pair("cim:LinearShuntCompensator.g0PerSection", &assign_LinearShuntCompensator_g0PerSection));
	dynamic_switch.insert(std::make_pair("cim:LinearShuntCompensator.gPerSection", &assign_LinearShuntCompensator_gPerSection));
	dynamic_switch.insert(std::make_pair("cim:LinearShuntCompensatorPhase.bPerSection", &assign_LinearShuntCompensatorPhase_bPerSection));
	dynamic_switch.insert(std::make_pair("cim:LinearShuntCompensatorPhase.gPerSection", &assign_LinearShuntCompensatorPhase_gPerSection));
	dynamic_switch.insert(std::make_pair("cim:MutualCoupling.b0ch", &assign_MutualCoupling_b0ch));
	dynamic_switch.insert(std::make_pair("cim:MutualCoupling.distance11", &assign_MutualCoupling_distance11));
	dynamic_switch.insert(std::make_pair("cim:MutualCoupling.distance12", &assign_MutualCoupling_distance12));
	dynamic_switch.insert(std::make_pair("cim:MutualCoupling.distance21", &assign_MutualCoupling_distance21));
	dynamic_switch.insert(std::make_pair("cim:MutualCoupling.distance22", &assign_MutualCoupling_distance22));
	dynamic_switch.insert(std::make_pair("cim:MutualCoupling.g0ch", &assign_MutualCoupling_g0ch));
	dynamic_switch.insert(std::make_pair("cim:MutualCoupling.r0", &assign_MutualCoupling_r0));
	dynamic_switch.insert(std::make_pair("cim:MutualCoupling.x0", &assign_MutualCoupling_x0));
	dynamic_switch.insert(std::make_pair("cim:NonlinearShuntCompensatorPoint.b", &assign_NonlinearShuntCompensatorPoint_b));
	dynamic_switch.insert(std::make_pair("cim:NonlinearShuntCompensatorPoint.b0", &assign_NonlinearShuntCompensatorPoint_b0));
	dynamic_switch.insert(std::make_pair("cim:NonlinearShuntCompensatorPoint.g", &assign_NonlinearShuntCompensatorPoint_g));
	dynamic_switch.insert(std::make_pair("cim:NonlinearShuntCompensatorPoint.g0", &assign_NonlinearShuntCompensatorPoint_g0));
	dynamic_switch.insert(std::make_pair("cim:NonlinearShuntCompensatorPoint.sectionNumber", &assign_NonlinearShuntCompensatorPoint_sectionNumber));
	dynamic_switch.insert(std::make_pair("cim:NonlinearShuntCompensatorPhasePoint.b", &assign_NonlinearShuntCompensatorPhasePoint_b));
	dynamic_switch.insert(std::make_pair("cim:NonlinearShuntCompensatorPhasePoint.g", &assign_NonlinearShuntCompensatorPhasePoint_g));
	dynamic_switch.insert(std::make_pair("cim:NonlinearShuntCompensatorPhasePoint.sectionNumber", &assign_NonlinearShuntCompensatorPhasePoint_sectionNumber));
	dynamic_switch.insert(std::make_pair("cim:NonRotatingEnergy.maxP", &assign_NonRotatingEnergy_maxP));
	dynamic_switch.insert(std::make_pair("cim:NonRotatingEnergy.maxQ", &assign_NonRotatingEnergy_maxQ));
	dynamic_switch.insert(std::make_pair("cim:NonRotatingEnergy.minP", &assign_NonRotatingEnergy_minP));
	dynamic_switch.insert(std::make_pair("cim:NonRotatingEnergy.minQ", &assign_NonRotatingEnergy_minQ));
	dynamic_switch.insert(std::make_pair("cim:NonRotatingEnergy.p", &assign_NonRotatingEnergy_p));
	dynamic_switch.insert(std::make_pair("cim:NonRotatingEnergy.q", &assign_NonRotatingEnergy_q));
	dynamic_switch.insert(std::make_pair("cim:NonRotatingEnergy.r", &assign_NonRotatingEnergy_r));
	dynamic_switch.insert(std::make_pair("cim:NonRotatingEnergy.r0", &assign_NonRotatingEnergy_r0));
	dynamic_switch.insert(std::make_pair("cim:NonRotatingEnergy.rn", &assign_NonRotatingEnergy_rn));
	dynamic_switch.insert(std::make_pair("cim:NonRotatingEnergy.x", &assign_NonRotatingEnergy_x));
	dynamic_switch.insert(std::make_pair("cim:NonRotatingEnergy.x0", &assign_NonRotatingEnergy_x0));
	dynamic_switch.insert(std::make_pair("cim:NonRotatingEnergy.xn", &assign_NonRotatingEnergy_xn));
	dynamic_switch.insert(std::make_pair("cim:PhaseImpedanceData.b", &assign_PhaseImpedanceData_b));
	dynamic_switch.insert(std::make_pair("cim:PhaseImpedanceData.r", &assign_PhaseImpedanceData_r));
	dynamic_switch.insert(std::make_pair("cim:PhaseImpedanceData.sequenceNumber", &assign_PhaseImpedanceData_sequenceNumber));
	dynamic_switch.insert(std::make_pair("cim:PhaseImpedanceData.x", &assign_PhaseImpedanceData_x));
	dynamic_switch.insert(std::make_pair("cim:PerLengthPhaseImpedance.conductorCount", &assign_PerLengthPhaseImpedance_conductorCount));
	dynamic_switch.insert(std::make_pair("cim:PerLengthSequenceImpedance.b0ch", &assign_PerLengthSequenceImpedance_b0ch));
	dynamic_switch.insert(std::make_pair("cim:PerLengthSequenceImpedance.bch", &assign_PerLengthSequenceImpedance_bch));
	dynamic_switch.insert(std::make_pair("cim:PerLengthSequenceImpedance.g0ch", &assign_PerLengthSequenceImpedance_g0ch));
	dynamic_switch.insert(std::make_pair("cim:PerLengthSequenceImpedance.gch", &assign_PerLengthSequenceImpedance_gch));
	dynamic_switch.insert(std::make_pair("cim:PerLengthSequenceImpedance.r", &assign_PerLengthSequenceImpedance_r));
	dynamic_switch.insert(std::make_pair("cim:PerLengthSequenceImpedance.r0", &assign_PerLengthSequenceImpedance_r0));
	dynamic_switch.insert(std::make_pair("cim:PerLengthSequenceImpedance.x", &assign_PerLengthSequenceImpedance_x));
	dynamic_switch.insert(std::make_pair("cim:PerLengthSequenceImpedance.x0", &assign_PerLengthSequenceImpedance_x0));
	dynamic_switch.insert(std::make_pair("cim:PetersenCoil.mode", &assign_PetersenCoil_mode));
	dynamic_switch.insert(std::make_pair("cim:PetersenCoil.nominalU", &assign_PetersenCoil_nominalU));
	dynamic_switch.insert(std::make_pair("cim:PetersenCoil.offsetCurrent", &assign_PetersenCoil_offsetCurrent));
	dynamic_switch.insert(std::make_pair("cim:PetersenCoil.positionCurrent", &assign_PetersenCoil_positionCurrent));
	dynamic_switch.insert(std::make_pair("cim:PetersenCoil.xGroundMax", &assign_PetersenCoil_xGroundMax));
	dynamic_switch.insert(std::make_pair("cim:PetersenCoil.xGroundMin", &assign_PetersenCoil_xGroundMin));
	dynamic_switch.insert(std::make_pair("cim:PetersenCoil.xGroundNominal", &assign_PetersenCoil_xGroundNominal));
	dynamic_switch.insert(std::make_pair("cim:PhaseTapChangerNonLinear.voltageStepIncrement", &assign_PhaseTapChangerNonLinear_voltageStepIncrement));
	dynamic_switch.insert(std::make_pair("cim:PhaseTapChangerNonLinear.xMax", &assign_PhaseTapChangerNonLinear_xMax));
	dynamic_switch.insert(std::make_pair("cim:PhaseTapChangerNonLinear.xMin", &assign_PhaseTapChangerNonLinear_xMin));
	dynamic_switch.insert(std::make_pair("cim:PhaseTapChangerAsymmetrical.windingConnectionAngle", &assign_PhaseTapChangerAsymmetrical_windingConnectionAngle));
	dynamic_switch.insert(std::make_pair("cim:PhaseTapChangerLinear.stepPhaseShiftIncrement", &assign_PhaseTapChangerLinear_stepPhaseShiftIncrement));
	dynamic_switch.insert(std::make_pair("cim:PhaseTapChangerLinear.xMax", &assign_PhaseTapChangerLinear_xMax));
	dynamic_switch.insert(std::make_pair("cim:PhaseTapChangerLinear.xMin", &assign_PhaseTapChangerLinear_xMin));
	dynamic_switch.insert(std::make_pair("cim:TapChangerTablePoint.b", &assign_TapChangerTablePoint_b));
	dynamic_switch.insert(std::make_pair("cim:TapChangerTablePoint.g", &assign_TapChangerTablePoint_g));
	dynamic_switch.insert(std::make_pair("cim:TapChangerTablePoint.r", &assign_TapChangerTablePoint_r));
	dynamic_switch.insert(std::make_pair("cim:TapChangerTablePoint.ratio", &assign_TapChangerTablePoint_ratio));
	dynamic_switch.insert(std::make_pair("cim:TapChangerTablePoint.step", &assign_TapChangerTablePoint_step));
	dynamic_switch.insert(std::make_pair("cim:TapChangerTablePoint.x", &assign_TapChangerTablePoint_x));
	dynamic_switch.insert(std::make_pair("cim:PhaseTapChangerTablePoint.angle", &assign_PhaseTapChangerTablePoint_angle));
	dynamic_switch.insert(std::make_pair("cim:TransformerStarImpedance.r", &assign_TransformerStarImpedance_r));
	dynamic_switch.insert(std::make_pair("cim:TransformerStarImpedance.r0", &assign_TransformerStarImpedance_r0));
	dynamic_switch.insert(std::make_pair("cim:TransformerStarImpedance.x", &assign_TransformerStarImpedance_x));
	dynamic_switch.insert(std::make_pair("cim:TransformerStarImpedance.x0", &assign_TransformerStarImpedance_x0));
	dynamic_switch.insert(std::make_pair("cim:RatioTapChanger.stepVoltageIncrement", &assign_RatioTapChanger_stepVoltageIncrement));
	dynamic_switch.insert(std::make_pair("cim:RatioTapChanger.tculControlMode", &assign_RatioTapChanger_tculControlMode));
	dynamic_switch.insert(std::make_pair("cim:TransformerEnd.bmagSat", &assign_TransformerEnd_bmagSat));
	dynamic_switch.insert(std::make_pair("cim:TransformerEnd.endNumber", &assign_TransformerEnd_endNumber));
	dynamic_switch.insert(std::make_pair("cim:TransformerEnd.grounded", &assign_TransformerEnd_grounded));
	dynamic_switch.insert(std::make_pair("cim:TransformerEnd.magBaseU", &assign_TransformerEnd_magBaseU));
	dynamic_switch.insert(std::make_pair("cim:TransformerEnd.magSatFlux", &assign_TransformerEnd_magSatFlux));
	dynamic_switch.insert(std::make_pair("cim:TransformerEnd.rground", &assign_TransformerEnd_rground));
	dynamic_switch.insert(std::make_pair("cim:TransformerEnd.xground", &assign_TransformerEnd_xground));
	dynamic_switch.insert(std::make_pair("cim:PowerTransformerEnd.b", &assign_PowerTransformerEnd_b));
	dynamic_switch.insert(std::make_pair("cim:PowerTransformerEnd.b0", &assign_PowerTransformerEnd_b0));
	dynamic_switch.insert(std::make_pair("cim:PowerTransformerEnd.connectionKind", &assign_PowerTransformerEnd_connectionKind));
	dynamic_switch.insert(std::make_pair("cim:PowerTransformerEnd.g", &assign_PowerTransformerEnd_g));
	dynamic_switch.insert(std::make_pair("cim:PowerTransformerEnd.g0", &assign_PowerTransformerEnd_g0));
	dynamic_switch.insert(std::make_pair("cim:PowerTransformerEnd.phaseAngleClock", &assign_PowerTransformerEnd_phaseAngleClock));
	dynamic_switch.insert(std::make_pair("cim:PowerTransformerEnd.r", &assign_PowerTransformerEnd_r));
	dynamic_switch.insert(std::make_pair("cim:PowerTransformerEnd.r0", &assign_PowerTransformerEnd_r0));
	dynamic_switch.insert(std::make_pair("cim:PowerTransformerEnd.ratedS", &assign_PowerTransformerEnd_ratedS));
	dynamic_switch.insert(std::make_pair("cim:PowerTransformerEnd.ratedU", &assign_PowerTransformerEnd_ratedU));
	dynamic_switch.insert(std::make_pair("cim:PowerTransformerEnd.x", &assign_PowerTransformerEnd_x));
	dynamic_switch.insert(std::make_pair("cim:PowerTransformerEnd.x0", &assign_PowerTransformerEnd_x0));
	dynamic_switch.insert(std::make_pair("cim:PowerTransformer.beforeShCircuitHighestOperatingCurrent", &assign_PowerTransformer_beforeShCircuitHighestOperatingCurrent));
	dynamic_switch.insert(std::make_pair("cim:PowerTransformer.beforeShCircuitHighestOperatingVoltage", &assign_PowerTransformer_beforeShCircuitHighestOperatingVoltage));
	dynamic_switch.insert(std::make_pair("cim:PowerTransformer.beforeShortCircuitAnglePf", &assign_PowerTransformer_beforeShortCircuitAnglePf));
	dynamic_switch.insert(std::make_pair("cim:PowerTransformer.highSideMinOperatingU", &assign_PowerTransformer_highSideMinOperatingU));
	dynamic_switch.insert(std::make_pair("cim:PowerTransformer.isPartOfGeneratorUnit", &assign_PowerTransformer_isPartOfGeneratorUnit));
	dynamic_switch.insert(std::make_pair("cim:PowerTransformer.operationalValuesConsidered", &assign_PowerTransformer_operationalValuesConsidered));
	dynamic_switch.insert(std::make_pair("cim:PowerTransformer.vectorGroup", &assign_PowerTransformer_vectorGroup));
	dynamic_switch.insert(std::make_pair("cim:ReactiveCapabilityCurve.coolantTemperature", &assign_ReactiveCapabilityCurve_coolantTemperature));
	dynamic_switch.insert(std::make_pair("cim:ReactiveCapabilityCurve.hydrogenPressure", &assign_ReactiveCapabilityCurve_hydrogenPressure));
	dynamic_switch.insert(std::make_pair("cim:SeriesCompensator.r", &assign_SeriesCompensator_r));
	dynamic_switch.insert(std::make_pair("cim:SeriesCompensator.r0", &assign_SeriesCompensator_r0));
	dynamic_switch.insert(std::make_pair("cim:SeriesCompensator.varistorPresent", &assign_SeriesCompensator_varistorPresent));
	dynamic_switch.insert(std::make_pair("cim:SeriesCompensator.varistorRatedCurrent", &assign_SeriesCompensator_varistorRatedCurrent));
	dynamic_switch.insert(std::make_pair("cim:SeriesCompensator.varistorVoltageThreshold", &assign_SeriesCompensator_varistorVoltageThreshold));
	dynamic_switch.insert(std::make_pair("cim:SeriesCompensator.x", &assign_SeriesCompensator_x));
	dynamic_switch.insert(std::make_pair("cim:SeriesCompensator.x0", &assign_SeriesCompensator_x0));
	dynamic_switch.insert(std::make_pair("cim:StaticVarCompensator.capacitiveRating", &assign_StaticVarCompensator_capacitiveRating));
	dynamic_switch.insert(std::make_pair("cim:StaticVarCompensator.inductiveRating", &assign_StaticVarCompensator_inductiveRating));
	dynamic_switch.insert(std::make_pair("cim:StaticVarCompensator.q", &assign_StaticVarCompensator_q));
	dynamic_switch.insert(std::make_pair("cim:StaticVarCompensator.slope", &assign_StaticVarCompensator_slope));
	dynamic_switch.insert(std::make_pair("cim:StaticVarCompensator.sVCControlMode", &assign_StaticVarCompensator_sVCControlMode));
	dynamic_switch.insert(std::make_pair("cim:StaticVarCompensator.voltageSetPoint", &assign_StaticVarCompensator_voltageSetPoint));
	dynamic_switch.insert(std::make_pair("cim:TransformerCoreAdmittance.b", &assign_TransformerCoreAdmittance_b));
	dynamic_switch.insert(std::make_pair("cim:TransformerCoreAdmittance.b0", &assign_TransformerCoreAdmittance_b0));
	dynamic_switch.insert(std::make_pair("cim:TransformerCoreAdmittance.g", &assign_TransformerCoreAdmittance_g));
	dynamic_switch.insert(std::make_pair("cim:TransformerCoreAdmittance.g0", &assign_TransformerCoreAdmittance_g0));
	dynamic_switch.insert(std::make_pair("cim:TransformerMeshImpedance.r", &assign_TransformerMeshImpedance_r));
	dynamic_switch.insert(std::make_pair("cim:TransformerMeshImpedance.r0", &assign_TransformerMeshImpedance_r0));
	dynamic_switch.insert(std::make_pair("cim:TransformerMeshImpedance.x", &assign_TransformerMeshImpedance_x));
	dynamic_switch.insert(std::make_pair("cim:TransformerMeshImpedance.x0", &assign_TransformerMeshImpedance_x0));
	dynamic_switch.insert(std::make_pair("cim:TransformerTankEnd.phases", &assign_TransformerTankEnd_phases));
	dynamic_switch.insert(std::make_pair("cim:RemoteInputSignal.remoteSignalType", &assign_RemoteInputSignal_remoteSignalType));
	dynamic_switch.insert(std::make_pair("cim:DynamicsFunctionBlock.enabled", &assign_DynamicsFunctionBlock_enabled));
	dynamic_switch.insert(std::make_pair("cim:RotatingMachineDynamics.damping", &assign_RotatingMachineDynamics_damping));
	dynamic_switch.insert(std::make_pair("cim:RotatingMachineDynamics.inertia", &assign_RotatingMachineDynamics_inertia));
	dynamic_switch.insert(std::make_pair("cim:RotatingMachineDynamics.saturationFactor", &assign_RotatingMachineDynamics_saturationFactor));
	dynamic_switch.insert(std::make_pair("cim:RotatingMachineDynamics.saturationFactor120", &assign_RotatingMachineDynamics_saturationFactor120));
	dynamic_switch.insert(std::make_pair("cim:RotatingMachineDynamics.statorLeakageReactance", &assign_RotatingMachineDynamics_statorLeakageReactance));
	dynamic_switch.insert(std::make_pair("cim:RotatingMachineDynamics.statorResistance", &assign_RotatingMachineDynamics_statorResistance));
	dynamic_switch.insert(std::make_pair("cim:AsynchronousMachineEquivalentCircuit.rr1", &assign_AsynchronousMachineEquivalentCircuit_rr1));
	dynamic_switch.insert(std::make_pair("cim:AsynchronousMachineEquivalentCircuit.rr2", &assign_AsynchronousMachineEquivalentCircuit_rr2));
	dynamic_switch.insert(std::make_pair("cim:AsynchronousMachineEquivalentCircuit.xlr1", &assign_AsynchronousMachineEquivalentCircuit_xlr1));
	dynamic_switch.insert(std::make_pair("cim:AsynchronousMachineEquivalentCircuit.xlr2", &assign_AsynchronousMachineEquivalentCircuit_xlr2));
	dynamic_switch.insert(std::make_pair("cim:AsynchronousMachineEquivalentCircuit.xm", &assign_AsynchronousMachineEquivalentCircuit_xm));
	dynamic_switch.insert(std::make_pair("cim:AsynchronousMachineTimeConstantReactance.tpo", &assign_AsynchronousMachineTimeConstantReactance_tpo));
	dynamic_switch.insert(std::make_pair("cim:AsynchronousMachineTimeConstantReactance.tppo", &assign_AsynchronousMachineTimeConstantReactance_tppo));
	dynamic_switch.insert(std::make_pair("cim:AsynchronousMachineTimeConstantReactance.xp", &assign_AsynchronousMachineTimeConstantReactance_xp));
	dynamic_switch.insert(std::make_pair("cim:AsynchronousMachineTimeConstantReactance.xpp", &assign_AsynchronousMachineTimeConstantReactance_xpp));
	dynamic_switch.insert(std::make_pair("cim:AsynchronousMachineTimeConstantReactance.xs", &assign_AsynchronousMachineTimeConstantReactance_xs));
	dynamic_switch.insert(std::make_pair("cim:DiscExcContIEEEDEC1A.esc", &assign_DiscExcContIEEEDEC1A_esc));
	dynamic_switch.insert(std::make_pair("cim:DiscExcContIEEEDEC1A.kan", &assign_DiscExcContIEEEDEC1A_kan));
	dynamic_switch.insert(std::make_pair("cim:DiscExcContIEEEDEC1A.ketl", &assign_DiscExcContIEEEDEC1A_ketl));
	dynamic_switch.insert(std::make_pair("cim:DiscExcContIEEEDEC1A.tan", &assign_DiscExcContIEEEDEC1A_tan));
	dynamic_switch.insert(std::make_pair("cim:DiscExcContIEEEDEC1A.td", &assign_DiscExcContIEEEDEC1A_td));
	dynamic_switch.insert(std::make_pair("cim:DiscExcContIEEEDEC1A.tl1", &assign_DiscExcContIEEEDEC1A_tl1));
	dynamic_switch.insert(std::make_pair("cim:DiscExcContIEEEDEC1A.tl2", &assign_DiscExcContIEEEDEC1A_tl2));
	dynamic_switch.insert(std::make_pair("cim:DiscExcContIEEEDEC1A.tw5", &assign_DiscExcContIEEEDEC1A_tw5));
	dynamic_switch.insert(std::make_pair("cim:DiscExcContIEEEDEC1A.val", &assign_DiscExcContIEEEDEC1A_val));
	dynamic_switch.insert(std::make_pair("cim:DiscExcContIEEEDEC1A.vanmax", &assign_DiscExcContIEEEDEC1A_vanmax));
	dynamic_switch.insert(std::make_pair("cim:DiscExcContIEEEDEC1A.vomax", &assign_DiscExcContIEEEDEC1A_vomax));
	dynamic_switch.insert(std::make_pair("cim:DiscExcContIEEEDEC1A.vomin", &assign_DiscExcContIEEEDEC1A_vomin));
	dynamic_switch.insert(std::make_pair("cim:DiscExcContIEEEDEC1A.vsmax", &assign_DiscExcContIEEEDEC1A_vsmax));
	dynamic_switch.insert(std::make_pair("cim:DiscExcContIEEEDEC1A.vsmin", &assign_DiscExcContIEEEDEC1A_vsmin));
	dynamic_switch.insert(std::make_pair("cim:DiscExcContIEEEDEC1A.vtc", &assign_DiscExcContIEEEDEC1A_vtc));
	dynamic_switch.insert(std::make_pair("cim:DiscExcContIEEEDEC1A.vtlmt", &assign_DiscExcContIEEEDEC1A_vtlmt));
	dynamic_switch.insert(std::make_pair("cim:DiscExcContIEEEDEC1A.vtm", &assign_DiscExcContIEEEDEC1A_vtm));
	dynamic_switch.insert(std::make_pair("cim:DiscExcContIEEEDEC1A.vtn", &assign_DiscExcContIEEEDEC1A_vtn));
	dynamic_switch.insert(std::make_pair("cim:DiscExcContIEEEDEC2A.td1", &assign_DiscExcContIEEEDEC2A_td1));
	dynamic_switch.insert(std::make_pair("cim:DiscExcContIEEEDEC2A.td2", &assign_DiscExcContIEEEDEC2A_td2));
	dynamic_switch.insert(std::make_pair("cim:DiscExcContIEEEDEC2A.vdmax", &assign_DiscExcContIEEEDEC2A_vdmax));
	dynamic_switch.insert(std::make_pair("cim:DiscExcContIEEEDEC2A.vdmin", &assign_DiscExcContIEEEDEC2A_vdmin));
	dynamic_switch.insert(std::make_pair("cim:DiscExcContIEEEDEC2A.vk", &assign_DiscExcContIEEEDEC2A_vk));
	dynamic_switch.insert(std::make_pair("cim:DiscExcContIEEEDEC3A.tdr", &assign_DiscExcContIEEEDEC3A_tdr));
	dynamic_switch.insert(std::make_pair("cim:DiscExcContIEEEDEC3A.vtmin", &assign_DiscExcContIEEEDEC3A_vtmin));
	dynamic_switch.insert(std::make_pair("cim:ExcAC1A.hvlvgates", &assign_ExcAC1A_hvlvgates));
	dynamic_switch.insert(std::make_pair("cim:ExcAC1A.ka", &assign_ExcAC1A_ka));
	dynamic_switch.insert(std::make_pair("cim:ExcAC1A.kc", &assign_ExcAC1A_kc));
	dynamic_switch.insert(std::make_pair("cim:ExcAC1A.kd", &assign_ExcAC1A_kd));
	dynamic_switch.insert(std::make_pair("cim:ExcAC1A.ke", &assign_ExcAC1A_ke));
	dynamic_switch.insert(std::make_pair("cim:ExcAC1A.kf", &assign_ExcAC1A_kf));
	dynamic_switch.insert(std::make_pair("cim:ExcAC1A.kf1", &assign_ExcAC1A_kf1));
	dynamic_switch.insert(std::make_pair("cim:ExcAC1A.kf2", &assign_ExcAC1A_kf2));
	dynamic_switch.insert(std::make_pair("cim:ExcAC1A.ks", &assign_ExcAC1A_ks));
	dynamic_switch.insert(std::make_pair("cim:ExcAC1A.seve1", &assign_ExcAC1A_seve1));
	dynamic_switch.insert(std::make_pair("cim:ExcAC1A.seve2", &assign_ExcAC1A_seve2));
	dynamic_switch.insert(std::make_pair("cim:ExcAC1A.ta", &assign_ExcAC1A_ta));
	dynamic_switch.insert(std::make_pair("cim:ExcAC1A.tb", &assign_ExcAC1A_tb));
	dynamic_switch.insert(std::make_pair("cim:ExcAC1A.tc", &assign_ExcAC1A_tc));
	dynamic_switch.insert(std::make_pair("cim:ExcAC1A.te", &assign_ExcAC1A_te));
	dynamic_switch.insert(std::make_pair("cim:ExcAC1A.tf", &assign_ExcAC1A_tf));
	dynamic_switch.insert(std::make_pair("cim:ExcAC1A.vamax", &assign_ExcAC1A_vamax));
	dynamic_switch.insert(std::make_pair("cim:ExcAC1A.vamin", &assign_ExcAC1A_vamin));
	dynamic_switch.insert(std::make_pair("cim:ExcAC1A.ve1", &assign_ExcAC1A_ve1));
	dynamic_switch.insert(std::make_pair("cim:ExcAC1A.ve2", &assign_ExcAC1A_ve2));
	dynamic_switch.insert(std::make_pair("cim:ExcAC1A.vrmax", &assign_ExcAC1A_vrmax));
	dynamic_switch.insert(std::make_pair("cim:ExcAC1A.vrmin", &assign_ExcAC1A_vrmin));
	dynamic_switch.insert(std::make_pair("cim:ExcAC2A.hvgate", &assign_ExcAC2A_hvgate));
	dynamic_switch.insert(std::make_pair("cim:ExcAC2A.ka", &assign_ExcAC2A_ka));
	dynamic_switch.insert(std::make_pair("cim:ExcAC2A.kb", &assign_ExcAC2A_kb));
	dynamic_switch.insert(std::make_pair("cim:ExcAC2A.kb1", &assign_ExcAC2A_kb1));
	dynamic_switch.insert(std::make_pair("cim:ExcAC2A.kc", &assign_ExcAC2A_kc));
	dynamic_switch.insert(std::make_pair("cim:ExcAC2A.kd", &assign_ExcAC2A_kd));
	dynamic_switch.insert(std::make_pair("cim:ExcAC2A.ke", &assign_ExcAC2A_ke));
	dynamic_switch.insert(std::make_pair("cim:ExcAC2A.kf", &assign_ExcAC2A_kf));
	dynamic_switch.insert(std::make_pair("cim:ExcAC2A.kh", &assign_ExcAC2A_kh));
	dynamic_switch.insert(std::make_pair("cim:ExcAC2A.kl", &assign_ExcAC2A_kl));
	dynamic_switch.insert(std::make_pair("cim:ExcAC2A.kl1", &assign_ExcAC2A_kl1));
	dynamic_switch.insert(std::make_pair("cim:ExcAC2A.ks", &assign_ExcAC2A_ks));
	dynamic_switch.insert(std::make_pair("cim:ExcAC2A.lvgate", &assign_ExcAC2A_lvgate));
	dynamic_switch.insert(std::make_pair("cim:ExcAC2A.seve1", &assign_ExcAC2A_seve1));
	dynamic_switch.insert(std::make_pair("cim:ExcAC2A.seve2", &assign_ExcAC2A_seve2));
	dynamic_switch.insert(std::make_pair("cim:ExcAC2A.ta", &assign_ExcAC2A_ta));
	dynamic_switch.insert(std::make_pair("cim:ExcAC2A.tb", &assign_ExcAC2A_tb));
	dynamic_switch.insert(std::make_pair("cim:ExcAC2A.tc", &assign_ExcAC2A_tc));
	dynamic_switch.insert(std::make_pair("cim:ExcAC2A.te", &assign_ExcAC2A_te));
	dynamic_switch.insert(std::make_pair("cim:ExcAC2A.tf", &assign_ExcAC2A_tf));
	dynamic_switch.insert(std::make_pair("cim:ExcAC2A.vamax", &assign_ExcAC2A_vamax));
	dynamic_switch.insert(std::make_pair("cim:ExcAC2A.vamin", &assign_ExcAC2A_vamin));
	dynamic_switch.insert(std::make_pair("cim:ExcAC2A.ve1", &assign_ExcAC2A_ve1));
	dynamic_switch.insert(std::make_pair("cim:ExcAC2A.ve2", &assign_ExcAC2A_ve2));
	dynamic_switch.insert(std::make_pair("cim:ExcAC2A.vfemax", &assign_ExcAC2A_vfemax));
	dynamic_switch.insert(std::make_pair("cim:ExcAC2A.vlr", &assign_ExcAC2A_vlr));
	dynamic_switch.insert(std::make_pair("cim:ExcAC2A.vrmax", &assign_ExcAC2A_vrmax));
	dynamic_switch.insert(std::make_pair("cim:ExcAC2A.vrmin", &assign_ExcAC2A_vrmin));
	dynamic_switch.insert(std::make_pair("cim:ExcAC3A.efdn", &assign_ExcAC3A_efdn));
	dynamic_switch.insert(std::make_pair("cim:ExcAC3A.ka", &assign_ExcAC3A_ka));
	dynamic_switch.insert(std::make_pair("cim:ExcAC3A.kc", &assign_ExcAC3A_kc));
	dynamic_switch.insert(std::make_pair("cim:ExcAC3A.kd", &assign_ExcAC3A_kd));
	dynamic_switch.insert(std::make_pair("cim:ExcAC3A.ke", &assign_ExcAC3A_ke));
	dynamic_switch.insert(std::make_pair("cim:ExcAC3A.kf", &assign_ExcAC3A_kf));
	dynamic_switch.insert(std::make_pair("cim:ExcAC3A.kf1", &assign_ExcAC3A_kf1));
	dynamic_switch.insert(std::make_pair("cim:ExcAC3A.kf2", &assign_ExcAC3A_kf2));
	dynamic_switch.insert(std::make_pair("cim:ExcAC3A.klv", &assign_ExcAC3A_klv));
	dynamic_switch.insert(std::make_pair("cim:ExcAC3A.kn", &assign_ExcAC3A_kn));
	dynamic_switch.insert(std::make_pair("cim:ExcAC3A.kr", &assign_ExcAC3A_kr));
	dynamic_switch.insert(std::make_pair("cim:ExcAC3A.ks", &assign_ExcAC3A_ks));
	dynamic_switch.insert(std::make_pair("cim:ExcAC3A.seve1", &assign_ExcAC3A_seve1));
	dynamic_switch.insert(std::make_pair("cim:ExcAC3A.seve2", &assign_ExcAC3A_seve2));
	dynamic_switch.insert(std::make_pair("cim:ExcAC3A.ta", &assign_ExcAC3A_ta));
	dynamic_switch.insert(std::make_pair("cim:ExcAC3A.tb", &assign_ExcAC3A_tb));
	dynamic_switch.insert(std::make_pair("cim:ExcAC3A.tc", &assign_ExcAC3A_tc));
	dynamic_switch.insert(std::make_pair("cim:ExcAC3A.te", &assign_ExcAC3A_te));
	dynamic_switch.insert(std::make_pair("cim:ExcAC3A.tf", &assign_ExcAC3A_tf));
	dynamic_switch.insert(std::make_pair("cim:ExcAC3A.vamax", &assign_ExcAC3A_vamax));
	dynamic_switch.insert(std::make_pair("cim:ExcAC3A.vamin", &assign_ExcAC3A_vamin));
	dynamic_switch.insert(std::make_pair("cim:ExcAC3A.ve1", &assign_ExcAC3A_ve1));
	dynamic_switch.insert(std::make_pair("cim:ExcAC3A.ve2", &assign_ExcAC3A_ve2));
	dynamic_switch.insert(std::make_pair("cim:ExcAC3A.vemin", &assign_ExcAC3A_vemin));
	dynamic_switch.insert(std::make_pair("cim:ExcAC3A.vfemax", &assign_ExcAC3A_vfemax));
	dynamic_switch.insert(std::make_pair("cim:ExcAC3A.vlv", &assign_ExcAC3A_vlv));
	dynamic_switch.insert(std::make_pair("cim:ExcAC4A.ka", &assign_ExcAC4A_ka));
	dynamic_switch.insert(std::make_pair("cim:ExcAC4A.kc", &assign_ExcAC4A_kc));
	dynamic_switch.insert(std::make_pair("cim:ExcAC4A.ta", &assign_ExcAC4A_ta));
	dynamic_switch.insert(std::make_pair("cim:ExcAC4A.tb", &assign_ExcAC4A_tb));
	dynamic_switch.insert(std::make_pair("cim:ExcAC4A.tc", &assign_ExcAC4A_tc));
	dynamic_switch.insert(std::make_pair("cim:ExcAC4A.vimax", &assign_ExcAC4A_vimax));
	dynamic_switch.insert(std::make_pair("cim:ExcAC4A.vimin", &assign_ExcAC4A_vimin));
	dynamic_switch.insert(std::make_pair("cim:ExcAC4A.vrmax", &assign_ExcAC4A_vrmax));
	dynamic_switch.insert(std::make_pair("cim:ExcAC4A.vrmin", &assign_ExcAC4A_vrmin));
	dynamic_switch.insert(std::make_pair("cim:ExcAC5A.a", &assign_ExcAC5A_a));
	dynamic_switch.insert(std::make_pair("cim:ExcAC5A.efd1", &assign_ExcAC5A_efd1));
	dynamic_switch.insert(std::make_pair("cim:ExcAC5A.efd2", &assign_ExcAC5A_efd2));
	dynamic_switch.insert(std::make_pair("cim:ExcAC5A.ka", &assign_ExcAC5A_ka));
	dynamic_switch.insert(std::make_pair("cim:ExcAC5A.ke", &assign_ExcAC5A_ke));
	dynamic_switch.insert(std::make_pair("cim:ExcAC5A.kf", &assign_ExcAC5A_kf));
	dynamic_switch.insert(std::make_pair("cim:ExcAC5A.ks", &assign_ExcAC5A_ks));
	dynamic_switch.insert(std::make_pair("cim:ExcAC5A.seefd1", &assign_ExcAC5A_seefd1));
	dynamic_switch.insert(std::make_pair("cim:ExcAC5A.seefd2", &assign_ExcAC5A_seefd2));
	dynamic_switch.insert(std::make_pair("cim:ExcAC5A.ta", &assign_ExcAC5A_ta));
	dynamic_switch.insert(std::make_pair("cim:ExcAC5A.tb", &assign_ExcAC5A_tb));
	dynamic_switch.insert(std::make_pair("cim:ExcAC5A.tc", &assign_ExcAC5A_tc));
	dynamic_switch.insert(std::make_pair("cim:ExcAC5A.te", &assign_ExcAC5A_te));
	dynamic_switch.insert(std::make_pair("cim:ExcAC5A.tf1", &assign_ExcAC5A_tf1));
	dynamic_switch.insert(std::make_pair("cim:ExcAC5A.tf2", &assign_ExcAC5A_tf2));
	dynamic_switch.insert(std::make_pair("cim:ExcAC5A.tf3", &assign_ExcAC5A_tf3));
	dynamic_switch.insert(std::make_pair("cim:ExcAC5A.vrmax", &assign_ExcAC5A_vrmax));
	dynamic_switch.insert(std::make_pair("cim:ExcAC5A.vrmin", &assign_ExcAC5A_vrmin));
	dynamic_switch.insert(std::make_pair("cim:ExcAC6A.ka", &assign_ExcAC6A_ka));
	dynamic_switch.insert(std::make_pair("cim:ExcAC6A.kc", &assign_ExcAC6A_kc));
	dynamic_switch.insert(std::make_pair("cim:ExcAC6A.kd", &assign_ExcAC6A_kd));
	dynamic_switch.insert(std::make_pair("cim:ExcAC6A.ke", &assign_ExcAC6A_ke));
	dynamic_switch.insert(std::make_pair("cim:ExcAC6A.kh", &assign_ExcAC6A_kh));
	dynamic_switch.insert(std::make_pair("cim:ExcAC6A.ks", &assign_ExcAC6A_ks));
	dynamic_switch.insert(std::make_pair("cim:ExcAC6A.seve1", &assign_ExcAC6A_seve1));
	dynamic_switch.insert(std::make_pair("cim:ExcAC6A.seve2", &assign_ExcAC6A_seve2));
	dynamic_switch.insert(std::make_pair("cim:ExcAC6A.ta", &assign_ExcAC6A_ta));
	dynamic_switch.insert(std::make_pair("cim:ExcAC6A.tb", &assign_ExcAC6A_tb));
	dynamic_switch.insert(std::make_pair("cim:ExcAC6A.tc", &assign_ExcAC6A_tc));
	dynamic_switch.insert(std::make_pair("cim:ExcAC6A.te", &assign_ExcAC6A_te));
	dynamic_switch.insert(std::make_pair("cim:ExcAC6A.th", &assign_ExcAC6A_th));
	dynamic_switch.insert(std::make_pair("cim:ExcAC6A.tj", &assign_ExcAC6A_tj));
	dynamic_switch.insert(std::make_pair("cim:ExcAC6A.tk", &assign_ExcAC6A_tk));
	dynamic_switch.insert(std::make_pair("cim:ExcAC6A.vamax", &assign_ExcAC6A_vamax));
	dynamic_switch.insert(std::make_pair("cim:ExcAC6A.vamin", &assign_ExcAC6A_vamin));
	dynamic_switch.insert(std::make_pair("cim:ExcAC6A.ve1", &assign_ExcAC6A_ve1));
	dynamic_switch.insert(std::make_pair("cim:ExcAC6A.ve2", &assign_ExcAC6A_ve2));
	dynamic_switch.insert(std::make_pair("cim:ExcAC6A.vfelim", &assign_ExcAC6A_vfelim));
	dynamic_switch.insert(std::make_pair("cim:ExcAC6A.vhmax", &assign_ExcAC6A_vhmax));
	dynamic_switch.insert(std::make_pair("cim:ExcAC6A.vrmax", &assign_ExcAC6A_vrmax));
	dynamic_switch.insert(std::make_pair("cim:ExcAC6A.vrmin", &assign_ExcAC6A_vrmin));
	dynamic_switch.insert(std::make_pair("cim:ExcAC8B.inlim", &assign_ExcAC8B_inlim));
	dynamic_switch.insert(std::make_pair("cim:ExcAC8B.ka", &assign_ExcAC8B_ka));
	dynamic_switch.insert(std::make_pair("cim:ExcAC8B.kc", &assign_ExcAC8B_kc));
	dynamic_switch.insert(std::make_pair("cim:ExcAC8B.kd", &assign_ExcAC8B_kd));
	dynamic_switch.insert(std::make_pair("cim:ExcAC8B.kdr", &assign_ExcAC8B_kdr));
	dynamic_switch.insert(std::make_pair("cim:ExcAC8B.ke", &assign_ExcAC8B_ke));
	dynamic_switch.insert(std::make_pair("cim:ExcAC8B.kir", &assign_ExcAC8B_kir));
	dynamic_switch.insert(std::make_pair("cim:ExcAC8B.kpr", &assign_ExcAC8B_kpr));
	dynamic_switch.insert(std::make_pair("cim:ExcAC8B.ks", &assign_ExcAC8B_ks));
	dynamic_switch.insert(std::make_pair("cim:ExcAC8B.pidlim", &assign_ExcAC8B_pidlim));
	dynamic_switch.insert(std::make_pair("cim:ExcAC8B.seve1", &assign_ExcAC8B_seve1));
	dynamic_switch.insert(std::make_pair("cim:ExcAC8B.seve2", &assign_ExcAC8B_seve2));
	dynamic_switch.insert(std::make_pair("cim:ExcAC8B.ta", &assign_ExcAC8B_ta));
	dynamic_switch.insert(std::make_pair("cim:ExcAC8B.tdr", &assign_ExcAC8B_tdr));
	dynamic_switch.insert(std::make_pair("cim:ExcAC8B.te", &assign_ExcAC8B_te));
	dynamic_switch.insert(std::make_pair("cim:ExcAC8B.telim", &assign_ExcAC8B_telim));
	dynamic_switch.insert(std::make_pair("cim:ExcAC8B.ve1", &assign_ExcAC8B_ve1));
	dynamic_switch.insert(std::make_pair("cim:ExcAC8B.ve2", &assign_ExcAC8B_ve2));
	dynamic_switch.insert(std::make_pair("cim:ExcAC8B.vemin", &assign_ExcAC8B_vemin));
	dynamic_switch.insert(std::make_pair("cim:ExcAC8B.vfemax", &assign_ExcAC8B_vfemax));
	dynamic_switch.insert(std::make_pair("cim:ExcAC8B.vimax", &assign_ExcAC8B_vimax));
	dynamic_switch.insert(std::make_pair("cim:ExcAC8B.vimin", &assign_ExcAC8B_vimin));
	dynamic_switch.insert(std::make_pair("cim:ExcAC8B.vpidmax", &assign_ExcAC8B_vpidmax));
	dynamic_switch.insert(std::make_pair("cim:ExcAC8B.vpidmin", &assign_ExcAC8B_vpidmin));
	dynamic_switch.insert(std::make_pair("cim:ExcAC8B.vrmax", &assign_ExcAC8B_vrmax));
	dynamic_switch.insert(std::make_pair("cim:ExcAC8B.vrmin", &assign_ExcAC8B_vrmin));
	dynamic_switch.insert(std::make_pair("cim:ExcAC8B.vtmult", &assign_ExcAC8B_vtmult));
	dynamic_switch.insert(std::make_pair("cim:ExcANS.blint", &assign_ExcANS_blint));
	dynamic_switch.insert(std::make_pair("cim:ExcANS.ifmn", &assign_ExcANS_ifmn));
	dynamic_switch.insert(std::make_pair("cim:ExcANS.ifmx", &assign_ExcANS_ifmx));
	dynamic_switch.insert(std::make_pair("cim:ExcANS.k2", &assign_ExcANS_k2));
	dynamic_switch.insert(std::make_pair("cim:ExcANS.k3", &assign_ExcANS_k3));
	dynamic_switch.insert(std::make_pair("cim:ExcANS.kce", &assign_ExcANS_kce));
	dynamic_switch.insert(std::make_pair("cim:ExcANS.krvecc", &assign_ExcANS_krvecc));
	dynamic_switch.insert(std::make_pair("cim:ExcANS.kvfif", &assign_ExcANS_kvfif));
	dynamic_switch.insert(std::make_pair("cim:ExcANS.t1", &assign_ExcANS_t1));
	dynamic_switch.insert(std::make_pair("cim:ExcANS.t2", &assign_ExcANS_t2));
	dynamic_switch.insert(std::make_pair("cim:ExcANS.t3", &assign_ExcANS_t3));
	dynamic_switch.insert(std::make_pair("cim:ExcANS.tb", &assign_ExcANS_tb));
	dynamic_switch.insert(std::make_pair("cim:ExcANS.vrmn", &assign_ExcANS_vrmn));
	dynamic_switch.insert(std::make_pair("cim:ExcANS.vrmx", &assign_ExcANS_vrmx));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR1.e1", &assign_ExcAVR1_e1));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR1.e2", &assign_ExcAVR1_e2));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR1.ka", &assign_ExcAVR1_ka));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR1.kf", &assign_ExcAVR1_kf));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR1.se1", &assign_ExcAVR1_se1));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR1.se2", &assign_ExcAVR1_se2));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR1.ta", &assign_ExcAVR1_ta));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR1.tb", &assign_ExcAVR1_tb));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR1.te", &assign_ExcAVR1_te));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR1.tf", &assign_ExcAVR1_tf));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR1.vrmn", &assign_ExcAVR1_vrmn));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR1.vrmx", &assign_ExcAVR1_vrmx));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR2.e1", &assign_ExcAVR2_e1));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR2.e2", &assign_ExcAVR2_e2));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR2.ka", &assign_ExcAVR2_ka));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR2.kf", &assign_ExcAVR2_kf));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR2.se1", &assign_ExcAVR2_se1));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR2.se2", &assign_ExcAVR2_se2));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR2.ta", &assign_ExcAVR2_ta));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR2.tb", &assign_ExcAVR2_tb));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR2.te", &assign_ExcAVR2_te));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR2.tf1", &assign_ExcAVR2_tf1));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR2.tf2", &assign_ExcAVR2_tf2));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR2.vrmn", &assign_ExcAVR2_vrmn));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR2.vrmx", &assign_ExcAVR2_vrmx));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR3.e1", &assign_ExcAVR3_e1));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR3.e2", &assign_ExcAVR3_e2));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR3.ka", &assign_ExcAVR3_ka));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR3.se1", &assign_ExcAVR3_se1));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR3.se2", &assign_ExcAVR3_se2));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR3.t1", &assign_ExcAVR3_t1));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR3.t2", &assign_ExcAVR3_t2));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR3.t3", &assign_ExcAVR3_t3));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR3.t4", &assign_ExcAVR3_t4));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR3.te", &assign_ExcAVR3_te));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR3.vrmn", &assign_ExcAVR3_vrmn));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR3.vrmx", &assign_ExcAVR3_vrmx));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR4.imul", &assign_ExcAVR4_imul));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR4.ka", &assign_ExcAVR4_ka));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR4.ke", &assign_ExcAVR4_ke));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR4.kif", &assign_ExcAVR4_kif));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR4.t1", &assign_ExcAVR4_t1));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR4.t1if", &assign_ExcAVR4_t1if));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR4.t2", &assign_ExcAVR4_t2));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR4.t3", &assign_ExcAVR4_t3));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR4.t4", &assign_ExcAVR4_t4));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR4.tif", &assign_ExcAVR4_tif));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR4.vfmn", &assign_ExcAVR4_vfmn));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR4.vfmx", &assign_ExcAVR4_vfmx));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR4.vrmn", &assign_ExcAVR4_vrmn));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR4.vrmx", &assign_ExcAVR4_vrmx));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR5.ka", &assign_ExcAVR5_ka));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR5.rex", &assign_ExcAVR5_rex));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR5.ta", &assign_ExcAVR5_ta));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR7.a1", &assign_ExcAVR7_a1));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR7.a2", &assign_ExcAVR7_a2));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR7.a3", &assign_ExcAVR7_a3));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR7.a4", &assign_ExcAVR7_a4));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR7.a5", &assign_ExcAVR7_a5));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR7.a6", &assign_ExcAVR7_a6));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR7.k1", &assign_ExcAVR7_k1));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR7.k3", &assign_ExcAVR7_k3));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR7.k5", &assign_ExcAVR7_k5));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR7.t1", &assign_ExcAVR7_t1));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR7.t2", &assign_ExcAVR7_t2));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR7.t3", &assign_ExcAVR7_t3));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR7.t4", &assign_ExcAVR7_t4));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR7.t5", &assign_ExcAVR7_t5));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR7.t6", &assign_ExcAVR7_t6));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR7.vmax1", &assign_ExcAVR7_vmax1));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR7.vmax3", &assign_ExcAVR7_vmax3));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR7.vmax5", &assign_ExcAVR7_vmax5));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR7.vmin1", &assign_ExcAVR7_vmin1));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR7.vmin3", &assign_ExcAVR7_vmin3));
	dynamic_switch.insert(std::make_pair("cim:ExcAVR7.vmin5", &assign_ExcAVR7_vmin5));
	dynamic_switch.insert(std::make_pair("cim:ExcBBC.efdmax", &assign_ExcBBC_efdmax));
	dynamic_switch.insert(std::make_pair("cim:ExcBBC.efdmin", &assign_ExcBBC_efdmin));
	dynamic_switch.insert(std::make_pair("cim:ExcBBC.k", &assign_ExcBBC_k));
	dynamic_switch.insert(std::make_pair("cim:ExcBBC.routing_selector", &assign_ExcBBC_routing_selector));
	dynamic_switch.insert(std::make_pair("cim:ExcBBC.t1", &assign_ExcBBC_t1));
	dynamic_switch.insert(std::make_pair("cim:ExcBBC.t2", &assign_ExcBBC_t2));
	dynamic_switch.insert(std::make_pair("cim:ExcBBC.t3", &assign_ExcBBC_t3));
	dynamic_switch.insert(std::make_pair("cim:ExcBBC.t4", &assign_ExcBBC_t4));
	dynamic_switch.insert(std::make_pair("cim:ExcBBC.vrmax", &assign_ExcBBC_vrmax));
	dynamic_switch.insert(std::make_pair("cim:ExcBBC.vrmin", &assign_ExcBBC_vrmin));
	dynamic_switch.insert(std::make_pair("cim:ExcBBC.xe", &assign_ExcBBC_xe));
	dynamic_switch.insert(std::make_pair("cim:ExcCZ.efdmax", &assign_ExcCZ_efdmax));
	dynamic_switch.insert(std::make_pair("cim:ExcCZ.efdmin", &assign_ExcCZ_efdmin));
	dynamic_switch.insert(std::make_pair("cim:ExcCZ.ka", &assign_ExcCZ_ka));
	dynamic_switch.insert(std::make_pair("cim:ExcCZ.ke", &assign_ExcCZ_ke));
	dynamic_switch.insert(std::make_pair("cim:ExcCZ.kp", &assign_ExcCZ_kp));
	dynamic_switch.insert(std::make_pair("cim:ExcCZ.ta", &assign_ExcCZ_ta));
	dynamic_switch.insert(std::make_pair("cim:ExcCZ.tc", &assign_ExcCZ_tc));
	dynamic_switch.insert(std::make_pair("cim:ExcCZ.te", &assign_ExcCZ_te));
	dynamic_switch.insert(std::make_pair("cim:ExcCZ.vrmax", &assign_ExcCZ_vrmax));
	dynamic_switch.insert(std::make_pair("cim:ExcCZ.vrmin", &assign_ExcCZ_vrmin));
	dynamic_switch.insert(std::make_pair("cim:ExcDC1A.edfmax", &assign_ExcDC1A_edfmax));
	dynamic_switch.insert(std::make_pair("cim:ExcDC1A.efd1", &assign_ExcDC1A_efd1));
	dynamic_switch.insert(std::make_pair("cim:ExcDC1A.efd2", &assign_ExcDC1A_efd2));
	dynamic_switch.insert(std::make_pair("cim:ExcDC1A.efdmin", &assign_ExcDC1A_efdmin));
	dynamic_switch.insert(std::make_pair("cim:ExcDC1A.exclim", &assign_ExcDC1A_exclim));
	dynamic_switch.insert(std::make_pair("cim:ExcDC1A.ka", &assign_ExcDC1A_ka));
	dynamic_switch.insert(std::make_pair("cim:ExcDC1A.ke", &assign_ExcDC1A_ke));
	dynamic_switch.insert(std::make_pair("cim:ExcDC1A.kf", &assign_ExcDC1A_kf));
	dynamic_switch.insert(std::make_pair("cim:ExcDC1A.ks", &assign_ExcDC1A_ks));
	dynamic_switch.insert(std::make_pair("cim:ExcDC1A.seefd1", &assign_ExcDC1A_seefd1));
	dynamic_switch.insert(std::make_pair("cim:ExcDC1A.seefd2", &assign_ExcDC1A_seefd2));
	dynamic_switch.insert(std::make_pair("cim:ExcDC1A.ta", &assign_ExcDC1A_ta));
	dynamic_switch.insert(std::make_pair("cim:ExcDC1A.tb", &assign_ExcDC1A_tb));
	dynamic_switch.insert(std::make_pair("cim:ExcDC1A.tc", &assign_ExcDC1A_tc));
	dynamic_switch.insert(std::make_pair("cim:ExcDC1A.te", &assign_ExcDC1A_te));
	dynamic_switch.insert(std::make_pair("cim:ExcDC1A.tf", &assign_ExcDC1A_tf));
	dynamic_switch.insert(std::make_pair("cim:ExcDC1A.vrmax", &assign_ExcDC1A_vrmax));
	dynamic_switch.insert(std::make_pair("cim:ExcDC1A.vrmin", &assign_ExcDC1A_vrmin));
	dynamic_switch.insert(std::make_pair("cim:ExcDC2A.efd1", &assign_ExcDC2A_efd1));
	dynamic_switch.insert(std::make_pair("cim:ExcDC2A.efd2", &assign_ExcDC2A_efd2));
	dynamic_switch.insert(std::make_pair("cim:ExcDC2A.exclim", &assign_ExcDC2A_exclim));
	dynamic_switch.insert(std::make_pair("cim:ExcDC2A.ka", &assign_ExcDC2A_ka));
	dynamic_switch.insert(std::make_pair("cim:ExcDC2A.ke", &assign_ExcDC2A_ke));
	dynamic_switch.insert(std::make_pair("cim:ExcDC2A.kf", &assign_ExcDC2A_kf));
	dynamic_switch.insert(std::make_pair("cim:ExcDC2A.ks", &assign_ExcDC2A_ks));
	dynamic_switch.insert(std::make_pair("cim:ExcDC2A.seefd1", &assign_ExcDC2A_seefd1));
	dynamic_switch.insert(std::make_pair("cim:ExcDC2A.seefd2", &assign_ExcDC2A_seefd2));
	dynamic_switch.insert(std::make_pair("cim:ExcDC2A.ta", &assign_ExcDC2A_ta));
	dynamic_switch.insert(std::make_pair("cim:ExcDC2A.tb", &assign_ExcDC2A_tb));
	dynamic_switch.insert(std::make_pair("cim:ExcDC2A.tc", &assign_ExcDC2A_tc));
	dynamic_switch.insert(std::make_pair("cim:ExcDC2A.te", &assign_ExcDC2A_te));
	dynamic_switch.insert(std::make_pair("cim:ExcDC2A.tf", &assign_ExcDC2A_tf));
	dynamic_switch.insert(std::make_pair("cim:ExcDC2A.tf1", &assign_ExcDC2A_tf1));
	dynamic_switch.insert(std::make_pair("cim:ExcDC2A.vrmax", &assign_ExcDC2A_vrmax));
	dynamic_switch.insert(std::make_pair("cim:ExcDC2A.vrmin", &assign_ExcDC2A_vrmin));
	dynamic_switch.insert(std::make_pair("cim:ExcDC2A.vtlim", &assign_ExcDC2A_vtlim));
	dynamic_switch.insert(std::make_pair("cim:ExcDC3A.edfmax", &assign_ExcDC3A_edfmax));
	dynamic_switch.insert(std::make_pair("cim:ExcDC3A.efd1", &assign_ExcDC3A_efd1));
	dynamic_switch.insert(std::make_pair("cim:ExcDC3A.efd2", &assign_ExcDC3A_efd2));
	dynamic_switch.insert(std::make_pair("cim:ExcDC3A.efdlim", &assign_ExcDC3A_efdlim));
	dynamic_switch.insert(std::make_pair("cim:ExcDC3A.efdmin", &assign_ExcDC3A_efdmin));
	dynamic_switch.insert(std::make_pair("cim:ExcDC3A.exclim", &assign_ExcDC3A_exclim));
	dynamic_switch.insert(std::make_pair("cim:ExcDC3A.ke", &assign_ExcDC3A_ke));
	dynamic_switch.insert(std::make_pair("cim:ExcDC3A.kr", &assign_ExcDC3A_kr));
	dynamic_switch.insert(std::make_pair("cim:ExcDC3A.ks", &assign_ExcDC3A_ks));
	dynamic_switch.insert(std::make_pair("cim:ExcDC3A.kv", &assign_ExcDC3A_kv));
	dynamic_switch.insert(std::make_pair("cim:ExcDC3A.seefd1", &assign_ExcDC3A_seefd1));
	dynamic_switch.insert(std::make_pair("cim:ExcDC3A.seefd2", &assign_ExcDC3A_seefd2));
	dynamic_switch.insert(std::make_pair("cim:ExcDC3A.te", &assign_ExcDC3A_te));
	dynamic_switch.insert(std::make_pair("cim:ExcDC3A.trh", &assign_ExcDC3A_trh));
	dynamic_switch.insert(std::make_pair("cim:ExcDC3A.vrmax", &assign_ExcDC3A_vrmax));
	dynamic_switch.insert(std::make_pair("cim:ExcDC3A.vrmin", &assign_ExcDC3A_vrmin));
	dynamic_switch.insert(std::make_pair("cim:ExcDC3A1.exclim", &assign_ExcDC3A1_exclim));
	dynamic_switch.insert(std::make_pair("cim:ExcDC3A1.ka", &assign_ExcDC3A1_ka));
	dynamic_switch.insert(std::make_pair("cim:ExcDC3A1.ke", &assign_ExcDC3A1_ke));
	dynamic_switch.insert(std::make_pair("cim:ExcDC3A1.kf", &assign_ExcDC3A1_kf));
	dynamic_switch.insert(std::make_pair("cim:ExcDC3A1.ki", &assign_ExcDC3A1_ki));
	dynamic_switch.insert(std::make_pair("cim:ExcDC3A1.kp", &assign_ExcDC3A1_kp));
	dynamic_switch.insert(std::make_pair("cim:ExcDC3A1.ta", &assign_ExcDC3A1_ta));
	dynamic_switch.insert(std::make_pair("cim:ExcDC3A1.te", &assign_ExcDC3A1_te));
	dynamic_switch.insert(std::make_pair("cim:ExcDC3A1.tf", &assign_ExcDC3A1_tf));
	dynamic_switch.insert(std::make_pair("cim:ExcDC3A1.vb1max", &assign_ExcDC3A1_vb1max));
	dynamic_switch.insert(std::make_pair("cim:ExcDC3A1.vblim", &assign_ExcDC3A1_vblim));
	dynamic_switch.insert(std::make_pair("cim:ExcDC3A1.vbmax", &assign_ExcDC3A1_vbmax));
	dynamic_switch.insert(std::make_pair("cim:ExcDC3A1.vrmax", &assign_ExcDC3A1_vrmax));
	dynamic_switch.insert(std::make_pair("cim:ExcDC3A1.vrmin", &assign_ExcDC3A1_vrmin));
	dynamic_switch.insert(std::make_pair("cim:ExcELIN1.dpnf", &assign_ExcELIN1_dpnf));
	dynamic_switch.insert(std::make_pair("cim:ExcELIN1.efmax", &assign_ExcELIN1_efmax));
	dynamic_switch.insert(std::make_pair("cim:ExcELIN1.efmin", &assign_ExcELIN1_efmin));
	dynamic_switch.insert(std::make_pair("cim:ExcELIN1.ks1", &assign_ExcELIN1_ks1));
	dynamic_switch.insert(std::make_pair("cim:ExcELIN1.ks2", &assign_ExcELIN1_ks2));
	dynamic_switch.insert(std::make_pair("cim:ExcELIN1.smax", &assign_ExcELIN1_smax));
	dynamic_switch.insert(std::make_pair("cim:ExcELIN1.tfi", &assign_ExcELIN1_tfi));
	dynamic_switch.insert(std::make_pair("cim:ExcELIN1.tnu", &assign_ExcELIN1_tnu));
	dynamic_switch.insert(std::make_pair("cim:ExcELIN1.ts1", &assign_ExcELIN1_ts1));
	dynamic_switch.insert(std::make_pair("cim:ExcELIN1.ts2", &assign_ExcELIN1_ts2));
	dynamic_switch.insert(std::make_pair("cim:ExcELIN1.tsw", &assign_ExcELIN1_tsw));
	dynamic_switch.insert(std::make_pair("cim:ExcELIN1.vpi", &assign_ExcELIN1_vpi));
	dynamic_switch.insert(std::make_pair("cim:ExcELIN1.vpnf", &assign_ExcELIN1_vpnf));
	dynamic_switch.insert(std::make_pair("cim:ExcELIN1.vpu", &assign_ExcELIN1_vpu));
	dynamic_switch.insert(std::make_pair("cim:ExcELIN1.xe", &assign_ExcELIN1_xe));
	dynamic_switch.insert(std::make_pair("cim:ExcELIN2.efdbas", &assign_ExcELIN2_efdbas));
	dynamic_switch.insert(std::make_pair("cim:ExcELIN2.iefmax", &assign_ExcELIN2_iefmax));
	dynamic_switch.insert(std::make_pair("cim:ExcELIN2.iefmax2", &assign_ExcELIN2_iefmax2));
	dynamic_switch.insert(std::make_pair("cim:ExcELIN2.iefmin", &assign_ExcELIN2_iefmin));
	dynamic_switch.insert(std::make_pair("cim:ExcELIN2.k1", &assign_ExcELIN2_k1));
	dynamic_switch.insert(std::make_pair("cim:ExcELIN2.k1ec", &assign_ExcELIN2_k1ec));
	dynamic_switch.insert(std::make_pair("cim:ExcELIN2.k2", &assign_ExcELIN2_k2));
	dynamic_switch.insert(std::make_pair("cim:ExcELIN2.k3", &assign_ExcELIN2_k3));
	dynamic_switch.insert(std::make_pair("cim:ExcELIN2.k4", &assign_ExcELIN2_k4));
	dynamic_switch.insert(std::make_pair("cim:ExcELIN2.kd1", &assign_ExcELIN2_kd1));
	dynamic_switch.insert(std::make_pair("cim:ExcELIN2.ke2", &assign_ExcELIN2_ke2));
	dynamic_switch.insert(std::make_pair("cim:ExcELIN2.ketb", &assign_ExcELIN2_ketb));
	dynamic_switch.insert(std::make_pair("cim:ExcELIN2.pid1max", &assign_ExcELIN2_pid1max));
	dynamic_switch.insert(std::make_pair("cim:ExcELIN2.seve1", &assign_ExcELIN2_seve1));
	dynamic_switch.insert(std::make_pair("cim:ExcELIN2.seve2", &assign_ExcELIN2_seve2));
	dynamic_switch.insert(std::make_pair("cim:ExcELIN2.tb1", &assign_ExcELIN2_tb1));
	dynamic_switch.insert(std::make_pair("cim:ExcELIN2.te", &assign_ExcELIN2_te));
	dynamic_switch.insert(std::make_pair("cim:ExcELIN2.te2", &assign_ExcELIN2_te2));
	dynamic_switch.insert(std::make_pair("cim:ExcELIN2.ti1", &assign_ExcELIN2_ti1));
	dynamic_switch.insert(std::make_pair("cim:ExcELIN2.ti3", &assign_ExcELIN2_ti3));
	dynamic_switch.insert(std::make_pair("cim:ExcELIN2.ti4", &assign_ExcELIN2_ti4));
	dynamic_switch.insert(std::make_pair("cim:ExcELIN2.tr4", &assign_ExcELIN2_tr4));
	dynamic_switch.insert(std::make_pair("cim:ExcELIN2.upmax", &assign_ExcELIN2_upmax));
	dynamic_switch.insert(std::make_pair("cim:ExcELIN2.upmin", &assign_ExcELIN2_upmin));
	dynamic_switch.insert(std::make_pair("cim:ExcELIN2.ve1", &assign_ExcELIN2_ve1));
	dynamic_switch.insert(std::make_pair("cim:ExcELIN2.ve2", &assign_ExcELIN2_ve2));
	dynamic_switch.insert(std::make_pair("cim:ExcELIN2.xp", &assign_ExcELIN2_xp));
	dynamic_switch.insert(std::make_pair("cim:ExcHU.ae", &assign_ExcHU_ae));
	dynamic_switch.insert(std::make_pair("cim:ExcHU.ai", &assign_ExcHU_ai));
	dynamic_switch.insert(std::make_pair("cim:ExcHU.atr", &assign_ExcHU_atr));
	dynamic_switch.insert(std::make_pair("cim:ExcHU.emax", &assign_ExcHU_emax));
	dynamic_switch.insert(std::make_pair("cim:ExcHU.emin", &assign_ExcHU_emin));
	dynamic_switch.insert(std::make_pair("cim:ExcHU.imax", &assign_ExcHU_imax));
	dynamic_switch.insert(std::make_pair("cim:ExcHU.imin", &assign_ExcHU_imin));
	dynamic_switch.insert(std::make_pair("cim:ExcHU.ke", &assign_ExcHU_ke));
	dynamic_switch.insert(std::make_pair("cim:ExcHU.ki", &assign_ExcHU_ki));
	dynamic_switch.insert(std::make_pair("cim:ExcHU.te", &assign_ExcHU_te));
	dynamic_switch.insert(std::make_pair("cim:ExcHU.ti", &assign_ExcHU_ti));
	dynamic_switch.insert(std::make_pair("cim:ExcHU.tr", &assign_ExcHU_tr));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC1A.ka", &assign_ExcIEEEAC1A_ka));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC1A.kc", &assign_ExcIEEEAC1A_kc));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC1A.kd", &assign_ExcIEEEAC1A_kd));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC1A.ke", &assign_ExcIEEEAC1A_ke));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC1A.kf", &assign_ExcIEEEAC1A_kf));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC1A.seve1", &assign_ExcIEEEAC1A_seve1));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC1A.seve2", &assign_ExcIEEEAC1A_seve2));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC1A.ta", &assign_ExcIEEEAC1A_ta));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC1A.tb", &assign_ExcIEEEAC1A_tb));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC1A.tc", &assign_ExcIEEEAC1A_tc));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC1A.te", &assign_ExcIEEEAC1A_te));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC1A.tf", &assign_ExcIEEEAC1A_tf));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC1A.vamax", &assign_ExcIEEEAC1A_vamax));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC1A.vamin", &assign_ExcIEEEAC1A_vamin));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC1A.ve1", &assign_ExcIEEEAC1A_ve1));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC1A.ve2", &assign_ExcIEEEAC1A_ve2));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC1A.vrmax", &assign_ExcIEEEAC1A_vrmax));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC1A.vrmin", &assign_ExcIEEEAC1A_vrmin));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC2A.ka", &assign_ExcIEEEAC2A_ka));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC2A.kb", &assign_ExcIEEEAC2A_kb));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC2A.kc", &assign_ExcIEEEAC2A_kc));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC2A.kd", &assign_ExcIEEEAC2A_kd));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC2A.ke", &assign_ExcIEEEAC2A_ke));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC2A.kf", &assign_ExcIEEEAC2A_kf));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC2A.kh", &assign_ExcIEEEAC2A_kh));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC2A.seve1", &assign_ExcIEEEAC2A_seve1));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC2A.seve2", &assign_ExcIEEEAC2A_seve2));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC2A.ta", &assign_ExcIEEEAC2A_ta));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC2A.tb", &assign_ExcIEEEAC2A_tb));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC2A.tc", &assign_ExcIEEEAC2A_tc));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC2A.te", &assign_ExcIEEEAC2A_te));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC2A.tf", &assign_ExcIEEEAC2A_tf));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC2A.vamax", &assign_ExcIEEEAC2A_vamax));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC2A.vamin", &assign_ExcIEEEAC2A_vamin));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC2A.ve1", &assign_ExcIEEEAC2A_ve1));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC2A.ve2", &assign_ExcIEEEAC2A_ve2));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC2A.vfemax", &assign_ExcIEEEAC2A_vfemax));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC2A.vrmax", &assign_ExcIEEEAC2A_vrmax));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC2A.vrmin", &assign_ExcIEEEAC2A_vrmin));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC3A.efdn", &assign_ExcIEEEAC3A_efdn));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC3A.ka", &assign_ExcIEEEAC3A_ka));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC3A.kc", &assign_ExcIEEEAC3A_kc));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC3A.kd", &assign_ExcIEEEAC3A_kd));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC3A.ke", &assign_ExcIEEEAC3A_ke));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC3A.kf", &assign_ExcIEEEAC3A_kf));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC3A.kn", &assign_ExcIEEEAC3A_kn));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC3A.kr", &assign_ExcIEEEAC3A_kr));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC3A.seve1", &assign_ExcIEEEAC3A_seve1));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC3A.seve2", &assign_ExcIEEEAC3A_seve2));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC3A.ta", &assign_ExcIEEEAC3A_ta));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC3A.tb", &assign_ExcIEEEAC3A_tb));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC3A.tc", &assign_ExcIEEEAC3A_tc));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC3A.te", &assign_ExcIEEEAC3A_te));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC3A.tf", &assign_ExcIEEEAC3A_tf));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC3A.vamax", &assign_ExcIEEEAC3A_vamax));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC3A.vamin", &assign_ExcIEEEAC3A_vamin));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC3A.ve1", &assign_ExcIEEEAC3A_ve1));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC3A.ve2", &assign_ExcIEEEAC3A_ve2));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC3A.vemin", &assign_ExcIEEEAC3A_vemin));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC3A.vfemax", &assign_ExcIEEEAC3A_vfemax));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC4A.ka", &assign_ExcIEEEAC4A_ka));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC4A.kc", &assign_ExcIEEEAC4A_kc));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC4A.ta", &assign_ExcIEEEAC4A_ta));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC4A.tb", &assign_ExcIEEEAC4A_tb));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC4A.tc", &assign_ExcIEEEAC4A_tc));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC4A.vimax", &assign_ExcIEEEAC4A_vimax));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC4A.vimin", &assign_ExcIEEEAC4A_vimin));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC4A.vrmax", &assign_ExcIEEEAC4A_vrmax));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC4A.vrmin", &assign_ExcIEEEAC4A_vrmin));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC5A.efd1", &assign_ExcIEEEAC5A_efd1));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC5A.efd2", &assign_ExcIEEEAC5A_efd2));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC5A.ka", &assign_ExcIEEEAC5A_ka));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC5A.ke", &assign_ExcIEEEAC5A_ke));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC5A.kf", &assign_ExcIEEEAC5A_kf));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC5A.seefd1", &assign_ExcIEEEAC5A_seefd1));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC5A.seefd2", &assign_ExcIEEEAC5A_seefd2));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC5A.ta", &assign_ExcIEEEAC5A_ta));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC5A.te", &assign_ExcIEEEAC5A_te));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC5A.tf1", &assign_ExcIEEEAC5A_tf1));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC5A.tf2", &assign_ExcIEEEAC5A_tf2));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC5A.tf3", &assign_ExcIEEEAC5A_tf3));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC5A.vrmax", &assign_ExcIEEEAC5A_vrmax));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC5A.vrmin", &assign_ExcIEEEAC5A_vrmin));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC6A.ka", &assign_ExcIEEEAC6A_ka));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC6A.kc", &assign_ExcIEEEAC6A_kc));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC6A.kd", &assign_ExcIEEEAC6A_kd));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC6A.ke", &assign_ExcIEEEAC6A_ke));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC6A.kh", &assign_ExcIEEEAC6A_kh));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC6A.seve1", &assign_ExcIEEEAC6A_seve1));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC6A.seve2", &assign_ExcIEEEAC6A_seve2));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC6A.ta", &assign_ExcIEEEAC6A_ta));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC6A.tb", &assign_ExcIEEEAC6A_tb));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC6A.tc", &assign_ExcIEEEAC6A_tc));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC6A.te", &assign_ExcIEEEAC6A_te));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC6A.th", &assign_ExcIEEEAC6A_th));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC6A.tj", &assign_ExcIEEEAC6A_tj));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC6A.tk", &assign_ExcIEEEAC6A_tk));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC6A.vamax", &assign_ExcIEEEAC6A_vamax));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC6A.vamin", &assign_ExcIEEEAC6A_vamin));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC6A.ve1", &assign_ExcIEEEAC6A_ve1));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC6A.ve2", &assign_ExcIEEEAC6A_ve2));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC6A.vfelim", &assign_ExcIEEEAC6A_vfelim));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC6A.vhmax", &assign_ExcIEEEAC6A_vhmax));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC6A.vrmax", &assign_ExcIEEEAC6A_vrmax));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC6A.vrmin", &assign_ExcIEEEAC6A_vrmin));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC7B.kc", &assign_ExcIEEEAC7B_kc));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC7B.kd", &assign_ExcIEEEAC7B_kd));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC7B.kdr", &assign_ExcIEEEAC7B_kdr));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC7B.ke", &assign_ExcIEEEAC7B_ke));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC7B.kf1", &assign_ExcIEEEAC7B_kf1));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC7B.kf2", &assign_ExcIEEEAC7B_kf2));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC7B.kf3", &assign_ExcIEEEAC7B_kf3));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC7B.kia", &assign_ExcIEEEAC7B_kia));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC7B.kir", &assign_ExcIEEEAC7B_kir));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC7B.kl", &assign_ExcIEEEAC7B_kl));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC7B.kp", &assign_ExcIEEEAC7B_kp));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC7B.kpa", &assign_ExcIEEEAC7B_kpa));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC7B.kpr", &assign_ExcIEEEAC7B_kpr));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC7B.seve1", &assign_ExcIEEEAC7B_seve1));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC7B.seve2", &assign_ExcIEEEAC7B_seve2));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC7B.tdr", &assign_ExcIEEEAC7B_tdr));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC7B.te", &assign_ExcIEEEAC7B_te));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC7B.tf", &assign_ExcIEEEAC7B_tf));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC7B.vamax", &assign_ExcIEEEAC7B_vamax));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC7B.vamin", &assign_ExcIEEEAC7B_vamin));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC7B.ve1", &assign_ExcIEEEAC7B_ve1));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC7B.ve2", &assign_ExcIEEEAC7B_ve2));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC7B.vemin", &assign_ExcIEEEAC7B_vemin));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC7B.vfemax", &assign_ExcIEEEAC7B_vfemax));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC7B.vrmax", &assign_ExcIEEEAC7B_vrmax));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC7B.vrmin", &assign_ExcIEEEAC7B_vrmin));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC8B.ka", &assign_ExcIEEEAC8B_ka));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC8B.kc", &assign_ExcIEEEAC8B_kc));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC8B.kd", &assign_ExcIEEEAC8B_kd));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC8B.kdr", &assign_ExcIEEEAC8B_kdr));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC8B.ke", &assign_ExcIEEEAC8B_ke));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC8B.kir", &assign_ExcIEEEAC8B_kir));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC8B.kpr", &assign_ExcIEEEAC8B_kpr));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC8B.seve1", &assign_ExcIEEEAC8B_seve1));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC8B.seve2", &assign_ExcIEEEAC8B_seve2));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC8B.ta", &assign_ExcIEEEAC8B_ta));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC8B.tdr", &assign_ExcIEEEAC8B_tdr));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC8B.te", &assign_ExcIEEEAC8B_te));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC8B.ve1", &assign_ExcIEEEAC8B_ve1));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC8B.ve2", &assign_ExcIEEEAC8B_ve2));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC8B.vemin", &assign_ExcIEEEAC8B_vemin));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC8B.vfemax", &assign_ExcIEEEAC8B_vfemax));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC8B.vrmax", &assign_ExcIEEEAC8B_vrmax));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEAC8B.vrmin", &assign_ExcIEEEAC8B_vrmin));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC1A.efd1", &assign_ExcIEEEDC1A_efd1));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC1A.efd2", &assign_ExcIEEEDC1A_efd2));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC1A.exclim", &assign_ExcIEEEDC1A_exclim));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC1A.ka", &assign_ExcIEEEDC1A_ka));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC1A.ke", &assign_ExcIEEEDC1A_ke));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC1A.kf", &assign_ExcIEEEDC1A_kf));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC1A.seefd1", &assign_ExcIEEEDC1A_seefd1));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC1A.seefd2", &assign_ExcIEEEDC1A_seefd2));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC1A.ta", &assign_ExcIEEEDC1A_ta));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC1A.tb", &assign_ExcIEEEDC1A_tb));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC1A.tc", &assign_ExcIEEEDC1A_tc));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC1A.te", &assign_ExcIEEEDC1A_te));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC1A.tf", &assign_ExcIEEEDC1A_tf));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC1A.uelin", &assign_ExcIEEEDC1A_uelin));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC1A.vrmax", &assign_ExcIEEEDC1A_vrmax));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC1A.vrmin", &assign_ExcIEEEDC1A_vrmin));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC2A.efd1", &assign_ExcIEEEDC2A_efd1));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC2A.efd2", &assign_ExcIEEEDC2A_efd2));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC2A.exclim", &assign_ExcIEEEDC2A_exclim));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC2A.ka", &assign_ExcIEEEDC2A_ka));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC2A.ke", &assign_ExcIEEEDC2A_ke));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC2A.kf", &assign_ExcIEEEDC2A_kf));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC2A.seefd1", &assign_ExcIEEEDC2A_seefd1));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC2A.seefd2", &assign_ExcIEEEDC2A_seefd2));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC2A.ta", &assign_ExcIEEEDC2A_ta));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC2A.tb", &assign_ExcIEEEDC2A_tb));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC2A.tc", &assign_ExcIEEEDC2A_tc));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC2A.te", &assign_ExcIEEEDC2A_te));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC2A.tf", &assign_ExcIEEEDC2A_tf));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC2A.uelin", &assign_ExcIEEEDC2A_uelin));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC2A.vrmax", &assign_ExcIEEEDC2A_vrmax));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC2A.vrmin", &assign_ExcIEEEDC2A_vrmin));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC3A.efd1", &assign_ExcIEEEDC3A_efd1));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC3A.efd2", &assign_ExcIEEEDC3A_efd2));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC3A.exclim", &assign_ExcIEEEDC3A_exclim));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC3A.ke", &assign_ExcIEEEDC3A_ke));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC3A.kv", &assign_ExcIEEEDC3A_kv));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC3A.seefd1", &assign_ExcIEEEDC3A_seefd1));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC3A.seefd2", &assign_ExcIEEEDC3A_seefd2));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC3A.te", &assign_ExcIEEEDC3A_te));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC3A.trh", &assign_ExcIEEEDC3A_trh));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC3A.vrmax", &assign_ExcIEEEDC3A_vrmax));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC3A.vrmin", &assign_ExcIEEEDC3A_vrmin));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC4B.efd1", &assign_ExcIEEEDC4B_efd1));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC4B.efd2", &assign_ExcIEEEDC4B_efd2));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC4B.ka", &assign_ExcIEEEDC4B_ka));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC4B.kd", &assign_ExcIEEEDC4B_kd));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC4B.ke", &assign_ExcIEEEDC4B_ke));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC4B.kf", &assign_ExcIEEEDC4B_kf));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC4B.ki", &assign_ExcIEEEDC4B_ki));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC4B.kp", &assign_ExcIEEEDC4B_kp));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC4B.oelin", &assign_ExcIEEEDC4B_oelin));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC4B.seefd1", &assign_ExcIEEEDC4B_seefd1));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC4B.seefd2", &assign_ExcIEEEDC4B_seefd2));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC4B.ta", &assign_ExcIEEEDC4B_ta));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC4B.td", &assign_ExcIEEEDC4B_td));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC4B.te", &assign_ExcIEEEDC4B_te));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC4B.tf", &assign_ExcIEEEDC4B_tf));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC4B.uelin", &assign_ExcIEEEDC4B_uelin));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC4B.vemin", &assign_ExcIEEEDC4B_vemin));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC4B.vrmax", &assign_ExcIEEEDC4B_vrmax));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEDC4B.vrmin", &assign_ExcIEEEDC4B_vrmin));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST1A.ilr", &assign_ExcIEEEST1A_ilr));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST1A.ka", &assign_ExcIEEEST1A_ka));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST1A.kc", &assign_ExcIEEEST1A_kc));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST1A.kf", &assign_ExcIEEEST1A_kf));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST1A.klr", &assign_ExcIEEEST1A_klr));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST1A.pssin", &assign_ExcIEEEST1A_pssin));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST1A.ta", &assign_ExcIEEEST1A_ta));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST1A.tb", &assign_ExcIEEEST1A_tb));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST1A.tb1", &assign_ExcIEEEST1A_tb1));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST1A.tc", &assign_ExcIEEEST1A_tc));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST1A.tc1", &assign_ExcIEEEST1A_tc1));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST1A.tf", &assign_ExcIEEEST1A_tf));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST1A.uelin", &assign_ExcIEEEST1A_uelin));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST1A.vamax", &assign_ExcIEEEST1A_vamax));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST1A.vamin", &assign_ExcIEEEST1A_vamin));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST1A.vimax", &assign_ExcIEEEST1A_vimax));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST1A.vimin", &assign_ExcIEEEST1A_vimin));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST1A.vrmax", &assign_ExcIEEEST1A_vrmax));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST1A.vrmin", &assign_ExcIEEEST1A_vrmin));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST2A.efdmax", &assign_ExcIEEEST2A_efdmax));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST2A.ka", &assign_ExcIEEEST2A_ka));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST2A.kc", &assign_ExcIEEEST2A_kc));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST2A.ke", &assign_ExcIEEEST2A_ke));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST2A.kf", &assign_ExcIEEEST2A_kf));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST2A.ki", &assign_ExcIEEEST2A_ki));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST2A.kp", &assign_ExcIEEEST2A_kp));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST2A.ta", &assign_ExcIEEEST2A_ta));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST2A.te", &assign_ExcIEEEST2A_te));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST2A.tf", &assign_ExcIEEEST2A_tf));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST2A.uelin", &assign_ExcIEEEST2A_uelin));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST2A.vrmax", &assign_ExcIEEEST2A_vrmax));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST2A.vrmin", &assign_ExcIEEEST2A_vrmin));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST3A.ka", &assign_ExcIEEEST3A_ka));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST3A.kc", &assign_ExcIEEEST3A_kc));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST3A.kg", &assign_ExcIEEEST3A_kg));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST3A.ki", &assign_ExcIEEEST3A_ki));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST3A.km", &assign_ExcIEEEST3A_km));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST3A.kp", &assign_ExcIEEEST3A_kp));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST3A.ta", &assign_ExcIEEEST3A_ta));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST3A.tb", &assign_ExcIEEEST3A_tb));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST3A.tc", &assign_ExcIEEEST3A_tc));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST3A.thetap", &assign_ExcIEEEST3A_thetap));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST3A.tm", &assign_ExcIEEEST3A_tm));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST3A.vbmax", &assign_ExcIEEEST3A_vbmax));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST3A.vgmax", &assign_ExcIEEEST3A_vgmax));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST3A.vimax", &assign_ExcIEEEST3A_vimax));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST3A.vimin", &assign_ExcIEEEST3A_vimin));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST3A.vmmax", &assign_ExcIEEEST3A_vmmax));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST3A.vmmin", &assign_ExcIEEEST3A_vmmin));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST3A.vrmax", &assign_ExcIEEEST3A_vrmax));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST3A.vrmin", &assign_ExcIEEEST3A_vrmin));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST3A.xl", &assign_ExcIEEEST3A_xl));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST4B.kc", &assign_ExcIEEEST4B_kc));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST4B.kg", &assign_ExcIEEEST4B_kg));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST4B.ki", &assign_ExcIEEEST4B_ki));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST4B.kim", &assign_ExcIEEEST4B_kim));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST4B.kir", &assign_ExcIEEEST4B_kir));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST4B.kp", &assign_ExcIEEEST4B_kp));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST4B.kpm", &assign_ExcIEEEST4B_kpm));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST4B.kpr", &assign_ExcIEEEST4B_kpr));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST4B.ta", &assign_ExcIEEEST4B_ta));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST4B.thetap", &assign_ExcIEEEST4B_thetap));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST4B.vbmax", &assign_ExcIEEEST4B_vbmax));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST4B.vmmax", &assign_ExcIEEEST4B_vmmax));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST4B.vmmin", &assign_ExcIEEEST4B_vmmin));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST4B.vrmax", &assign_ExcIEEEST4B_vrmax));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST4B.vrmin", &assign_ExcIEEEST4B_vrmin));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST4B.xl", &assign_ExcIEEEST4B_xl));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST5B.kc", &assign_ExcIEEEST5B_kc));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST5B.kr", &assign_ExcIEEEST5B_kr));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST5B.t1", &assign_ExcIEEEST5B_t1));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST5B.tb1", &assign_ExcIEEEST5B_tb1));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST5B.tb2", &assign_ExcIEEEST5B_tb2));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST5B.tc1", &assign_ExcIEEEST5B_tc1));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST5B.tc2", &assign_ExcIEEEST5B_tc2));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST5B.tob1", &assign_ExcIEEEST5B_tob1));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST5B.tob2", &assign_ExcIEEEST5B_tob2));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST5B.toc1", &assign_ExcIEEEST5B_toc1));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST5B.toc2", &assign_ExcIEEEST5B_toc2));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST5B.tub1", &assign_ExcIEEEST5B_tub1));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST5B.tub2", &assign_ExcIEEEST5B_tub2));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST5B.tuc1", &assign_ExcIEEEST5B_tuc1));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST5B.tuc2", &assign_ExcIEEEST5B_tuc2));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST5B.vrmax", &assign_ExcIEEEST5B_vrmax));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST5B.vrmin", &assign_ExcIEEEST5B_vrmin));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST6B.ilr", &assign_ExcIEEEST6B_ilr));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST6B.kci", &assign_ExcIEEEST6B_kci));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST6B.kff", &assign_ExcIEEEST6B_kff));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST6B.kg", &assign_ExcIEEEST6B_kg));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST6B.kia", &assign_ExcIEEEST6B_kia));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST6B.klr", &assign_ExcIEEEST6B_klr));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST6B.km", &assign_ExcIEEEST6B_km));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST6B.kpa", &assign_ExcIEEEST6B_kpa));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST6B.oelin", &assign_ExcIEEEST6B_oelin));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST6B.tg", &assign_ExcIEEEST6B_tg));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST6B.vamax", &assign_ExcIEEEST6B_vamax));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST6B.vamin", &assign_ExcIEEEST6B_vamin));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST6B.vrmax", &assign_ExcIEEEST6B_vrmax));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST6B.vrmin", &assign_ExcIEEEST6B_vrmin));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST7B.kh", &assign_ExcIEEEST7B_kh));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST7B.kia", &assign_ExcIEEEST7B_kia));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST7B.kl", &assign_ExcIEEEST7B_kl));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST7B.kpa", &assign_ExcIEEEST7B_kpa));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST7B.oelin", &assign_ExcIEEEST7B_oelin));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST7B.tb", &assign_ExcIEEEST7B_tb));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST7B.tc", &assign_ExcIEEEST7B_tc));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST7B.tf", &assign_ExcIEEEST7B_tf));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST7B.tg", &assign_ExcIEEEST7B_tg));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST7B.tia", &assign_ExcIEEEST7B_tia));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST7B.uelin", &assign_ExcIEEEST7B_uelin));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST7B.vmax", &assign_ExcIEEEST7B_vmax));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST7B.vmin", &assign_ExcIEEEST7B_vmin));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST7B.vrmax", &assign_ExcIEEEST7B_vrmax));
	dynamic_switch.insert(std::make_pair("cim:ExcIEEEST7B.vrmin", &assign_ExcIEEEST7B_vrmin));
	dynamic_switch.insert(std::make_pair("cim:ExcOEX3T.e1", &assign_ExcOEX3T_e1));
	dynamic_switch.insert(std::make_pair("cim:ExcOEX3T.e2", &assign_ExcOEX3T_e2));
	dynamic_switch.insert(std::make_pair("cim:ExcOEX3T.ka", &assign_ExcOEX3T_ka));
	dynamic_switch.insert(std::make_pair("cim:ExcOEX3T.kc", &assign_ExcOEX3T_kc));
	dynamic_switch.insert(std::make_pair("cim:ExcOEX3T.kd", &assign_ExcOEX3T_kd));
	dynamic_switch.insert(std::make_pair("cim:ExcOEX3T.ke", &assign_ExcOEX3T_ke));
	dynamic_switch.insert(std::make_pair("cim:ExcOEX3T.kf", &assign_ExcOEX3T_kf));
	dynamic_switch.insert(std::make_pair("cim:ExcOEX3T.see1", &assign_ExcOEX3T_see1));
	dynamic_switch.insert(std::make_pair("cim:ExcOEX3T.see2", &assign_ExcOEX3T_see2));
	dynamic_switch.insert(std::make_pair("cim:ExcOEX3T.t1", &assign_ExcOEX3T_t1));
	dynamic_switch.insert(std::make_pair("cim:ExcOEX3T.t2", &assign_ExcOEX3T_t2));
	dynamic_switch.insert(std::make_pair("cim:ExcOEX3T.t3", &assign_ExcOEX3T_t3));
	dynamic_switch.insert(std::make_pair("cim:ExcOEX3T.t4", &assign_ExcOEX3T_t4));
	dynamic_switch.insert(std::make_pair("cim:ExcOEX3T.t5", &assign_ExcOEX3T_t5));
	dynamic_switch.insert(std::make_pair("cim:ExcOEX3T.t6", &assign_ExcOEX3T_t6));
	dynamic_switch.insert(std::make_pair("cim:ExcOEX3T.te", &assign_ExcOEX3T_te));
	dynamic_switch.insert(std::make_pair("cim:ExcOEX3T.tf", &assign_ExcOEX3T_tf));
	dynamic_switch.insert(std::make_pair("cim:ExcOEX3T.vrmax", &assign_ExcOEX3T_vrmax));
	dynamic_switch.insert(std::make_pair("cim:ExcOEX3T.vrmin", &assign_ExcOEX3T_vrmin));
	dynamic_switch.insert(std::make_pair("cim:ExcPIC.e1", &assign_ExcPIC_e1));
	dynamic_switch.insert(std::make_pair("cim:ExcPIC.e2", &assign_ExcPIC_e2));
	dynamic_switch.insert(std::make_pair("cim:ExcPIC.efdmax", &assign_ExcPIC_efdmax));
	dynamic_switch.insert(std::make_pair("cim:ExcPIC.efdmin", &assign_ExcPIC_efdmin));
	dynamic_switch.insert(std::make_pair("cim:ExcPIC.ka", &assign_ExcPIC_ka));
	dynamic_switch.insert(std::make_pair("cim:ExcPIC.kc", &assign_ExcPIC_kc));
	dynamic_switch.insert(std::make_pair("cim:ExcPIC.ke", &assign_ExcPIC_ke));
	dynamic_switch.insert(std::make_pair("cim:ExcPIC.kf", &assign_ExcPIC_kf));
	dynamic_switch.insert(std::make_pair("cim:ExcPIC.ki", &assign_ExcPIC_ki));
	dynamic_switch.insert(std::make_pair("cim:ExcPIC.kp", &assign_ExcPIC_kp));
	dynamic_switch.insert(std::make_pair("cim:ExcPIC.se1", &assign_ExcPIC_se1));
	dynamic_switch.insert(std::make_pair("cim:ExcPIC.se2", &assign_ExcPIC_se2));
	dynamic_switch.insert(std::make_pair("cim:ExcPIC.ta1", &assign_ExcPIC_ta1));
	dynamic_switch.insert(std::make_pair("cim:ExcPIC.ta2", &assign_ExcPIC_ta2));
	dynamic_switch.insert(std::make_pair("cim:ExcPIC.ta3", &assign_ExcPIC_ta3));
	dynamic_switch.insert(std::make_pair("cim:ExcPIC.ta4", &assign_ExcPIC_ta4));
	dynamic_switch.insert(std::make_pair("cim:ExcPIC.te", &assign_ExcPIC_te));
	dynamic_switch.insert(std::make_pair("cim:ExcPIC.tf1", &assign_ExcPIC_tf1));
	dynamic_switch.insert(std::make_pair("cim:ExcPIC.tf2", &assign_ExcPIC_tf2));
	dynamic_switch.insert(std::make_pair("cim:ExcPIC.vr1", &assign_ExcPIC_vr1));
	dynamic_switch.insert(std::make_pair("cim:ExcPIC.vr2", &assign_ExcPIC_vr2));
	dynamic_switch.insert(std::make_pair("cim:ExcPIC.vrmax", &assign_ExcPIC_vrmax));
	dynamic_switch.insert(std::make_pair("cim:ExcPIC.vrmin", &assign_ExcPIC_vrmin));
	dynamic_switch.insert(std::make_pair("cim:ExcREXS.e1", &assign_ExcREXS_e1));
	dynamic_switch.insert(std::make_pair("cim:ExcREXS.e2", &assign_ExcREXS_e2));
	dynamic_switch.insert(std::make_pair("cim:ExcREXS.fbf", &assign_ExcREXS_fbf));
	dynamic_switch.insert(std::make_pair("cim:ExcREXS.flimf", &assign_ExcREXS_flimf));
	dynamic_switch.insert(std::make_pair("cim:ExcREXS.kc", &assign_ExcREXS_kc));
	dynamic_switch.insert(std::make_pair("cim:ExcREXS.kd", &assign_ExcREXS_kd));
	dynamic_switch.insert(std::make_pair("cim:ExcREXS.ke", &assign_ExcREXS_ke));
	dynamic_switch.insert(std::make_pair("cim:ExcREXS.kefd", &assign_ExcREXS_kefd));
	dynamic_switch.insert(std::make_pair("cim:ExcREXS.kf", &assign_ExcREXS_kf));
	dynamic_switch.insert(std::make_pair("cim:ExcREXS.kh", &assign_ExcREXS_kh));
	dynamic_switch.insert(std::make_pair("cim:ExcREXS.kii", &assign_ExcREXS_kii));
	dynamic_switch.insert(std::make_pair("cim:ExcREXS.kip", &assign_ExcREXS_kip));
	dynamic_switch.insert(std::make_pair("cim:ExcREXS.ks", &assign_ExcREXS_ks));
	dynamic_switch.insert(std::make_pair("cim:ExcREXS.kvi", &assign_ExcREXS_kvi));
	dynamic_switch.insert(std::make_pair("cim:ExcREXS.kvp", &assign_ExcREXS_kvp));
	dynamic_switch.insert(std::make_pair("cim:ExcREXS.kvphz", &assign_ExcREXS_kvphz));
	dynamic_switch.insert(std::make_pair("cim:ExcREXS.nvphz", &assign_ExcREXS_nvphz));
	dynamic_switch.insert(std::make_pair("cim:ExcREXS.se1", &assign_ExcREXS_se1));
	dynamic_switch.insert(std::make_pair("cim:ExcREXS.se2", &assign_ExcREXS_se2));
	dynamic_switch.insert(std::make_pair("cim:ExcREXS.ta", &assign_ExcREXS_ta));
	dynamic_switch.insert(std::make_pair("cim:ExcREXS.tb1", &assign_ExcREXS_tb1));
	dynamic_switch.insert(std::make_pair("cim:ExcREXS.tb2", &assign_ExcREXS_tb2));
	dynamic_switch.insert(std::make_pair("cim:ExcREXS.tc1", &assign_ExcREXS_tc1));
	dynamic_switch.insert(std::make_pair("cim:ExcREXS.tc2", &assign_ExcREXS_tc2));
	dynamic_switch.insert(std::make_pair("cim:ExcREXS.te", &assign_ExcREXS_te));
	dynamic_switch.insert(std::make_pair("cim:ExcREXS.tf", &assign_ExcREXS_tf));
	dynamic_switch.insert(std::make_pair("cim:ExcREXS.tf1", &assign_ExcREXS_tf1));
	dynamic_switch.insert(std::make_pair("cim:ExcREXS.tf2", &assign_ExcREXS_tf2));
	dynamic_switch.insert(std::make_pair("cim:ExcREXS.tp", &assign_ExcREXS_tp));
	dynamic_switch.insert(std::make_pair("cim:ExcREXS.vcmax", &assign_ExcREXS_vcmax));
	dynamic_switch.insert(std::make_pair("cim:ExcREXS.vfmax", &assign_ExcREXS_vfmax));
	dynamic_switch.insert(std::make_pair("cim:ExcREXS.vfmin", &assign_ExcREXS_vfmin));
	dynamic_switch.insert(std::make_pair("cim:ExcREXS.vimax", &assign_ExcREXS_vimax));
	dynamic_switch.insert(std::make_pair("cim:ExcREXS.vrmax", &assign_ExcREXS_vrmax));
	dynamic_switch.insert(std::make_pair("cim:ExcREXS.vrmin", &assign_ExcREXS_vrmin));
	dynamic_switch.insert(std::make_pair("cim:ExcREXS.xc", &assign_ExcREXS_xc));
	dynamic_switch.insert(std::make_pair("cim:ExcSCRX.cswitch", &assign_ExcSCRX_cswitch));
	dynamic_switch.insert(std::make_pair("cim:ExcSCRX.emax", &assign_ExcSCRX_emax));
	dynamic_switch.insert(std::make_pair("cim:ExcSCRX.emin", &assign_ExcSCRX_emin));
	dynamic_switch.insert(std::make_pair("cim:ExcSCRX.k", &assign_ExcSCRX_k));
	dynamic_switch.insert(std::make_pair("cim:ExcSCRX.rcrfd", &assign_ExcSCRX_rcrfd));
	dynamic_switch.insert(std::make_pair("cim:ExcSCRX.tatb", &assign_ExcSCRX_tatb));
	dynamic_switch.insert(std::make_pair("cim:ExcSCRX.tb", &assign_ExcSCRX_tb));
	dynamic_switch.insert(std::make_pair("cim:ExcSCRX.te", &assign_ExcSCRX_te));
	dynamic_switch.insert(std::make_pair("cim:ExcSEXS.efdmax", &assign_ExcSEXS_efdmax));
	dynamic_switch.insert(std::make_pair("cim:ExcSEXS.efdmin", &assign_ExcSEXS_efdmin));
	dynamic_switch.insert(std::make_pair("cim:ExcSEXS.emax", &assign_ExcSEXS_emax));
	dynamic_switch.insert(std::make_pair("cim:ExcSEXS.emin", &assign_ExcSEXS_emin));
	dynamic_switch.insert(std::make_pair("cim:ExcSEXS.k", &assign_ExcSEXS_k));
	dynamic_switch.insert(std::make_pair("cim:ExcSEXS.kc", &assign_ExcSEXS_kc));
	dynamic_switch.insert(std::make_pair("cim:ExcSEXS.tatb", &assign_ExcSEXS_tatb));
	dynamic_switch.insert(std::make_pair("cim:ExcSEXS.tb", &assign_ExcSEXS_tb));
	dynamic_switch.insert(std::make_pair("cim:ExcSEXS.tc", &assign_ExcSEXS_tc));
	dynamic_switch.insert(std::make_pair("cim:ExcSEXS.te", &assign_ExcSEXS_te));
	dynamic_switch.insert(std::make_pair("cim:ExcSK.efdmax", &assign_ExcSK_efdmax));
	dynamic_switch.insert(std::make_pair("cim:ExcSK.efdmin", &assign_ExcSK_efdmin));
	dynamic_switch.insert(std::make_pair("cim:ExcSK.emax", &assign_ExcSK_emax));
	dynamic_switch.insert(std::make_pair("cim:ExcSK.emin", &assign_ExcSK_emin));
	dynamic_switch.insert(std::make_pair("cim:ExcSK.k", &assign_ExcSK_k));
	dynamic_switch.insert(std::make_pair("cim:ExcSK.k1", &assign_ExcSK_k1));
	dynamic_switch.insert(std::make_pair("cim:ExcSK.k2", &assign_ExcSK_k2));
	dynamic_switch.insert(std::make_pair("cim:ExcSK.kc", &assign_ExcSK_kc));
	dynamic_switch.insert(std::make_pair("cim:ExcSK.kce", &assign_ExcSK_kce));
	dynamic_switch.insert(std::make_pair("cim:ExcSK.kd", &assign_ExcSK_kd));
	dynamic_switch.insert(std::make_pair("cim:ExcSK.kgob", &assign_ExcSK_kgob));
	dynamic_switch.insert(std::make_pair("cim:ExcSK.kp", &assign_ExcSK_kp));
	dynamic_switch.insert(std::make_pair("cim:ExcSK.kqi", &assign_ExcSK_kqi));
	dynamic_switch.insert(std::make_pair("cim:ExcSK.kqob", &assign_ExcSK_kqob));
	dynamic_switch.insert(std::make_pair("cim:ExcSK.kqp", &assign_ExcSK_kqp));
	dynamic_switch.insert(std::make_pair("cim:ExcSK.nq", &assign_ExcSK_nq));
	dynamic_switch.insert(std::make_pair("cim:ExcSK.qconoff", &assign_ExcSK_qconoff));
	dynamic_switch.insert(std::make_pair("cim:ExcSK.qz", &assign_ExcSK_qz));
	dynamic_switch.insert(std::make_pair("cim:ExcSK.remote", &assign_ExcSK_remote));
	dynamic_switch.insert(std::make_pair("cim:ExcSK.sbase", &assign_ExcSK_sbase));
	dynamic_switch.insert(std::make_pair("cim:ExcSK.tc", &assign_ExcSK_tc));
	dynamic_switch.insert(std::make_pair("cim:ExcSK.te", &assign_ExcSK_te));
	dynamic_switch.insert(std::make_pair("cim:ExcSK.ti", &assign_ExcSK_ti));
	dynamic_switch.insert(std::make_pair("cim:ExcSK.tp", &assign_ExcSK_tp));
	dynamic_switch.insert(std::make_pair("cim:ExcSK.tr", &assign_ExcSK_tr));
	dynamic_switch.insert(std::make_pair("cim:ExcSK.uimax", &assign_ExcSK_uimax));
	dynamic_switch.insert(std::make_pair("cim:ExcSK.uimin", &assign_ExcSK_uimin));
	dynamic_switch.insert(std::make_pair("cim:ExcSK.urmax", &assign_ExcSK_urmax));
	dynamic_switch.insert(std::make_pair("cim:ExcSK.urmin", &assign_ExcSK_urmin));
	dynamic_switch.insert(std::make_pair("cim:ExcSK.vtmax", &assign_ExcSK_vtmax));
	dynamic_switch.insert(std::make_pair("cim:ExcSK.vtmin", &assign_ExcSK_vtmin));
	dynamic_switch.insert(std::make_pair("cim:ExcSK.yp", &assign_ExcSK_yp));
	dynamic_switch.insert(std::make_pair("cim:ExcST1A.ilr", &assign_ExcST1A_ilr));
	dynamic_switch.insert(std::make_pair("cim:ExcST1A.ka", &assign_ExcST1A_ka));
	dynamic_switch.insert(std::make_pair("cim:ExcST1A.kc", &assign_ExcST1A_kc));
	dynamic_switch.insert(std::make_pair("cim:ExcST1A.kf", &assign_ExcST1A_kf));
	dynamic_switch.insert(std::make_pair("cim:ExcST1A.klr", &assign_ExcST1A_klr));
	dynamic_switch.insert(std::make_pair("cim:ExcST1A.ta", &assign_ExcST1A_ta));
	dynamic_switch.insert(std::make_pair("cim:ExcST1A.tb", &assign_ExcST1A_tb));
	dynamic_switch.insert(std::make_pair("cim:ExcST1A.tb1", &assign_ExcST1A_tb1));
	dynamic_switch.insert(std::make_pair("cim:ExcST1A.tc", &assign_ExcST1A_tc));
	dynamic_switch.insert(std::make_pair("cim:ExcST1A.tc1", &assign_ExcST1A_tc1));
	dynamic_switch.insert(std::make_pair("cim:ExcST1A.tf", &assign_ExcST1A_tf));
	dynamic_switch.insert(std::make_pair("cim:ExcST1A.vamax", &assign_ExcST1A_vamax));
	dynamic_switch.insert(std::make_pair("cim:ExcST1A.vamin", &assign_ExcST1A_vamin));
	dynamic_switch.insert(std::make_pair("cim:ExcST1A.vimax", &assign_ExcST1A_vimax));
	dynamic_switch.insert(std::make_pair("cim:ExcST1A.vimin", &assign_ExcST1A_vimin));
	dynamic_switch.insert(std::make_pair("cim:ExcST1A.vrmax", &assign_ExcST1A_vrmax));
	dynamic_switch.insert(std::make_pair("cim:ExcST1A.vrmin", &assign_ExcST1A_vrmin));
	dynamic_switch.insert(std::make_pair("cim:ExcST1A.xe", &assign_ExcST1A_xe));
	dynamic_switch.insert(std::make_pair("cim:ExcST2A.efdmax", &assign_ExcST2A_efdmax));
	dynamic_switch.insert(std::make_pair("cim:ExcST2A.ka", &assign_ExcST2A_ka));
	dynamic_switch.insert(std::make_pair("cim:ExcST2A.kc", &assign_ExcST2A_kc));
	dynamic_switch.insert(std::make_pair("cim:ExcST2A.ke", &assign_ExcST2A_ke));
	dynamic_switch.insert(std::make_pair("cim:ExcST2A.kf", &assign_ExcST2A_kf));
	dynamic_switch.insert(std::make_pair("cim:ExcST2A.ki", &assign_ExcST2A_ki));
	dynamic_switch.insert(std::make_pair("cim:ExcST2A.kp", &assign_ExcST2A_kp));
	dynamic_switch.insert(std::make_pair("cim:ExcST2A.ta", &assign_ExcST2A_ta));
	dynamic_switch.insert(std::make_pair("cim:ExcST2A.tb", &assign_ExcST2A_tb));
	dynamic_switch.insert(std::make_pair("cim:ExcST2A.tc", &assign_ExcST2A_tc));
	dynamic_switch.insert(std::make_pair("cim:ExcST2A.te", &assign_ExcST2A_te));
	dynamic_switch.insert(std::make_pair("cim:ExcST2A.tf", &assign_ExcST2A_tf));
	dynamic_switch.insert(std::make_pair("cim:ExcST2A.uelin", &assign_ExcST2A_uelin));
	dynamic_switch.insert(std::make_pair("cim:ExcST2A.vrmax", &assign_ExcST2A_vrmax));
	dynamic_switch.insert(std::make_pair("cim:ExcST2A.vrmin", &assign_ExcST2A_vrmin));
	dynamic_switch.insert(std::make_pair("cim:ExcST3A.efdmax", &assign_ExcST3A_efdmax));
	dynamic_switch.insert(std::make_pair("cim:ExcST3A.kc", &assign_ExcST3A_kc));
	dynamic_switch.insert(std::make_pair("cim:ExcST3A.kg", &assign_ExcST3A_kg));
	dynamic_switch.insert(std::make_pair("cim:ExcST3A.ki", &assign_ExcST3A_ki));
	dynamic_switch.insert(std::make_pair("cim:ExcST3A.kj", &assign_ExcST3A_kj));
	dynamic_switch.insert(std::make_pair("cim:ExcST3A.km", &assign_ExcST3A_km));
	dynamic_switch.insert(std::make_pair("cim:ExcST3A.kp", &assign_ExcST3A_kp));
	dynamic_switch.insert(std::make_pair("cim:ExcST3A.ks", &assign_ExcST3A_ks));
	dynamic_switch.insert(std::make_pair("cim:ExcST3A.ks1", &assign_ExcST3A_ks1));
	dynamic_switch.insert(std::make_pair("cim:ExcST3A.tb", &assign_ExcST3A_tb));
	dynamic_switch.insert(std::make_pair("cim:ExcST3A.tc", &assign_ExcST3A_tc));
	dynamic_switch.insert(std::make_pair("cim:ExcST3A.thetap", &assign_ExcST3A_thetap));
	dynamic_switch.insert(std::make_pair("cim:ExcST3A.tm", &assign_ExcST3A_tm));
	dynamic_switch.insert(std::make_pair("cim:ExcST3A.vbmax", &assign_ExcST3A_vbmax));
	dynamic_switch.insert(std::make_pair("cim:ExcST3A.vgmax", &assign_ExcST3A_vgmax));
	dynamic_switch.insert(std::make_pair("cim:ExcST3A.vimax", &assign_ExcST3A_vimax));
	dynamic_switch.insert(std::make_pair("cim:ExcST3A.vimin", &assign_ExcST3A_vimin));
	dynamic_switch.insert(std::make_pair("cim:ExcST3A.vrmax", &assign_ExcST3A_vrmax));
	dynamic_switch.insert(std::make_pair("cim:ExcST3A.vrmin", &assign_ExcST3A_vrmin));
	dynamic_switch.insert(std::make_pair("cim:ExcST3A.xl", &assign_ExcST3A_xl));
	dynamic_switch.insert(std::make_pair("cim:ExcST4B.kc", &assign_ExcST4B_kc));
	dynamic_switch.insert(std::make_pair("cim:ExcST4B.kg", &assign_ExcST4B_kg));
	dynamic_switch.insert(std::make_pair("cim:ExcST4B.ki", &assign_ExcST4B_ki));
	dynamic_switch.insert(std::make_pair("cim:ExcST4B.kim", &assign_ExcST4B_kim));
	dynamic_switch.insert(std::make_pair("cim:ExcST4B.kir", &assign_ExcST4B_kir));
	dynamic_switch.insert(std::make_pair("cim:ExcST4B.kp", &assign_ExcST4B_kp));
	dynamic_switch.insert(std::make_pair("cim:ExcST4B.kpm", &assign_ExcST4B_kpm));
	dynamic_switch.insert(std::make_pair("cim:ExcST4B.kpr", &assign_ExcST4B_kpr));
	dynamic_switch.insert(std::make_pair("cim:ExcST4B.lvgate", &assign_ExcST4B_lvgate));
	dynamic_switch.insert(std::make_pair("cim:ExcST4B.ta", &assign_ExcST4B_ta));
	dynamic_switch.insert(std::make_pair("cim:ExcST4B.thetap", &assign_ExcST4B_thetap));
	dynamic_switch.insert(std::make_pair("cim:ExcST4B.uel", &assign_ExcST4B_uel));
	dynamic_switch.insert(std::make_pair("cim:ExcST4B.vbmax", &assign_ExcST4B_vbmax));
	dynamic_switch.insert(std::make_pair("cim:ExcST4B.vgmax", &assign_ExcST4B_vgmax));
	dynamic_switch.insert(std::make_pair("cim:ExcST4B.vmmax", &assign_ExcST4B_vmmax));
	dynamic_switch.insert(std::make_pair("cim:ExcST4B.vmmin", &assign_ExcST4B_vmmin));
	dynamic_switch.insert(std::make_pair("cim:ExcST4B.vrmax", &assign_ExcST4B_vrmax));
	dynamic_switch.insert(std::make_pair("cim:ExcST4B.vrmin", &assign_ExcST4B_vrmin));
	dynamic_switch.insert(std::make_pair("cim:ExcST4B.xl", &assign_ExcST4B_xl));
	dynamic_switch.insert(std::make_pair("cim:ExcST6B.ilr", &assign_ExcST6B_ilr));
	dynamic_switch.insert(std::make_pair("cim:ExcST6B.k1", &assign_ExcST6B_k1));
	dynamic_switch.insert(std::make_pair("cim:ExcST6B.kcl", &assign_ExcST6B_kcl));
	dynamic_switch.insert(std::make_pair("cim:ExcST6B.kff", &assign_ExcST6B_kff));
	dynamic_switch.insert(std::make_pair("cim:ExcST6B.kg", &assign_ExcST6B_kg));
	dynamic_switch.insert(std::make_pair("cim:ExcST6B.kia", &assign_ExcST6B_kia));
	dynamic_switch.insert(std::make_pair("cim:ExcST6B.klr", &assign_ExcST6B_klr));
	dynamic_switch.insert(std::make_pair("cim:ExcST6B.km", &assign_ExcST6B_km));
	dynamic_switch.insert(std::make_pair("cim:ExcST6B.kpa", &assign_ExcST6B_kpa));
	dynamic_switch.insert(std::make_pair("cim:ExcST6B.kvd", &assign_ExcST6B_kvd));
	dynamic_switch.insert(std::make_pair("cim:ExcST6B.oelin", &assign_ExcST6B_oelin));
	dynamic_switch.insert(std::make_pair("cim:ExcST6B.tg", &assign_ExcST6B_tg));
	dynamic_switch.insert(std::make_pair("cim:ExcST6B.ts", &assign_ExcST6B_ts));
	dynamic_switch.insert(std::make_pair("cim:ExcST6B.tvd", &assign_ExcST6B_tvd));
	dynamic_switch.insert(std::make_pair("cim:ExcST6B.vamax", &assign_ExcST6B_vamax));
	dynamic_switch.insert(std::make_pair("cim:ExcST6B.vamin", &assign_ExcST6B_vamin));
	dynamic_switch.insert(std::make_pair("cim:ExcST6B.vilim", &assign_ExcST6B_vilim));
	dynamic_switch.insert(std::make_pair("cim:ExcST6B.vimax", &assign_ExcST6B_vimax));
	dynamic_switch.insert(std::make_pair("cim:ExcST6B.vimin", &assign_ExcST6B_vimin));
	dynamic_switch.insert(std::make_pair("cim:ExcST6B.vmult", &assign_ExcST6B_vmult));
	dynamic_switch.insert(std::make_pair("cim:ExcST6B.vrmax", &assign_ExcST6B_vrmax));
	dynamic_switch.insert(std::make_pair("cim:ExcST6B.vrmin", &assign_ExcST6B_vrmin));
	dynamic_switch.insert(std::make_pair("cim:ExcST6B.xc", &assign_ExcST6B_xc));
	dynamic_switch.insert(std::make_pair("cim:ExcST7B.kh", &assign_ExcST7B_kh));
	dynamic_switch.insert(std::make_pair("cim:ExcST7B.kia", &assign_ExcST7B_kia));
	dynamic_switch.insert(std::make_pair("cim:ExcST7B.kl", &assign_ExcST7B_kl));
	dynamic_switch.insert(std::make_pair("cim:ExcST7B.kpa", &assign_ExcST7B_kpa));
	dynamic_switch.insert(std::make_pair("cim:ExcST7B.oelin", &assign_ExcST7B_oelin));
	dynamic_switch.insert(std::make_pair("cim:ExcST7B.tb", &assign_ExcST7B_tb));
	dynamic_switch.insert(std::make_pair("cim:ExcST7B.tc", &assign_ExcST7B_tc));
	dynamic_switch.insert(std::make_pair("cim:ExcST7B.tf", &assign_ExcST7B_tf));
	dynamic_switch.insert(std::make_pair("cim:ExcST7B.tg", &assign_ExcST7B_tg));
	dynamic_switch.insert(std::make_pair("cim:ExcST7B.tia", &assign_ExcST7B_tia));
	dynamic_switch.insert(std::make_pair("cim:ExcST7B.ts", &assign_ExcST7B_ts));
	dynamic_switch.insert(std::make_pair("cim:ExcST7B.uelin", &assign_ExcST7B_uelin));
	dynamic_switch.insert(std::make_pair("cim:ExcST7B.vmax", &assign_ExcST7B_vmax));
	dynamic_switch.insert(std::make_pair("cim:ExcST7B.vmin", &assign_ExcST7B_vmin));
	dynamic_switch.insert(std::make_pair("cim:ExcST7B.vrmax", &assign_ExcST7B_vrmax));
	dynamic_switch.insert(std::make_pair("cim:ExcST7B.vrmin", &assign_ExcST7B_vrmin));
	dynamic_switch.insert(std::make_pair("cim:LoadComposite.epfd", &assign_LoadComposite_epfd));
	dynamic_switch.insert(std::make_pair("cim:LoadComposite.epfs", &assign_LoadComposite_epfs));
	dynamic_switch.insert(std::make_pair("cim:LoadComposite.epvd", &assign_LoadComposite_epvd));
	dynamic_switch.insert(std::make_pair("cim:LoadComposite.epvs", &assign_LoadComposite_epvs));
	dynamic_switch.insert(std::make_pair("cim:LoadComposite.eqfd", &assign_LoadComposite_eqfd));
	dynamic_switch.insert(std::make_pair("cim:LoadComposite.eqfs", &assign_LoadComposite_eqfs));
	dynamic_switch.insert(std::make_pair("cim:LoadComposite.eqvd", &assign_LoadComposite_eqvd));
	dynamic_switch.insert(std::make_pair("cim:LoadComposite.eqvs", &assign_LoadComposite_eqvs));
	dynamic_switch.insert(std::make_pair("cim:LoadComposite.h", &assign_LoadComposite_h));
	dynamic_switch.insert(std::make_pair("cim:LoadComposite.lfrac", &assign_LoadComposite_lfrac));
	dynamic_switch.insert(std::make_pair("cim:LoadComposite.pfrac", &assign_LoadComposite_pfrac));
	dynamic_switch.insert(std::make_pair("cim:LoadGenericNonLinear.bs", &assign_LoadGenericNonLinear_bs));
	dynamic_switch.insert(std::make_pair("cim:LoadGenericNonLinear.bt", &assign_LoadGenericNonLinear_bt));
	dynamic_switch.insert(std::make_pair("cim:LoadGenericNonLinear.genericNonLinearLoadModelType", &assign_LoadGenericNonLinear_genericNonLinearLoadModelType));
	dynamic_switch.insert(std::make_pair("cim:LoadGenericNonLinear.ls", &assign_LoadGenericNonLinear_ls));
	dynamic_switch.insert(std::make_pair("cim:LoadGenericNonLinear.lt", &assign_LoadGenericNonLinear_lt));
	dynamic_switch.insert(std::make_pair("cim:LoadGenericNonLinear.pt", &assign_LoadGenericNonLinear_pt));
	dynamic_switch.insert(std::make_pair("cim:LoadGenericNonLinear.qt", &assign_LoadGenericNonLinear_qt));
	dynamic_switch.insert(std::make_pair("cim:LoadGenericNonLinear.tp", &assign_LoadGenericNonLinear_tp));
	dynamic_switch.insert(std::make_pair("cim:LoadGenericNonLinear.tq", &assign_LoadGenericNonLinear_tq));
	dynamic_switch.insert(std::make_pair("cim:LoadMotor.d", &assign_LoadMotor_d));
	dynamic_switch.insert(std::make_pair("cim:LoadMotor.h", &assign_LoadMotor_h));
	dynamic_switch.insert(std::make_pair("cim:LoadMotor.lfac", &assign_LoadMotor_lfac));
	dynamic_switch.insert(std::make_pair("cim:LoadMotor.lp", &assign_LoadMotor_lp));
	dynamic_switch.insert(std::make_pair("cim:LoadMotor.lpp", &assign_LoadMotor_lpp));
	dynamic_switch.insert(std::make_pair("cim:LoadMotor.ls", &assign_LoadMotor_ls));
	dynamic_switch.insert(std::make_pair("cim:LoadMotor.pfrac", &assign_LoadMotor_pfrac));
	dynamic_switch.insert(std::make_pair("cim:LoadMotor.ra", &assign_LoadMotor_ra));
	dynamic_switch.insert(std::make_pair("cim:LoadMotor.tbkr", &assign_LoadMotor_tbkr));
	dynamic_switch.insert(std::make_pair("cim:LoadMotor.tpo", &assign_LoadMotor_tpo));
	dynamic_switch.insert(std::make_pair("cim:LoadMotor.tppo", &assign_LoadMotor_tppo));
	dynamic_switch.insert(std::make_pair("cim:LoadMotor.tv", &assign_LoadMotor_tv));
	dynamic_switch.insert(std::make_pair("cim:LoadMotor.vt", &assign_LoadMotor_vt));
	dynamic_switch.insert(std::make_pair("cim:LoadStatic.ep1", &assign_LoadStatic_ep1));
	dynamic_switch.insert(std::make_pair("cim:LoadStatic.ep2", &assign_LoadStatic_ep2));
	dynamic_switch.insert(std::make_pair("cim:LoadStatic.ep3", &assign_LoadStatic_ep3));
	dynamic_switch.insert(std::make_pair("cim:LoadStatic.eq1", &assign_LoadStatic_eq1));
	dynamic_switch.insert(std::make_pair("cim:LoadStatic.eq2", &assign_LoadStatic_eq2));
	dynamic_switch.insert(std::make_pair("cim:LoadStatic.eq3", &assign_LoadStatic_eq3));
	dynamic_switch.insert(std::make_pair("cim:LoadStatic.kp1", &assign_LoadStatic_kp1));
	dynamic_switch.insert(std::make_pair("cim:LoadStatic.kp2", &assign_LoadStatic_kp2));
	dynamic_switch.insert(std::make_pair("cim:LoadStatic.kp3", &assign_LoadStatic_kp3));
	dynamic_switch.insert(std::make_pair("cim:LoadStatic.kp4", &assign_LoadStatic_kp4));
	dynamic_switch.insert(std::make_pair("cim:LoadStatic.kpf", &assign_LoadStatic_kpf));
	dynamic_switch.insert(std::make_pair("cim:LoadStatic.kq1", &assign_LoadStatic_kq1));
	dynamic_switch.insert(std::make_pair("cim:LoadStatic.kq2", &assign_LoadStatic_kq2));
	dynamic_switch.insert(std::make_pair("cim:LoadStatic.kq3", &assign_LoadStatic_kq3));
	dynamic_switch.insert(std::make_pair("cim:LoadStatic.kq4", &assign_LoadStatic_kq4));
	dynamic_switch.insert(std::make_pair("cim:LoadStatic.kqf", &assign_LoadStatic_kqf));
	dynamic_switch.insert(std::make_pair("cim:LoadStatic.staticLoadModelType", &assign_LoadStatic_staticLoadModelType));
	dynamic_switch.insert(std::make_pair("cim:MechLoad1.a", &assign_MechLoad1_a));
	dynamic_switch.insert(std::make_pair("cim:MechLoad1.b", &assign_MechLoad1_b));
	dynamic_switch.insert(std::make_pair("cim:MechLoad1.d", &assign_MechLoad1_d));
	dynamic_switch.insert(std::make_pair("cim:MechLoad1.e", &assign_MechLoad1_e));
	dynamic_switch.insert(std::make_pair("cim:OverexcLim2.ifdlim", &assign_OverexcLim2_ifdlim));
	dynamic_switch.insert(std::make_pair("cim:OverexcLim2.koi", &assign_OverexcLim2_koi));
	dynamic_switch.insert(std::make_pair("cim:OverexcLim2.voimax", &assign_OverexcLim2_voimax));
	dynamic_switch.insert(std::make_pair("cim:OverexcLim2.voimin", &assign_OverexcLim2_voimin));
	dynamic_switch.insert(std::make_pair("cim:OverexcLimIEEE.hyst", &assign_OverexcLimIEEE_hyst));
	dynamic_switch.insert(std::make_pair("cim:OverexcLimIEEE.ifdlim", &assign_OverexcLimIEEE_ifdlim));
	dynamic_switch.insert(std::make_pair("cim:OverexcLimIEEE.ifdmax", &assign_OverexcLimIEEE_ifdmax));
	dynamic_switch.insert(std::make_pair("cim:OverexcLimIEEE.itfpu", &assign_OverexcLimIEEE_itfpu));
	dynamic_switch.insert(std::make_pair("cim:OverexcLimIEEE.kcd", &assign_OverexcLimIEEE_kcd));
	dynamic_switch.insert(std::make_pair("cim:OverexcLimIEEE.kramp", &assign_OverexcLimIEEE_kramp));
	dynamic_switch.insert(std::make_pair("cim:OverexcLimX1.efd1", &assign_OverexcLimX1_efd1));
	dynamic_switch.insert(std::make_pair("cim:OverexcLimX1.efd2", &assign_OverexcLimX1_efd2));
	dynamic_switch.insert(std::make_pair("cim:OverexcLimX1.efd3", &assign_OverexcLimX1_efd3));
	dynamic_switch.insert(std::make_pair("cim:OverexcLimX1.efddes", &assign_OverexcLimX1_efddes));
	dynamic_switch.insert(std::make_pair("cim:OverexcLimX1.efdrated", &assign_OverexcLimX1_efdrated));
	dynamic_switch.insert(std::make_pair("cim:OverexcLimX1.kmx", &assign_OverexcLimX1_kmx));
	dynamic_switch.insert(std::make_pair("cim:OverexcLimX1.t1", &assign_OverexcLimX1_t1));
	dynamic_switch.insert(std::make_pair("cim:OverexcLimX1.t2", &assign_OverexcLimX1_t2));
	dynamic_switch.insert(std::make_pair("cim:OverexcLimX1.t3", &assign_OverexcLimX1_t3));
	dynamic_switch.insert(std::make_pair("cim:OverexcLimX1.vlow", &assign_OverexcLimX1_vlow));
	dynamic_switch.insert(std::make_pair("cim:OverexcLimX2.efd1", &assign_OverexcLimX2_efd1));
	dynamic_switch.insert(std::make_pair("cim:OverexcLimX2.efd2", &assign_OverexcLimX2_efd2));
	dynamic_switch.insert(std::make_pair("cim:OverexcLimX2.efd3", &assign_OverexcLimX2_efd3));
	dynamic_switch.insert(std::make_pair("cim:OverexcLimX2.efddes", &assign_OverexcLimX2_efddes));
	dynamic_switch.insert(std::make_pair("cim:OverexcLimX2.efdrated", &assign_OverexcLimX2_efdrated));
	dynamic_switch.insert(std::make_pair("cim:OverexcLimX2.kmx", &assign_OverexcLimX2_kmx));
	dynamic_switch.insert(std::make_pair("cim:OverexcLimX2.m", &assign_OverexcLimX2_m));
	dynamic_switch.insert(std::make_pair("cim:OverexcLimX2.t1", &assign_OverexcLimX2_t1));
	dynamic_switch.insert(std::make_pair("cim:OverexcLimX2.t2", &assign_OverexcLimX2_t2));
	dynamic_switch.insert(std::make_pair("cim:OverexcLimX2.t3", &assign_OverexcLimX2_t3));
	dynamic_switch.insert(std::make_pair("cim:OverexcLimX2.vlow", &assign_OverexcLimX2_vlow));
	dynamic_switch.insert(std::make_pair("cim:PFVArType1IEEEPFController.ovex", &assign_PFVArType1IEEEPFController_ovex));
	dynamic_switch.insert(std::make_pair("cim:PFVArType1IEEEPFController.tpfc", &assign_PFVArType1IEEEPFController_tpfc));
	dynamic_switch.insert(std::make_pair("cim:PFVArType1IEEEPFController.vitmin", &assign_PFVArType1IEEEPFController_vitmin));
	dynamic_switch.insert(std::make_pair("cim:PFVArType1IEEEPFController.vpf", &assign_PFVArType1IEEEPFController_vpf));
	dynamic_switch.insert(std::make_pair("cim:PFVArType1IEEEPFController.vpfcbw", &assign_PFVArType1IEEEPFController_vpfcbw));
	dynamic_switch.insert(std::make_pair("cim:PFVArType1IEEEPFController.vpfref", &assign_PFVArType1IEEEPFController_vpfref));
	dynamic_switch.insert(std::make_pair("cim:PFVArType1IEEEPFController.vvtmax", &assign_PFVArType1IEEEPFController_vvtmax));
	dynamic_switch.insert(std::make_pair("cim:PFVArType1IEEEPFController.vvtmin", &assign_PFVArType1IEEEPFController_vvtmin));
	dynamic_switch.insert(std::make_pair("cim:PFVArType1IEEEVArController.tvarc", &assign_PFVArType1IEEEVArController_tvarc));
	dynamic_switch.insert(std::make_pair("cim:PFVArType1IEEEVArController.vvar", &assign_PFVArType1IEEEVArController_vvar));
	dynamic_switch.insert(std::make_pair("cim:PFVArType1IEEEVArController.vvarcbw", &assign_PFVArType1IEEEVArController_vvarcbw));
	dynamic_switch.insert(std::make_pair("cim:PFVArType1IEEEVArController.vvarref", &assign_PFVArType1IEEEVArController_vvarref));
	dynamic_switch.insert(std::make_pair("cim:PFVArType1IEEEVArController.vvtmax", &assign_PFVArType1IEEEVArController_vvtmax));
	dynamic_switch.insert(std::make_pair("cim:PFVArType1IEEEVArController.vvtmin", &assign_PFVArType1IEEEVArController_vvtmin));
	dynamic_switch.insert(std::make_pair("cim:PFVArType2Common1.j", &assign_PFVArType2Common1_j));
	dynamic_switch.insert(std::make_pair("cim:PFVArType2Common1.ki", &assign_PFVArType2Common1_ki));
	dynamic_switch.insert(std::make_pair("cim:PFVArType2Common1.kp", &assign_PFVArType2Common1_kp));
	dynamic_switch.insert(std::make_pair("cim:PFVArType2Common1.max", &assign_PFVArType2Common1_max));
	dynamic_switch.insert(std::make_pair("cim:PFVArType2Common1.ref", &assign_PFVArType2Common1_ref));
	dynamic_switch.insert(std::make_pair("cim:PFVArType2IEEEPFController.exlon", &assign_PFVArType2IEEEPFController_exlon));
	dynamic_switch.insert(std::make_pair("cim:PFVArType2IEEEPFController.ki", &assign_PFVArType2IEEEPFController_ki));
	dynamic_switch.insert(std::make_pair("cim:PFVArType2IEEEPFController.kp", &assign_PFVArType2IEEEPFController_kp));
	dynamic_switch.insert(std::make_pair("cim:PFVArType2IEEEPFController.pfref", &assign_PFVArType2IEEEPFController_pfref));
	dynamic_switch.insert(std::make_pair("cim:PFVArType2IEEEPFController.vclmt", &assign_PFVArType2IEEEPFController_vclmt));
	dynamic_switch.insert(std::make_pair("cim:PFVArType2IEEEPFController.vref", &assign_PFVArType2IEEEPFController_vref));
	dynamic_switch.insert(std::make_pair("cim:PFVArType2IEEEPFController.vs", &assign_PFVArType2IEEEPFController_vs));
	dynamic_switch.insert(std::make_pair("cim:PFVArType2IEEEVArController.exlon", &assign_PFVArType2IEEEVArController_exlon));
	dynamic_switch.insert(std::make_pair("cim:PFVArType2IEEEVArController.ki", &assign_PFVArType2IEEEVArController_ki));
	dynamic_switch.insert(std::make_pair("cim:PFVArType2IEEEVArController.kp", &assign_PFVArType2IEEEVArController_kp));
	dynamic_switch.insert(std::make_pair("cim:PFVArType2IEEEVArController.qref", &assign_PFVArType2IEEEVArController_qref));
	dynamic_switch.insert(std::make_pair("cim:PFVArType2IEEEVArController.vclmt", &assign_PFVArType2IEEEVArController_vclmt));
	dynamic_switch.insert(std::make_pair("cim:PFVArType2IEEEVArController.vref", &assign_PFVArType2IEEEVArController_vref));
	dynamic_switch.insert(std::make_pair("cim:PFVArType2IEEEVArController.vs", &assign_PFVArType2IEEEVArController_vs));
	dynamic_switch.insert(std::make_pair("cim:Pss1.kf", &assign_Pss1_kf));
	dynamic_switch.insert(std::make_pair("cim:Pss1.kpe", &assign_Pss1_kpe));
	dynamic_switch.insert(std::make_pair("cim:Pss1.ks", &assign_Pss1_ks));
	dynamic_switch.insert(std::make_pair("cim:Pss1.kw", &assign_Pss1_kw));
	dynamic_switch.insert(std::make_pair("cim:Pss1.pmin", &assign_Pss1_pmin));
	dynamic_switch.insert(std::make_pair("cim:Pss1.t10", &assign_Pss1_t10));
	dynamic_switch.insert(std::make_pair("cim:Pss1.t5", &assign_Pss1_t5));
	dynamic_switch.insert(std::make_pair("cim:Pss1.t6", &assign_Pss1_t6));
	dynamic_switch.insert(std::make_pair("cim:Pss1.t7", &assign_Pss1_t7));
	dynamic_switch.insert(std::make_pair("cim:Pss1.t8", &assign_Pss1_t8));
	dynamic_switch.insert(std::make_pair("cim:Pss1.t9", &assign_Pss1_t9));
	dynamic_switch.insert(std::make_pair("cim:Pss1.tpe", &assign_Pss1_tpe));
	dynamic_switch.insert(std::make_pair("cim:Pss1.vadat", &assign_Pss1_vadat));
	dynamic_switch.insert(std::make_pair("cim:Pss1.vsmn", &assign_Pss1_vsmn));
	dynamic_switch.insert(std::make_pair("cim:Pss1.vsmx", &assign_Pss1_vsmx));
	dynamic_switch.insert(std::make_pair("cim:Pss1A.a1", &assign_Pss1A_a1));
	dynamic_switch.insert(std::make_pair("cim:Pss1A.a2", &assign_Pss1A_a2));
	dynamic_switch.insert(std::make_pair("cim:Pss1A.a3", &assign_Pss1A_a3));
	dynamic_switch.insert(std::make_pair("cim:Pss1A.a4", &assign_Pss1A_a4));
	dynamic_switch.insert(std::make_pair("cim:Pss1A.a5", &assign_Pss1A_a5));
	dynamic_switch.insert(std::make_pair("cim:Pss1A.a6", &assign_Pss1A_a6));
	dynamic_switch.insert(std::make_pair("cim:Pss1A.a7", &assign_Pss1A_a7));
	dynamic_switch.insert(std::make_pair("cim:Pss1A.a8", &assign_Pss1A_a8));
	dynamic_switch.insert(std::make_pair("cim:Pss1A.inputSignalType", &assign_Pss1A_inputSignalType));
	dynamic_switch.insert(std::make_pair("cim:Pss1A.kd", &assign_Pss1A_kd));
	dynamic_switch.insert(std::make_pair("cim:Pss1A.ks", &assign_Pss1A_ks));
	dynamic_switch.insert(std::make_pair("cim:Pss1A.t1", &assign_Pss1A_t1));
	dynamic_switch.insert(std::make_pair("cim:Pss1A.t2", &assign_Pss1A_t2));
	dynamic_switch.insert(std::make_pair("cim:Pss1A.t3", &assign_Pss1A_t3));
	dynamic_switch.insert(std::make_pair("cim:Pss1A.t4", &assign_Pss1A_t4));
	dynamic_switch.insert(std::make_pair("cim:Pss1A.t5", &assign_Pss1A_t5));
	dynamic_switch.insert(std::make_pair("cim:Pss1A.t6", &assign_Pss1A_t6));
	dynamic_switch.insert(std::make_pair("cim:Pss1A.tdelay", &assign_Pss1A_tdelay));
	dynamic_switch.insert(std::make_pair("cim:Pss1A.vcl", &assign_Pss1A_vcl));
	dynamic_switch.insert(std::make_pair("cim:Pss1A.vcu", &assign_Pss1A_vcu));
	dynamic_switch.insert(std::make_pair("cim:Pss1A.vrmax", &assign_Pss1A_vrmax));
	dynamic_switch.insert(std::make_pair("cim:Pss1A.vrmin", &assign_Pss1A_vrmin));
	dynamic_switch.insert(std::make_pair("cim:Pss2B.a", &assign_Pss2B_a));
	dynamic_switch.insert(std::make_pair("cim:Pss2B.inputSignal1Type", &assign_Pss2B_inputSignal1Type));
	dynamic_switch.insert(std::make_pair("cim:Pss2B.inputSignal2Type", &assign_Pss2B_inputSignal2Type));
	dynamic_switch.insert(std::make_pair("cim:Pss2B.ks1", &assign_Pss2B_ks1));
	dynamic_switch.insert(std::make_pair("cim:Pss2B.ks2", &assign_Pss2B_ks2));
	dynamic_switch.insert(std::make_pair("cim:Pss2B.ks3", &assign_Pss2B_ks3));
	dynamic_switch.insert(std::make_pair("cim:Pss2B.ks4", &assign_Pss2B_ks4));
	dynamic_switch.insert(std::make_pair("cim:Pss2B.m", &assign_Pss2B_m));
	dynamic_switch.insert(std::make_pair("cim:Pss2B.n", &assign_Pss2B_n));
	dynamic_switch.insert(std::make_pair("cim:Pss2B.t1", &assign_Pss2B_t1));
	dynamic_switch.insert(std::make_pair("cim:Pss2B.t10", &assign_Pss2B_t10));
	dynamic_switch.insert(std::make_pair("cim:Pss2B.t11", &assign_Pss2B_t11));
	dynamic_switch.insert(std::make_pair("cim:Pss2B.t2", &assign_Pss2B_t2));
	dynamic_switch.insert(std::make_pair("cim:Pss2B.t3", &assign_Pss2B_t3));
	dynamic_switch.insert(std::make_pair("cim:Pss2B.t4", &assign_Pss2B_t4));
	dynamic_switch.insert(std::make_pair("cim:Pss2B.t6", &assign_Pss2B_t6));
	dynamic_switch.insert(std::make_pair("cim:Pss2B.t7", &assign_Pss2B_t7));
	dynamic_switch.insert(std::make_pair("cim:Pss2B.t8", &assign_Pss2B_t8));
	dynamic_switch.insert(std::make_pair("cim:Pss2B.t9", &assign_Pss2B_t9));
	dynamic_switch.insert(std::make_pair("cim:Pss2B.ta", &assign_Pss2B_ta));
	dynamic_switch.insert(std::make_pair("cim:Pss2B.tb", &assign_Pss2B_tb));
	dynamic_switch.insert(std::make_pair("cim:Pss2B.tw1", &assign_Pss2B_tw1));
	dynamic_switch.insert(std::make_pair("cim:Pss2B.tw2", &assign_Pss2B_tw2));
	dynamic_switch.insert(std::make_pair("cim:Pss2B.tw3", &assign_Pss2B_tw3));
	dynamic_switch.insert(std::make_pair("cim:Pss2B.tw4", &assign_Pss2B_tw4));
	dynamic_switch.insert(std::make_pair("cim:Pss2B.vsi1max", &assign_Pss2B_vsi1max));
	dynamic_switch.insert(std::make_pair("cim:Pss2B.vsi1min", &assign_Pss2B_vsi1min));
	dynamic_switch.insert(std::make_pair("cim:Pss2B.vsi2max", &assign_Pss2B_vsi2max));
	dynamic_switch.insert(std::make_pair("cim:Pss2B.vsi2min", &assign_Pss2B_vsi2min));
	dynamic_switch.insert(std::make_pair("cim:Pss2B.vstmax", &assign_Pss2B_vstmax));
	dynamic_switch.insert(std::make_pair("cim:Pss2B.vstmin", &assign_Pss2B_vstmin));
	dynamic_switch.insert(std::make_pair("cim:Pss2ST.inputSignal1Type", &assign_Pss2ST_inputSignal1Type));
	dynamic_switch.insert(std::make_pair("cim:Pss2ST.inputSignal2Type", &assign_Pss2ST_inputSignal2Type));
	dynamic_switch.insert(std::make_pair("cim:Pss2ST.k1", &assign_Pss2ST_k1));
	dynamic_switch.insert(std::make_pair("cim:Pss2ST.k2", &assign_Pss2ST_k2));
	dynamic_switch.insert(std::make_pair("cim:Pss2ST.lsmax", &assign_Pss2ST_lsmax));
	dynamic_switch.insert(std::make_pair("cim:Pss2ST.lsmin", &assign_Pss2ST_lsmin));
	dynamic_switch.insert(std::make_pair("cim:Pss2ST.t1", &assign_Pss2ST_t1));
	dynamic_switch.insert(std::make_pair("cim:Pss2ST.t10", &assign_Pss2ST_t10));
	dynamic_switch.insert(std::make_pair("cim:Pss2ST.t2", &assign_Pss2ST_t2));
	dynamic_switch.insert(std::make_pair("cim:Pss2ST.t3", &assign_Pss2ST_t3));
	dynamic_switch.insert(std::make_pair("cim:Pss2ST.t4", &assign_Pss2ST_t4));
	dynamic_switch.insert(std::make_pair("cim:Pss2ST.t5", &assign_Pss2ST_t5));
	dynamic_switch.insert(std::make_pair("cim:Pss2ST.t6", &assign_Pss2ST_t6));
	dynamic_switch.insert(std::make_pair("cim:Pss2ST.t7", &assign_Pss2ST_t7));
	dynamic_switch.insert(std::make_pair("cim:Pss2ST.t8", &assign_Pss2ST_t8));
	dynamic_switch.insert(std::make_pair("cim:Pss2ST.t9", &assign_Pss2ST_t9));
	dynamic_switch.insert(std::make_pair("cim:Pss2ST.vcl", &assign_Pss2ST_vcl));
	dynamic_switch.insert(std::make_pair("cim:Pss2ST.vcu", &assign_Pss2ST_vcu));
	dynamic_switch.insert(std::make_pair("cim:Pss5.ctw2", &assign_Pss5_ctw2));
	dynamic_switch.insert(std::make_pair("cim:Pss5.deadband", &assign_Pss5_deadband));
	dynamic_switch.insert(std::make_pair("cim:Pss5.isfreq", &assign_Pss5_isfreq));
	dynamic_switch.insert(std::make_pair("cim:Pss5.kf", &assign_Pss5_kf));
	dynamic_switch.insert(std::make_pair("cim:Pss5.kpe", &assign_Pss5_kpe));
	dynamic_switch.insert(std::make_pair("cim:Pss5.kpss", &assign_Pss5_kpss));
	dynamic_switch.insert(std::make_pair("cim:Pss5.pmm", &assign_Pss5_pmm));
	dynamic_switch.insert(std::make_pair("cim:Pss5.tl1", &assign_Pss5_tl1));
	dynamic_switch.insert(std::make_pair("cim:Pss5.tl2", &assign_Pss5_tl2));
	dynamic_switch.insert(std::make_pair("cim:Pss5.tl3", &assign_Pss5_tl3));
	dynamic_switch.insert(std::make_pair("cim:Pss5.tl4", &assign_Pss5_tl4));
	dynamic_switch.insert(std::make_pair("cim:Pss5.tpe", &assign_Pss5_tpe));
	dynamic_switch.insert(std::make_pair("cim:Pss5.tw1", &assign_Pss5_tw1));
	dynamic_switch.insert(std::make_pair("cim:Pss5.tw2", &assign_Pss5_tw2));
	dynamic_switch.insert(std::make_pair("cim:Pss5.vadat", &assign_Pss5_vadat));
	dynamic_switch.insert(std::make_pair("cim:Pss5.vsmn", &assign_Pss5_vsmn));
	dynamic_switch.insert(std::make_pair("cim:Pss5.vsmx", &assign_Pss5_vsmx));
	dynamic_switch.insert(std::make_pair("cim:PssELIN2.apss", &assign_PssELIN2_apss));
	dynamic_switch.insert(std::make_pair("cim:PssELIN2.ks1", &assign_PssELIN2_ks1));
	dynamic_switch.insert(std::make_pair("cim:PssELIN2.ks2", &assign_PssELIN2_ks2));
	dynamic_switch.insert(std::make_pair("cim:PssELIN2.ppss", &assign_PssELIN2_ppss));
	dynamic_switch.insert(std::make_pair("cim:PssELIN2.psslim", &assign_PssELIN2_psslim));
	dynamic_switch.insert(std::make_pair("cim:PssELIN2.ts1", &assign_PssELIN2_ts1));
	dynamic_switch.insert(std::make_pair("cim:PssELIN2.ts2", &assign_PssELIN2_ts2));
	dynamic_switch.insert(std::make_pair("cim:PssELIN2.ts3", &assign_PssELIN2_ts3));
	dynamic_switch.insert(std::make_pair("cim:PssELIN2.ts4", &assign_PssELIN2_ts4));
	dynamic_switch.insert(std::make_pair("cim:PssELIN2.ts5", &assign_PssELIN2_ts5));
	dynamic_switch.insert(std::make_pair("cim:PssELIN2.ts6", &assign_PssELIN2_ts6));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE1A.a1", &assign_PssIEEE1A_a1));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE1A.a2", &assign_PssIEEE1A_a2));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE1A.inputSignalType", &assign_PssIEEE1A_inputSignalType));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE1A.ks", &assign_PssIEEE1A_ks));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE1A.t1", &assign_PssIEEE1A_t1));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE1A.t2", &assign_PssIEEE1A_t2));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE1A.t3", &assign_PssIEEE1A_t3));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE1A.t4", &assign_PssIEEE1A_t4));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE1A.t5", &assign_PssIEEE1A_t5));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE1A.t6", &assign_PssIEEE1A_t6));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE1A.vrmax", &assign_PssIEEE1A_vrmax));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE1A.vrmin", &assign_PssIEEE1A_vrmin));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE2B.inputSignal1Type", &assign_PssIEEE2B_inputSignal1Type));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE2B.inputSignal2Type", &assign_PssIEEE2B_inputSignal2Type));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE2B.ks1", &assign_PssIEEE2B_ks1));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE2B.ks2", &assign_PssIEEE2B_ks2));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE2B.ks3", &assign_PssIEEE2B_ks3));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE2B.m", &assign_PssIEEE2B_m));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE2B.n", &assign_PssIEEE2B_n));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE2B.t1", &assign_PssIEEE2B_t1));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE2B.t10", &assign_PssIEEE2B_t10));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE2B.t11", &assign_PssIEEE2B_t11));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE2B.t2", &assign_PssIEEE2B_t2));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE2B.t3", &assign_PssIEEE2B_t3));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE2B.t4", &assign_PssIEEE2B_t4));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE2B.t6", &assign_PssIEEE2B_t6));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE2B.t7", &assign_PssIEEE2B_t7));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE2B.t8", &assign_PssIEEE2B_t8));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE2B.t9", &assign_PssIEEE2B_t9));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE2B.tw1", &assign_PssIEEE2B_tw1));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE2B.tw2", &assign_PssIEEE2B_tw2));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE2B.tw3", &assign_PssIEEE2B_tw3));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE2B.tw4", &assign_PssIEEE2B_tw4));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE2B.vsi1max", &assign_PssIEEE2B_vsi1max));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE2B.vsi1min", &assign_PssIEEE2B_vsi1min));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE2B.vsi2max", &assign_PssIEEE2B_vsi2max));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE2B.vsi2min", &assign_PssIEEE2B_vsi2min));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE2B.vstmax", &assign_PssIEEE2B_vstmax));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE2B.vstmin", &assign_PssIEEE2B_vstmin));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE3B.a1", &assign_PssIEEE3B_a1));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE3B.a2", &assign_PssIEEE3B_a2));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE3B.a3", &assign_PssIEEE3B_a3));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE3B.a4", &assign_PssIEEE3B_a4));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE3B.a5", &assign_PssIEEE3B_a5));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE3B.a6", &assign_PssIEEE3B_a6));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE3B.a7", &assign_PssIEEE3B_a7));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE3B.a8", &assign_PssIEEE3B_a8));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE3B.inputSignal1Type", &assign_PssIEEE3B_inputSignal1Type));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE3B.inputSignal2Type", &assign_PssIEEE3B_inputSignal2Type));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE3B.ks1", &assign_PssIEEE3B_ks1));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE3B.ks2", &assign_PssIEEE3B_ks2));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE3B.t1", &assign_PssIEEE3B_t1));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE3B.t2", &assign_PssIEEE3B_t2));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE3B.tw1", &assign_PssIEEE3B_tw1));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE3B.tw2", &assign_PssIEEE3B_tw2));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE3B.tw3", &assign_PssIEEE3B_tw3));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE3B.vstmax", &assign_PssIEEE3B_vstmax));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE3B.vstmin", &assign_PssIEEE3B_vstmin));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.bwh1", &assign_PssIEEE4B_bwh1));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.bwh2", &assign_PssIEEE4B_bwh2));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.bwl1", &assign_PssIEEE4B_bwl1));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.bwl2", &assign_PssIEEE4B_bwl2));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.kh", &assign_PssIEEE4B_kh));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.kh1", &assign_PssIEEE4B_kh1));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.kh11", &assign_PssIEEE4B_kh11));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.kh17", &assign_PssIEEE4B_kh17));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.kh2", &assign_PssIEEE4B_kh2));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.ki", &assign_PssIEEE4B_ki));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.ki1", &assign_PssIEEE4B_ki1));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.ki11", &assign_PssIEEE4B_ki11));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.ki17", &assign_PssIEEE4B_ki17));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.ki2", &assign_PssIEEE4B_ki2));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.kl", &assign_PssIEEE4B_kl));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.kl1", &assign_PssIEEE4B_kl1));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.kl11", &assign_PssIEEE4B_kl11));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.kl17", &assign_PssIEEE4B_kl17));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.kl2", &assign_PssIEEE4B_kl2));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.omeganh1", &assign_PssIEEE4B_omeganh1));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.omeganh2", &assign_PssIEEE4B_omeganh2));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.omeganl1", &assign_PssIEEE4B_omeganl1));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.omeganl2", &assign_PssIEEE4B_omeganl2));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.th1", &assign_PssIEEE4B_th1));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.th10", &assign_PssIEEE4B_th10));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.th11", &assign_PssIEEE4B_th11));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.th12", &assign_PssIEEE4B_th12));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.th2", &assign_PssIEEE4B_th2));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.th3", &assign_PssIEEE4B_th3));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.th4", &assign_PssIEEE4B_th4));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.th5", &assign_PssIEEE4B_th5));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.th6", &assign_PssIEEE4B_th6));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.th7", &assign_PssIEEE4B_th7));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.th8", &assign_PssIEEE4B_th8));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.th9", &assign_PssIEEE4B_th9));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.ti1", &assign_PssIEEE4B_ti1));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.ti10", &assign_PssIEEE4B_ti10));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.ti11", &assign_PssIEEE4B_ti11));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.ti12", &assign_PssIEEE4B_ti12));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.ti2", &assign_PssIEEE4B_ti2));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.ti3", &assign_PssIEEE4B_ti3));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.ti4", &assign_PssIEEE4B_ti4));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.ti5", &assign_PssIEEE4B_ti5));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.ti6", &assign_PssIEEE4B_ti6));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.ti7", &assign_PssIEEE4B_ti7));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.ti8", &assign_PssIEEE4B_ti8));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.ti9", &assign_PssIEEE4B_ti9));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.tl1", &assign_PssIEEE4B_tl1));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.tl10", &assign_PssIEEE4B_tl10));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.tl11", &assign_PssIEEE4B_tl11));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.tl12", &assign_PssIEEE4B_tl12));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.tl2", &assign_PssIEEE4B_tl2));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.tl3", &assign_PssIEEE4B_tl3));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.tl4", &assign_PssIEEE4B_tl4));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.tl5", &assign_PssIEEE4B_tl5));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.tl6", &assign_PssIEEE4B_tl6));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.tl7", &assign_PssIEEE4B_tl7));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.tl8", &assign_PssIEEE4B_tl8));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.tl9", &assign_PssIEEE4B_tl9));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.vhmax", &assign_PssIEEE4B_vhmax));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.vhmin", &assign_PssIEEE4B_vhmin));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.vimax", &assign_PssIEEE4B_vimax));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.vimin", &assign_PssIEEE4B_vimin));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.vlmax", &assign_PssIEEE4B_vlmax));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.vlmin", &assign_PssIEEE4B_vlmin));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.vstmax", &assign_PssIEEE4B_vstmax));
	dynamic_switch.insert(std::make_pair("cim:PssIEEE4B.vstmin", &assign_PssIEEE4B_vstmin));
	dynamic_switch.insert(std::make_pair("cim:PssPTIST1.dtc", &assign_PssPTIST1_dtc));
	dynamic_switch.insert(std::make_pair("cim:PssPTIST1.dtf", &assign_PssPTIST1_dtf));
	dynamic_switch.insert(std::make_pair("cim:PssPTIST1.dtp", &assign_PssPTIST1_dtp));
	dynamic_switch.insert(std::make_pair("cim:PssPTIST1.k", &assign_PssPTIST1_k));
	dynamic_switch.insert(std::make_pair("cim:PssPTIST1.m", &assign_PssPTIST1_m));
	dynamic_switch.insert(std::make_pair("cim:PssPTIST1.t1", &assign_PssPTIST1_t1));
	dynamic_switch.insert(std::make_pair("cim:PssPTIST1.t2", &assign_PssPTIST1_t2));
	dynamic_switch.insert(std::make_pair("cim:PssPTIST1.t3", &assign_PssPTIST1_t3));
	dynamic_switch.insert(std::make_pair("cim:PssPTIST1.t4", &assign_PssPTIST1_t4));
	dynamic_switch.insert(std::make_pair("cim:PssPTIST1.tf", &assign_PssPTIST1_tf));
	dynamic_switch.insert(std::make_pair("cim:PssPTIST1.tp", &assign_PssPTIST1_tp));
	dynamic_switch.insert(std::make_pair("cim:PssPTIST3.a0", &assign_PssPTIST3_a0));
	dynamic_switch.insert(std::make_pair("cim:PssPTIST3.a1", &assign_PssPTIST3_a1));
	dynamic_switch.insert(std::make_pair("cim:PssPTIST3.a2", &assign_PssPTIST3_a2));
	dynamic_switch.insert(std::make_pair("cim:PssPTIST3.a3", &assign_PssPTIST3_a3));
	dynamic_switch.insert(std::make_pair("cim:PssPTIST3.a4", &assign_PssPTIST3_a4));
	dynamic_switch.insert(std::make_pair("cim:PssPTIST3.a5", &assign_PssPTIST3_a5));
	dynamic_switch.insert(std::make_pair("cim:PssPTIST3.al", &assign_PssPTIST3_al));
	dynamic_switch.insert(std::make_pair("cim:PssPTIST3.athres", &assign_PssPTIST3_athres));
	dynamic_switch.insert(std::make_pair("cim:PssPTIST3.b0", &assign_PssPTIST3_b0));
	dynamic_switch.insert(std::make_pair("cim:PssPTIST3.b1", &assign_PssPTIST3_b1));
	dynamic_switch.insert(std::make_pair("cim:PssPTIST3.b2", &assign_PssPTIST3_b2));
	dynamic_switch.insert(std::make_pair("cim:PssPTIST3.b3", &assign_PssPTIST3_b3));
	dynamic_switch.insert(std::make_pair("cim:PssPTIST3.b4", &assign_PssPTIST3_b4));
	dynamic_switch.insert(std::make_pair("cim:PssPTIST3.b5", &assign_PssPTIST3_b5));
	dynamic_switch.insert(std::make_pair("cim:PssPTIST3.dl", &assign_PssPTIST3_dl));
	dynamic_switch.insert(std::make_pair("cim:PssPTIST3.dtc", &assign_PssPTIST3_dtc));
	dynamic_switch.insert(std::make_pair("cim:PssPTIST3.dtf", &assign_PssPTIST3_dtf));
	dynamic_switch.insert(std::make_pair("cim:PssPTIST3.dtp", &assign_PssPTIST3_dtp));
	dynamic_switch.insert(std::make_pair("cim:PssPTIST3.isw", &assign_PssPTIST3_isw));
	dynamic_switch.insert(std::make_pair("cim:PssPTIST3.k", &assign_PssPTIST3_k));
	dynamic_switch.insert(std::make_pair("cim:PssPTIST3.lthres", &assign_PssPTIST3_lthres));
	dynamic_switch.insert(std::make_pair("cim:PssPTIST3.m", &assign_PssPTIST3_m));
	dynamic_switch.insert(std::make_pair("cim:PssPTIST3.nav", &assign_PssPTIST3_nav));
	dynamic_switch.insert(std::make_pair("cim:PssPTIST3.ncl", &assign_PssPTIST3_ncl));
	dynamic_switch.insert(std::make_pair("cim:PssPTIST3.ncr", &assign_PssPTIST3_ncr));
	dynamic_switch.insert(std::make_pair("cim:PssPTIST3.pmin", &assign_PssPTIST3_pmin));
	dynamic_switch.insert(std::make_pair("cim:PssPTIST3.t1", &assign_PssPTIST3_t1));
	dynamic_switch.insert(std::make_pair("cim:PssPTIST3.t2", &assign_PssPTIST3_t2));
	dynamic_switch.insert(std::make_pair("cim:PssPTIST3.t3", &assign_PssPTIST3_t3));
	dynamic_switch.insert(std::make_pair("cim:PssPTIST3.t4", &assign_PssPTIST3_t4));
	dynamic_switch.insert(std::make_pair("cim:PssPTIST3.t5", &assign_PssPTIST3_t5));
	dynamic_switch.insert(std::make_pair("cim:PssPTIST3.t6", &assign_PssPTIST3_t6));
	dynamic_switch.insert(std::make_pair("cim:PssPTIST3.tf", &assign_PssPTIST3_tf));
	dynamic_switch.insert(std::make_pair("cim:PssPTIST3.tp", &assign_PssPTIST3_tp));
	dynamic_switch.insert(std::make_pair("cim:PssSB4.kx", &assign_PssSB4_kx));
	dynamic_switch.insert(std::make_pair("cim:PssSB4.ta", &assign_PssSB4_ta));
	dynamic_switch.insert(std::make_pair("cim:PssSB4.tb", &assign_PssSB4_tb));
	dynamic_switch.insert(std::make_pair("cim:PssSB4.tc", &assign_PssSB4_tc));
	dynamic_switch.insert(std::make_pair("cim:PssSB4.td", &assign_PssSB4_td));
	dynamic_switch.insert(std::make_pair("cim:PssSB4.te", &assign_PssSB4_te));
	dynamic_switch.insert(std::make_pair("cim:PssSB4.tt", &assign_PssSB4_tt));
	dynamic_switch.insert(std::make_pair("cim:PssSB4.tx1", &assign_PssSB4_tx1));
	dynamic_switch.insert(std::make_pair("cim:PssSB4.tx2", &assign_PssSB4_tx2));
	dynamic_switch.insert(std::make_pair("cim:PssSB4.vsmax", &assign_PssSB4_vsmax));
	dynamic_switch.insert(std::make_pair("cim:PssSB4.vsmin", &assign_PssSB4_vsmin));
	dynamic_switch.insert(std::make_pair("cim:PssSH.k", &assign_PssSH_k));
	dynamic_switch.insert(std::make_pair("cim:PssSH.k0", &assign_PssSH_k0));
	dynamic_switch.insert(std::make_pair("cim:PssSH.k1", &assign_PssSH_k1));
	dynamic_switch.insert(std::make_pair("cim:PssSH.k2", &assign_PssSH_k2));
	dynamic_switch.insert(std::make_pair("cim:PssSH.k3", &assign_PssSH_k3));
	dynamic_switch.insert(std::make_pair("cim:PssSH.k4", &assign_PssSH_k4));
	dynamic_switch.insert(std::make_pair("cim:PssSH.t1", &assign_PssSH_t1));
	dynamic_switch.insert(std::make_pair("cim:PssSH.t2", &assign_PssSH_t2));
	dynamic_switch.insert(std::make_pair("cim:PssSH.t3", &assign_PssSH_t3));
	dynamic_switch.insert(std::make_pair("cim:PssSH.t4", &assign_PssSH_t4));
	dynamic_switch.insert(std::make_pair("cim:PssSH.td", &assign_PssSH_td));
	dynamic_switch.insert(std::make_pair("cim:PssSH.vsmax", &assign_PssSH_vsmax));
	dynamic_switch.insert(std::make_pair("cim:PssSH.vsmin", &assign_PssSH_vsmin));
	dynamic_switch.insert(std::make_pair("cim:PssSK.k1", &assign_PssSK_k1));
	dynamic_switch.insert(std::make_pair("cim:PssSK.k2", &assign_PssSK_k2));
	dynamic_switch.insert(std::make_pair("cim:PssSK.k3", &assign_PssSK_k3));
	dynamic_switch.insert(std::make_pair("cim:PssSK.t1", &assign_PssSK_t1));
	dynamic_switch.insert(std::make_pair("cim:PssSK.t2", &assign_PssSK_t2));
	dynamic_switch.insert(std::make_pair("cim:PssSK.t3", &assign_PssSK_t3));
	dynamic_switch.insert(std::make_pair("cim:PssSK.t4", &assign_PssSK_t4));
	dynamic_switch.insert(std::make_pair("cim:PssSK.t5", &assign_PssSK_t5));
	dynamic_switch.insert(std::make_pair("cim:PssSK.t6", &assign_PssSK_t6));
	dynamic_switch.insert(std::make_pair("cim:PssSK.vsmax", &assign_PssSK_vsmax));
	dynamic_switch.insert(std::make_pair("cim:PssSK.vsmin", &assign_PssSK_vsmin));
	dynamic_switch.insert(std::make_pair("cim:PssWECC.inputSignal1Type", &assign_PssWECC_inputSignal1Type));
	dynamic_switch.insert(std::make_pair("cim:PssWECC.inputSignal2Type", &assign_PssWECC_inputSignal2Type));
	dynamic_switch.insert(std::make_pair("cim:PssWECC.k1", &assign_PssWECC_k1));
	dynamic_switch.insert(std::make_pair("cim:PssWECC.k2", &assign_PssWECC_k2));
	dynamic_switch.insert(std::make_pair("cim:PssWECC.t1", &assign_PssWECC_t1));
	dynamic_switch.insert(std::make_pair("cim:PssWECC.t10", &assign_PssWECC_t10));
	dynamic_switch.insert(std::make_pair("cim:PssWECC.t2", &assign_PssWECC_t2));
	dynamic_switch.insert(std::make_pair("cim:PssWECC.t3", &assign_PssWECC_t3));
	dynamic_switch.insert(std::make_pair("cim:PssWECC.t4", &assign_PssWECC_t4));
	dynamic_switch.insert(std::make_pair("cim:PssWECC.t5", &assign_PssWECC_t5));
	dynamic_switch.insert(std::make_pair("cim:PssWECC.t6", &assign_PssWECC_t6));
	dynamic_switch.insert(std::make_pair("cim:PssWECC.t7", &assign_PssWECC_t7));
	dynamic_switch.insert(std::make_pair("cim:PssWECC.t8", &assign_PssWECC_t8));
	dynamic_switch.insert(std::make_pair("cim:PssWECC.t9", &assign_PssWECC_t9));
	dynamic_switch.insert(std::make_pair("cim:PssWECC.vcl", &assign_PssWECC_vcl));
	dynamic_switch.insert(std::make_pair("cim:PssWECC.vcu", &assign_PssWECC_vcu));
	dynamic_switch.insert(std::make_pair("cim:PssWECC.vsmax", &assign_PssWECC_vsmax));
	dynamic_switch.insert(std::make_pair("cim:PssWECC.vsmin", &assign_PssWECC_vsmin));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachineDetailed.efdBaseRatio", &assign_SynchronousMachineDetailed_efdBaseRatio));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachineDetailed.ifdBaseType", &assign_SynchronousMachineDetailed_ifdBaseType));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachineDetailed.ifdBaseValue", &assign_SynchronousMachineDetailed_ifdBaseValue));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachineDetailed.saturationFactor120QAxis", &assign_SynchronousMachineDetailed_saturationFactor120QAxis));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachineDetailed.saturationFactorQAxis", &assign_SynchronousMachineDetailed_saturationFactorQAxis));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachineEquivalentCircuit.r1d", &assign_SynchronousMachineEquivalentCircuit_r1d));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachineEquivalentCircuit.r1q", &assign_SynchronousMachineEquivalentCircuit_r1q));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachineEquivalentCircuit.r2q", &assign_SynchronousMachineEquivalentCircuit_r2q));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachineEquivalentCircuit.rfd", &assign_SynchronousMachineEquivalentCircuit_rfd));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachineEquivalentCircuit.x1d", &assign_SynchronousMachineEquivalentCircuit_x1d));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachineEquivalentCircuit.x1q", &assign_SynchronousMachineEquivalentCircuit_x1q));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachineEquivalentCircuit.x2q", &assign_SynchronousMachineEquivalentCircuit_x2q));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachineEquivalentCircuit.xad", &assign_SynchronousMachineEquivalentCircuit_xad));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachineEquivalentCircuit.xaq", &assign_SynchronousMachineEquivalentCircuit_xaq));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachineEquivalentCircuit.xf1d", &assign_SynchronousMachineEquivalentCircuit_xf1d));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachineEquivalentCircuit.xfd", &assign_SynchronousMachineEquivalentCircuit_xfd));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachineTimeConstantReactance.ks", &assign_SynchronousMachineTimeConstantReactance_ks));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachineTimeConstantReactance.modelType", &assign_SynchronousMachineTimeConstantReactance_modelType));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachineTimeConstantReactance.rotorType", &assign_SynchronousMachineTimeConstantReactance_rotorType));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachineTimeConstantReactance.tc", &assign_SynchronousMachineTimeConstantReactance_tc));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachineTimeConstantReactance.tpdo", &assign_SynchronousMachineTimeConstantReactance_tpdo));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachineTimeConstantReactance.tppdo", &assign_SynchronousMachineTimeConstantReactance_tppdo));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachineTimeConstantReactance.tppqo", &assign_SynchronousMachineTimeConstantReactance_tppqo));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachineTimeConstantReactance.tpqo", &assign_SynchronousMachineTimeConstantReactance_tpqo));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachineTimeConstantReactance.xDirectSubtrans", &assign_SynchronousMachineTimeConstantReactance_xDirectSubtrans));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachineTimeConstantReactance.xDirectSync", &assign_SynchronousMachineTimeConstantReactance_xDirectSync));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachineTimeConstantReactance.xDirectTrans", &assign_SynchronousMachineTimeConstantReactance_xDirectTrans));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachineTimeConstantReactance.xQuadSubtrans", &assign_SynchronousMachineTimeConstantReactance_xQuadSubtrans));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachineTimeConstantReactance.xQuadSync", &assign_SynchronousMachineTimeConstantReactance_xQuadSync));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachineTimeConstantReactance.xQuadTrans", &assign_SynchronousMachineTimeConstantReactance_xQuadTrans));
	dynamic_switch.insert(std::make_pair("cim:GovCT1.aset", &assign_GovCT1_aset));
	dynamic_switch.insert(std::make_pair("cim:GovCT1.db", &assign_GovCT1_db));
	dynamic_switch.insert(std::make_pair("cim:GovCT1.dm", &assign_GovCT1_dm));
	dynamic_switch.insert(std::make_pair("cim:GovCT1.ka", &assign_GovCT1_ka));
	dynamic_switch.insert(std::make_pair("cim:GovCT1.kdgov", &assign_GovCT1_kdgov));
	dynamic_switch.insert(std::make_pair("cim:GovCT1.kigov", &assign_GovCT1_kigov));
	dynamic_switch.insert(std::make_pair("cim:GovCT1.kiload", &assign_GovCT1_kiload));
	dynamic_switch.insert(std::make_pair("cim:GovCT1.kimw", &assign_GovCT1_kimw));
	dynamic_switch.insert(std::make_pair("cim:GovCT1.kpgov", &assign_GovCT1_kpgov));
	dynamic_switch.insert(std::make_pair("cim:GovCT1.kpload", &assign_GovCT1_kpload));
	dynamic_switch.insert(std::make_pair("cim:GovCT1.kturb", &assign_GovCT1_kturb));
	dynamic_switch.insert(std::make_pair("cim:GovCT1.ldref", &assign_GovCT1_ldref));
	dynamic_switch.insert(std::make_pair("cim:GovCT1.maxerr", &assign_GovCT1_maxerr));
	dynamic_switch.insert(std::make_pair("cim:GovCT1.minerr", &assign_GovCT1_minerr));
	dynamic_switch.insert(std::make_pair("cim:GovCT1.mwbase", &assign_GovCT1_mwbase));
	dynamic_switch.insert(std::make_pair("cim:GovCT1.r", &assign_GovCT1_r));
	dynamic_switch.insert(std::make_pair("cim:GovCT1.rclose", &assign_GovCT1_rclose));
	dynamic_switch.insert(std::make_pair("cim:GovCT1.rdown", &assign_GovCT1_rdown));
	dynamic_switch.insert(std::make_pair("cim:GovCT1.ropen", &assign_GovCT1_ropen));
	dynamic_switch.insert(std::make_pair("cim:GovCT1.rselect", &assign_GovCT1_rselect));
	dynamic_switch.insert(std::make_pair("cim:GovCT1.rup", &assign_GovCT1_rup));
	dynamic_switch.insert(std::make_pair("cim:GovCT1.ta", &assign_GovCT1_ta));
	dynamic_switch.insert(std::make_pair("cim:GovCT1.tact", &assign_GovCT1_tact));
	dynamic_switch.insert(std::make_pair("cim:GovCT1.tb", &assign_GovCT1_tb));
	dynamic_switch.insert(std::make_pair("cim:GovCT1.tc", &assign_GovCT1_tc));
	dynamic_switch.insert(std::make_pair("cim:GovCT1.tdgov", &assign_GovCT1_tdgov));
	dynamic_switch.insert(std::make_pair("cim:GovCT1.teng", &assign_GovCT1_teng));
	dynamic_switch.insert(std::make_pair("cim:GovCT1.tfload", &assign_GovCT1_tfload));
	dynamic_switch.insert(std::make_pair("cim:GovCT1.tpelec", &assign_GovCT1_tpelec));
	dynamic_switch.insert(std::make_pair("cim:GovCT1.tsa", &assign_GovCT1_tsa));
	dynamic_switch.insert(std::make_pair("cim:GovCT1.tsb", &assign_GovCT1_tsb));
	dynamic_switch.insert(std::make_pair("cim:GovCT1.vmax", &assign_GovCT1_vmax));
	dynamic_switch.insert(std::make_pair("cim:GovCT1.vmin", &assign_GovCT1_vmin));
	dynamic_switch.insert(std::make_pair("cim:GovCT1.wfnl", &assign_GovCT1_wfnl));
	dynamic_switch.insert(std::make_pair("cim:GovCT1.wfspd", &assign_GovCT1_wfspd));
	dynamic_switch.insert(std::make_pair("cim:GovCT2.aset", &assign_GovCT2_aset));
	dynamic_switch.insert(std::make_pair("cim:GovCT2.db", &assign_GovCT2_db));
	dynamic_switch.insert(std::make_pair("cim:GovCT2.dm", &assign_GovCT2_dm));
	dynamic_switch.insert(std::make_pair("cim:GovCT2.flim1", &assign_GovCT2_flim1));
	dynamic_switch.insert(std::make_pair("cim:GovCT2.flim10", &assign_GovCT2_flim10));
	dynamic_switch.insert(std::make_pair("cim:GovCT2.flim2", &assign_GovCT2_flim2));
	dynamic_switch.insert(std::make_pair("cim:GovCT2.flim3", &assign_GovCT2_flim3));
	dynamic_switch.insert(std::make_pair("cim:GovCT2.flim4", &assign_GovCT2_flim4));
	dynamic_switch.insert(std::make_pair("cim:GovCT2.flim5", &assign_GovCT2_flim5));
	dynamic_switch.insert(std::make_pair("cim:GovCT2.flim6", &assign_GovCT2_flim6));
	dynamic_switch.insert(std::make_pair("cim:GovCT2.flim7", &assign_GovCT2_flim7));
	dynamic_switch.insert(std::make_pair("cim:GovCT2.flim8", &assign_GovCT2_flim8));
	dynamic_switch.insert(std::make_pair("cim:GovCT2.flim9", &assign_GovCT2_flim9));
	dynamic_switch.insert(std::make_pair("cim:GovCT2.ka", &assign_GovCT2_ka));
	dynamic_switch.insert(std::make_pair("cim:GovCT2.kdgov", &assign_GovCT2_kdgov));
	dynamic_switch.insert(std::make_pair("cim:GovCT2.kigov", &assign_GovCT2_kigov));
	dynamic_switch.insert(std::make_pair("cim:GovCT2.kiload", &assign_GovCT2_kiload));
	dynamic_switch.insert(std::make_pair("cim:GovCT2.kimw", &assign_GovCT2_kimw));
	dynamic_switch.insert(std::make_pair("cim:GovCT2.kpgov", &assign_GovCT2_kpgov));
	dynamic_switch.insert(std::make_pair("cim:GovCT2.kpload", &assign_GovCT2_kpload));
	dynamic_switch.insert(std::make_pair("cim:GovCT2.kturb", &assign_GovCT2_kturb));
	dynamic_switch.insert(std::make_pair("cim:GovCT2.ldref", &assign_GovCT2_ldref));
	dynamic_switch.insert(std::make_pair("cim:GovCT2.maxerr", &assign_GovCT2_maxerr));
	dynamic_switch.insert(std::make_pair("cim:GovCT2.minerr", &assign_GovCT2_minerr));
	dynamic_switch.insert(std::make_pair("cim:GovCT2.mwbase", &assign_GovCT2_mwbase));
	dynamic_switch.insert(std::make_pair("cim:GovCT2.plim1", &assign_GovCT2_plim1));
	dynamic_switch.insert(std::make_pair("cim:GovCT2.plim10", &assign_GovCT2_plim10));
	dynamic_switch.insert(std::make_pair("cim:GovCT2.plim2", &assign_GovCT2_plim2));
	dynamic_switch.insert(std::make_pair("cim:GovCT2.plim3", &assign_GovCT2_plim3));
	dynamic_switch.insert(std::make_pair("cim:GovCT2.plim4", &assign_GovCT2_plim4));
	dynamic_switch.insert(std::make_pair("cim:GovCT2.plim5", &assign_GovCT2_plim5));
	dynamic_switch.insert(std::make_pair("cim:GovCT2.plim6", &assign_GovCT2_plim6));
	dynamic_switch.insert(std::make_pair("cim:GovCT2.plim7", &assign_GovCT2_plim7));
	dynamic_switch.insert(std::make_pair("cim:GovCT2.plim8", &assign_GovCT2_plim8));
	dynamic_switch.insert(std::make_pair("cim:GovCT2.plim9", &assign_GovCT2_plim9));
	dynamic_switch.insert(std::make_pair("cim:GovCT2.prate", &assign_GovCT2_prate));
	dynamic_switch.insert(std::make_pair("cim:GovCT2.r", &assign_GovCT2_r));
	dynamic_switch.insert(std::make_pair("cim:GovCT2.rclose", &assign_GovCT2_rclose));
	dynamic_switch.insert(std::make_pair("cim:GovCT2.rdown", &assign_GovCT2_rdown));
	dynamic_switch.insert(std::make_pair("cim:GovCT2.ropen", &assign_GovCT2_ropen));
	dynamic_switch.insert(std::make_pair("cim:GovCT2.rselect", &assign_GovCT2_rselect));
	dynamic_switch.insert(std::make_pair("cim:GovCT2.rup", &assign_GovCT2_rup));
	dynamic_switch.insert(std::make_pair("cim:GovCT2.ta", &assign_GovCT2_ta));
	dynamic_switch.insert(std::make_pair("cim:GovCT2.tact", &assign_GovCT2_tact));
	dynamic_switch.insert(std::make_pair("cim:GovCT2.tb", &assign_GovCT2_tb));
	dynamic_switch.insert(std::make_pair("cim:GovCT2.tc", &assign_GovCT2_tc));
	dynamic_switch.insert(std::make_pair("cim:GovCT2.tdgov", &assign_GovCT2_tdgov));
	dynamic_switch.insert(std::make_pair("cim:GovCT2.teng", &assign_GovCT2_teng));
	dynamic_switch.insert(std::make_pair("cim:GovCT2.tfload", &assign_GovCT2_tfload));
	dynamic_switch.insert(std::make_pair("cim:GovCT2.tpelec", &assign_GovCT2_tpelec));
	dynamic_switch.insert(std::make_pair("cim:GovCT2.tsa", &assign_GovCT2_tsa));
	dynamic_switch.insert(std::make_pair("cim:GovCT2.tsb", &assign_GovCT2_tsb));
	dynamic_switch.insert(std::make_pair("cim:GovCT2.vmax", &assign_GovCT2_vmax));
	dynamic_switch.insert(std::make_pair("cim:GovCT2.vmin", &assign_GovCT2_vmin));
	dynamic_switch.insert(std::make_pair("cim:GovCT2.wfnl", &assign_GovCT2_wfnl));
	dynamic_switch.insert(std::make_pair("cim:GovCT2.wfspd", &assign_GovCT2_wfspd));
	dynamic_switch.insert(std::make_pair("cim:GovGAST.at", &assign_GovGAST_at));
	dynamic_switch.insert(std::make_pair("cim:GovGAST.dturb", &assign_GovGAST_dturb));
	dynamic_switch.insert(std::make_pair("cim:GovGAST.kt", &assign_GovGAST_kt));
	dynamic_switch.insert(std::make_pair("cim:GovGAST.mwbase", &assign_GovGAST_mwbase));
	dynamic_switch.insert(std::make_pair("cim:GovGAST.r", &assign_GovGAST_r));
	dynamic_switch.insert(std::make_pair("cim:GovGAST.t1", &assign_GovGAST_t1));
	dynamic_switch.insert(std::make_pair("cim:GovGAST.t2", &assign_GovGAST_t2));
	dynamic_switch.insert(std::make_pair("cim:GovGAST.t3", &assign_GovGAST_t3));
	dynamic_switch.insert(std::make_pair("cim:GovGAST.vmax", &assign_GovGAST_vmax));
	dynamic_switch.insert(std::make_pair("cim:GovGAST.vmin", &assign_GovGAST_vmin));
	dynamic_switch.insert(std::make_pair("cim:GovGAST1.a", &assign_GovGAST1_a));
	dynamic_switch.insert(std::make_pair("cim:GovGAST1.b", &assign_GovGAST1_b));
	dynamic_switch.insert(std::make_pair("cim:GovGAST1.db1", &assign_GovGAST1_db1));
	dynamic_switch.insert(std::make_pair("cim:GovGAST1.db2", &assign_GovGAST1_db2));
	dynamic_switch.insert(std::make_pair("cim:GovGAST1.eps", &assign_GovGAST1_eps));
	dynamic_switch.insert(std::make_pair("cim:GovGAST1.fidle", &assign_GovGAST1_fidle));
	dynamic_switch.insert(std::make_pair("cim:GovGAST1.gv1", &assign_GovGAST1_gv1));
	dynamic_switch.insert(std::make_pair("cim:GovGAST1.gv2", &assign_GovGAST1_gv2));
	dynamic_switch.insert(std::make_pair("cim:GovGAST1.gv3", &assign_GovGAST1_gv3));
	dynamic_switch.insert(std::make_pair("cim:GovGAST1.gv4", &assign_GovGAST1_gv4));
	dynamic_switch.insert(std::make_pair("cim:GovGAST1.gv5", &assign_GovGAST1_gv5));
	dynamic_switch.insert(std::make_pair("cim:GovGAST1.gv6", &assign_GovGAST1_gv6));
	dynamic_switch.insert(std::make_pair("cim:GovGAST1.ka", &assign_GovGAST1_ka));
	dynamic_switch.insert(std::make_pair("cim:GovGAST1.kt", &assign_GovGAST1_kt));
	dynamic_switch.insert(std::make_pair("cim:GovGAST1.lmax", &assign_GovGAST1_lmax));
	dynamic_switch.insert(std::make_pair("cim:GovGAST1.loadinc", &assign_GovGAST1_loadinc));
	dynamic_switch.insert(std::make_pair("cim:GovGAST1.ltrate", &assign_GovGAST1_ltrate));
	dynamic_switch.insert(std::make_pair("cim:GovGAST1.mwbase", &assign_GovGAST1_mwbase));
	dynamic_switch.insert(std::make_pair("cim:GovGAST1.pgv1", &assign_GovGAST1_pgv1));
	dynamic_switch.insert(std::make_pair("cim:GovGAST1.pgv2", &assign_GovGAST1_pgv2));
	dynamic_switch.insert(std::make_pair("cim:GovGAST1.pgv3", &assign_GovGAST1_pgv3));
	dynamic_switch.insert(std::make_pair("cim:GovGAST1.pgv4", &assign_GovGAST1_pgv4));
	dynamic_switch.insert(std::make_pair("cim:GovGAST1.pgv5", &assign_GovGAST1_pgv5));
	dynamic_switch.insert(std::make_pair("cim:GovGAST1.pgv6", &assign_GovGAST1_pgv6));
	dynamic_switch.insert(std::make_pair("cim:GovGAST1.r", &assign_GovGAST1_r));
	dynamic_switch.insert(std::make_pair("cim:GovGAST1.rmax", &assign_GovGAST1_rmax));
	dynamic_switch.insert(std::make_pair("cim:GovGAST1.t1", &assign_GovGAST1_t1));
	dynamic_switch.insert(std::make_pair("cim:GovGAST1.t2", &assign_GovGAST1_t2));
	dynamic_switch.insert(std::make_pair("cim:GovGAST1.t3", &assign_GovGAST1_t3));
	dynamic_switch.insert(std::make_pair("cim:GovGAST1.t4", &assign_GovGAST1_t4));
	dynamic_switch.insert(std::make_pair("cim:GovGAST1.t5", &assign_GovGAST1_t5));
	dynamic_switch.insert(std::make_pair("cim:GovGAST1.tltr", &assign_GovGAST1_tltr));
	dynamic_switch.insert(std::make_pair("cim:GovGAST1.vmax", &assign_GovGAST1_vmax));
	dynamic_switch.insert(std::make_pair("cim:GovGAST1.vmin", &assign_GovGAST1_vmin));
	dynamic_switch.insert(std::make_pair("cim:GovGAST2.a", &assign_GovGAST2_a));
	dynamic_switch.insert(std::make_pair("cim:GovGAST2.af1", &assign_GovGAST2_af1));
	dynamic_switch.insert(std::make_pair("cim:GovGAST2.af2", &assign_GovGAST2_af2));
	dynamic_switch.insert(std::make_pair("cim:GovGAST2.b", &assign_GovGAST2_b));
	dynamic_switch.insert(std::make_pair("cim:GovGAST2.bf1", &assign_GovGAST2_bf1));
	dynamic_switch.insert(std::make_pair("cim:GovGAST2.bf2", &assign_GovGAST2_bf2));
	dynamic_switch.insert(std::make_pair("cim:GovGAST2.c", &assign_GovGAST2_c));
	dynamic_switch.insert(std::make_pair("cim:GovGAST2.cf2", &assign_GovGAST2_cf2));
	dynamic_switch.insert(std::make_pair("cim:GovGAST2.ecr", &assign_GovGAST2_ecr));
	dynamic_switch.insert(std::make_pair("cim:GovGAST2.etd", &assign_GovGAST2_etd));
	dynamic_switch.insert(std::make_pair("cim:GovGAST2.k3", &assign_GovGAST2_k3));
	dynamic_switch.insert(std::make_pair("cim:GovGAST2.k4", &assign_GovGAST2_k4));
	dynamic_switch.insert(std::make_pair("cim:GovGAST2.k5", &assign_GovGAST2_k5));
	dynamic_switch.insert(std::make_pair("cim:GovGAST2.k6", &assign_GovGAST2_k6));
	dynamic_switch.insert(std::make_pair("cim:GovGAST2.kf", &assign_GovGAST2_kf));
	dynamic_switch.insert(std::make_pair("cim:GovGAST2.mwbase", &assign_GovGAST2_mwbase));
	dynamic_switch.insert(std::make_pair("cim:GovGAST2.t", &assign_GovGAST2_t));
	dynamic_switch.insert(std::make_pair("cim:GovGAST2.t3", &assign_GovGAST2_t3));
	dynamic_switch.insert(std::make_pair("cim:GovGAST2.t4", &assign_GovGAST2_t4));
	dynamic_switch.insert(std::make_pair("cim:GovGAST2.t5", &assign_GovGAST2_t5));
	dynamic_switch.insert(std::make_pair("cim:GovGAST2.tc", &assign_GovGAST2_tc));
	dynamic_switch.insert(std::make_pair("cim:GovGAST2.tcd", &assign_GovGAST2_tcd));
	dynamic_switch.insert(std::make_pair("cim:GovGAST2.tf", &assign_GovGAST2_tf));
	dynamic_switch.insert(std::make_pair("cim:GovGAST2.tmax", &assign_GovGAST2_tmax));
	dynamic_switch.insert(std::make_pair("cim:GovGAST2.tmin", &assign_GovGAST2_tmin));
	dynamic_switch.insert(std::make_pair("cim:GovGAST2.tr", &assign_GovGAST2_tr));
	dynamic_switch.insert(std::make_pair("cim:GovGAST2.trate", &assign_GovGAST2_trate));
	dynamic_switch.insert(std::make_pair("cim:GovGAST2.tt", &assign_GovGAST2_tt));
	dynamic_switch.insert(std::make_pair("cim:GovGAST2.w", &assign_GovGAST2_w));
	dynamic_switch.insert(std::make_pair("cim:GovGAST2.x", &assign_GovGAST2_x));
	dynamic_switch.insert(std::make_pair("cim:GovGAST2.y", &assign_GovGAST2_y));
	dynamic_switch.insert(std::make_pair("cim:GovGAST2.z", &assign_GovGAST2_z));
	dynamic_switch.insert(std::make_pair("cim:GovGAST3.bca", &assign_GovGAST3_bca));
	dynamic_switch.insert(std::make_pair("cim:GovGAST3.bp", &assign_GovGAST3_bp));
	dynamic_switch.insert(std::make_pair("cim:GovGAST3.dtc", &assign_GovGAST3_dtc));
	dynamic_switch.insert(std::make_pair("cim:GovGAST3.ka", &assign_GovGAST3_ka));
	dynamic_switch.insert(std::make_pair("cim:GovGAST3.kac", &assign_GovGAST3_kac));
	dynamic_switch.insert(std::make_pair("cim:GovGAST3.kca", &assign_GovGAST3_kca));
	dynamic_switch.insert(std::make_pair("cim:GovGAST3.ksi", &assign_GovGAST3_ksi));
	dynamic_switch.insert(std::make_pair("cim:GovGAST3.ky", &assign_GovGAST3_ky));
	dynamic_switch.insert(std::make_pair("cim:GovGAST3.mnef", &assign_GovGAST3_mnef));
	dynamic_switch.insert(std::make_pair("cim:GovGAST3.mxef", &assign_GovGAST3_mxef));
	dynamic_switch.insert(std::make_pair("cim:GovGAST3.rcmn", &assign_GovGAST3_rcmn));
	dynamic_switch.insert(std::make_pair("cim:GovGAST3.rcmx", &assign_GovGAST3_rcmx));
	dynamic_switch.insert(std::make_pair("cim:GovGAST3.tac", &assign_GovGAST3_tac));
	dynamic_switch.insert(std::make_pair("cim:GovGAST3.tc", &assign_GovGAST3_tc));
	dynamic_switch.insert(std::make_pair("cim:GovGAST3.td", &assign_GovGAST3_td));
	dynamic_switch.insert(std::make_pair("cim:GovGAST3.tfen", &assign_GovGAST3_tfen));
	dynamic_switch.insert(std::make_pair("cim:GovGAST3.tg", &assign_GovGAST3_tg));
	dynamic_switch.insert(std::make_pair("cim:GovGAST3.tsi", &assign_GovGAST3_tsi));
	dynamic_switch.insert(std::make_pair("cim:GovGAST3.tt", &assign_GovGAST3_tt));
	dynamic_switch.insert(std::make_pair("cim:GovGAST3.ttc", &assign_GovGAST3_ttc));
	dynamic_switch.insert(std::make_pair("cim:GovGAST3.ty", &assign_GovGAST3_ty));
	dynamic_switch.insert(std::make_pair("cim:GovGAST4.bp", &assign_GovGAST4_bp));
	dynamic_switch.insert(std::make_pair("cim:GovGAST4.ktm", &assign_GovGAST4_ktm));
	dynamic_switch.insert(std::make_pair("cim:GovGAST4.mnef", &assign_GovGAST4_mnef));
	dynamic_switch.insert(std::make_pair("cim:GovGAST4.mxef", &assign_GovGAST4_mxef));
	dynamic_switch.insert(std::make_pair("cim:GovGAST4.rymn", &assign_GovGAST4_rymn));
	dynamic_switch.insert(std::make_pair("cim:GovGAST4.rymx", &assign_GovGAST4_rymx));
	dynamic_switch.insert(std::make_pair("cim:GovGAST4.ta", &assign_GovGAST4_ta));
	dynamic_switch.insert(std::make_pair("cim:GovGAST4.tc", &assign_GovGAST4_tc));
	dynamic_switch.insert(std::make_pair("cim:GovGAST4.tcm", &assign_GovGAST4_tcm));
	dynamic_switch.insert(std::make_pair("cim:GovGAST4.tm", &assign_GovGAST4_tm));
	dynamic_switch.insert(std::make_pair("cim:GovGAST4.tv", &assign_GovGAST4_tv));
	dynamic_switch.insert(std::make_pair("cim:GovGASTWD.a", &assign_GovGASTWD_a));
	dynamic_switch.insert(std::make_pair("cim:GovGASTWD.af1", &assign_GovGASTWD_af1));
	dynamic_switch.insert(std::make_pair("cim:GovGASTWD.af2", &assign_GovGASTWD_af2));
	dynamic_switch.insert(std::make_pair("cim:GovGASTWD.b", &assign_GovGASTWD_b));
	dynamic_switch.insert(std::make_pair("cim:GovGASTWD.bf1", &assign_GovGASTWD_bf1));
	dynamic_switch.insert(std::make_pair("cim:GovGASTWD.bf2", &assign_GovGASTWD_bf2));
	dynamic_switch.insert(std::make_pair("cim:GovGASTWD.c", &assign_GovGASTWD_c));
	dynamic_switch.insert(std::make_pair("cim:GovGASTWD.cf2", &assign_GovGASTWD_cf2));
	dynamic_switch.insert(std::make_pair("cim:GovGASTWD.ecr", &assign_GovGASTWD_ecr));
	dynamic_switch.insert(std::make_pair("cim:GovGASTWD.etd", &assign_GovGASTWD_etd));
	dynamic_switch.insert(std::make_pair("cim:GovGASTWD.k3", &assign_GovGASTWD_k3));
	dynamic_switch.insert(std::make_pair("cim:GovGASTWD.k4", &assign_GovGASTWD_k4));
	dynamic_switch.insert(std::make_pair("cim:GovGASTWD.k5", &assign_GovGASTWD_k5));
	dynamic_switch.insert(std::make_pair("cim:GovGASTWD.k6", &assign_GovGASTWD_k6));
	dynamic_switch.insert(std::make_pair("cim:GovGASTWD.kd", &assign_GovGASTWD_kd));
	dynamic_switch.insert(std::make_pair("cim:GovGASTWD.kdroop", &assign_GovGASTWD_kdroop));
	dynamic_switch.insert(std::make_pair("cim:GovGASTWD.kf", &assign_GovGASTWD_kf));
	dynamic_switch.insert(std::make_pair("cim:GovGASTWD.ki", &assign_GovGASTWD_ki));
	dynamic_switch.insert(std::make_pair("cim:GovGASTWD.kp", &assign_GovGASTWD_kp));
	dynamic_switch.insert(std::make_pair("cim:GovGASTWD.mwbase", &assign_GovGASTWD_mwbase));
	dynamic_switch.insert(std::make_pair("cim:GovGASTWD.t", &assign_GovGASTWD_t));
	dynamic_switch.insert(std::make_pair("cim:GovGASTWD.t3", &assign_GovGASTWD_t3));
	dynamic_switch.insert(std::make_pair("cim:GovGASTWD.t4", &assign_GovGASTWD_t4));
	dynamic_switch.insert(std::make_pair("cim:GovGASTWD.t5", &assign_GovGASTWD_t5));
	dynamic_switch.insert(std::make_pair("cim:GovGASTWD.tc", &assign_GovGASTWD_tc));
	dynamic_switch.insert(std::make_pair("cim:GovGASTWD.tcd", &assign_GovGASTWD_tcd));
	dynamic_switch.insert(std::make_pair("cim:GovGASTWD.td", &assign_GovGASTWD_td));
	dynamic_switch.insert(std::make_pair("cim:GovGASTWD.tf", &assign_GovGASTWD_tf));
	dynamic_switch.insert(std::make_pair("cim:GovGASTWD.tmax", &assign_GovGASTWD_tmax));
	dynamic_switch.insert(std::make_pair("cim:GovGASTWD.tmin", &assign_GovGASTWD_tmin));
	dynamic_switch.insert(std::make_pair("cim:GovGASTWD.tr", &assign_GovGASTWD_tr));
	dynamic_switch.insert(std::make_pair("cim:GovGASTWD.trate", &assign_GovGASTWD_trate));
	dynamic_switch.insert(std::make_pair("cim:GovGASTWD.tt", &assign_GovGASTWD_tt));
	dynamic_switch.insert(std::make_pair("cim:GovHydro1.at", &assign_GovHydro1_at));
	dynamic_switch.insert(std::make_pair("cim:GovHydro1.dturb", &assign_GovHydro1_dturb));
	dynamic_switch.insert(std::make_pair("cim:GovHydro1.gmax", &assign_GovHydro1_gmax));
	dynamic_switch.insert(std::make_pair("cim:GovHydro1.gmin", &assign_GovHydro1_gmin));
	dynamic_switch.insert(std::make_pair("cim:GovHydro1.hdam", &assign_GovHydro1_hdam));
	dynamic_switch.insert(std::make_pair("cim:GovHydro1.mwbase", &assign_GovHydro1_mwbase));
	dynamic_switch.insert(std::make_pair("cim:GovHydro1.qnl", &assign_GovHydro1_qnl));
	dynamic_switch.insert(std::make_pair("cim:GovHydro1.rperm", &assign_GovHydro1_rperm));
	dynamic_switch.insert(std::make_pair("cim:GovHydro1.rtemp", &assign_GovHydro1_rtemp));
	dynamic_switch.insert(std::make_pair("cim:GovHydro1.tf", &assign_GovHydro1_tf));
	dynamic_switch.insert(std::make_pair("cim:GovHydro1.tg", &assign_GovHydro1_tg));
	dynamic_switch.insert(std::make_pair("cim:GovHydro1.tr", &assign_GovHydro1_tr));
	dynamic_switch.insert(std::make_pair("cim:GovHydro1.tw", &assign_GovHydro1_tw));
	dynamic_switch.insert(std::make_pair("cim:GovHydro1.velm", &assign_GovHydro1_velm));
	dynamic_switch.insert(std::make_pair("cim:GovHydro2.aturb", &assign_GovHydro2_aturb));
	dynamic_switch.insert(std::make_pair("cim:GovHydro2.bturb", &assign_GovHydro2_bturb));
	dynamic_switch.insert(std::make_pair("cim:GovHydro2.db1", &assign_GovHydro2_db1));
	dynamic_switch.insert(std::make_pair("cim:GovHydro2.db2", &assign_GovHydro2_db2));
	dynamic_switch.insert(std::make_pair("cim:GovHydro2.eps", &assign_GovHydro2_eps));
	dynamic_switch.insert(std::make_pair("cim:GovHydro2.gv1", &assign_GovHydro2_gv1));
	dynamic_switch.insert(std::make_pair("cim:GovHydro2.gv2", &assign_GovHydro2_gv2));
	dynamic_switch.insert(std::make_pair("cim:GovHydro2.gv3", &assign_GovHydro2_gv3));
	dynamic_switch.insert(std::make_pair("cim:GovHydro2.gv4", &assign_GovHydro2_gv4));
	dynamic_switch.insert(std::make_pair("cim:GovHydro2.gv5", &assign_GovHydro2_gv5));
	dynamic_switch.insert(std::make_pair("cim:GovHydro2.gv6", &assign_GovHydro2_gv6));
	dynamic_switch.insert(std::make_pair("cim:GovHydro2.kturb", &assign_GovHydro2_kturb));
	dynamic_switch.insert(std::make_pair("cim:GovHydro2.mwbase", &assign_GovHydro2_mwbase));
	dynamic_switch.insert(std::make_pair("cim:GovHydro2.pgv1", &assign_GovHydro2_pgv1));
	dynamic_switch.insert(std::make_pair("cim:GovHydro2.pgv2", &assign_GovHydro2_pgv2));
	dynamic_switch.insert(std::make_pair("cim:GovHydro2.pgv3", &assign_GovHydro2_pgv3));
	dynamic_switch.insert(std::make_pair("cim:GovHydro2.pgv4", &assign_GovHydro2_pgv4));
	dynamic_switch.insert(std::make_pair("cim:GovHydro2.pgv5", &assign_GovHydro2_pgv5));
	dynamic_switch.insert(std::make_pair("cim:GovHydro2.pgv6", &assign_GovHydro2_pgv6));
	dynamic_switch.insert(std::make_pair("cim:GovHydro2.pmax", &assign_GovHydro2_pmax));
	dynamic_switch.insert(std::make_pair("cim:GovHydro2.pmin", &assign_GovHydro2_pmin));
	dynamic_switch.insert(std::make_pair("cim:GovHydro2.rperm", &assign_GovHydro2_rperm));
	dynamic_switch.insert(std::make_pair("cim:GovHydro2.rtemp", &assign_GovHydro2_rtemp));
	dynamic_switch.insert(std::make_pair("cim:GovHydro2.tg", &assign_GovHydro2_tg));
	dynamic_switch.insert(std::make_pair("cim:GovHydro2.tp", &assign_GovHydro2_tp));
	dynamic_switch.insert(std::make_pair("cim:GovHydro2.tr", &assign_GovHydro2_tr));
	dynamic_switch.insert(std::make_pair("cim:GovHydro2.tw", &assign_GovHydro2_tw));
	dynamic_switch.insert(std::make_pair("cim:GovHydro2.uc", &assign_GovHydro2_uc));
	dynamic_switch.insert(std::make_pair("cim:GovHydro2.uo", &assign_GovHydro2_uo));
	dynamic_switch.insert(std::make_pair("cim:GovHydro3.at", &assign_GovHydro3_at));
	dynamic_switch.insert(std::make_pair("cim:GovHydro3.db1", &assign_GovHydro3_db1));
	dynamic_switch.insert(std::make_pair("cim:GovHydro3.db2", &assign_GovHydro3_db2));
	dynamic_switch.insert(std::make_pair("cim:GovHydro3.dturb", &assign_GovHydro3_dturb));
	dynamic_switch.insert(std::make_pair("cim:GovHydro3.eps", &assign_GovHydro3_eps));
	dynamic_switch.insert(std::make_pair("cim:GovHydro3.governorControl", &assign_GovHydro3_governorControl));
	dynamic_switch.insert(std::make_pair("cim:GovHydro3.gv1", &assign_GovHydro3_gv1));
	dynamic_switch.insert(std::make_pair("cim:GovHydro3.gv2", &assign_GovHydro3_gv2));
	dynamic_switch.insert(std::make_pair("cim:GovHydro3.gv3", &assign_GovHydro3_gv3));
	dynamic_switch.insert(std::make_pair("cim:GovHydro3.gv4", &assign_GovHydro3_gv4));
	dynamic_switch.insert(std::make_pair("cim:GovHydro3.gv5", &assign_GovHydro3_gv5));
	dynamic_switch.insert(std::make_pair("cim:GovHydro3.gv6", &assign_GovHydro3_gv6));
	dynamic_switch.insert(std::make_pair("cim:GovHydro3.h0", &assign_GovHydro3_h0));
	dynamic_switch.insert(std::make_pair("cim:GovHydro3.k1", &assign_GovHydro3_k1));
	dynamic_switch.insert(std::make_pair("cim:GovHydro3.k2", &assign_GovHydro3_k2));
	dynamic_switch.insert(std::make_pair("cim:GovHydro3.kg", &assign_GovHydro3_kg));
	dynamic_switch.insert(std::make_pair("cim:GovHydro3.ki", &assign_GovHydro3_ki));
	dynamic_switch.insert(std::make_pair("cim:GovHydro3.mwbase", &assign_GovHydro3_mwbase));
	dynamic_switch.insert(std::make_pair("cim:GovHydro3.pgv1", &assign_GovHydro3_pgv1));
	dynamic_switch.insert(std::make_pair("cim:GovHydro3.pgv2", &assign_GovHydro3_pgv2));
	dynamic_switch.insert(std::make_pair("cim:GovHydro3.pgv3", &assign_GovHydro3_pgv3));
	dynamic_switch.insert(std::make_pair("cim:GovHydro3.pgv4", &assign_GovHydro3_pgv4));
	dynamic_switch.insert(std::make_pair("cim:GovHydro3.pgv5", &assign_GovHydro3_pgv5));
	dynamic_switch.insert(std::make_pair("cim:GovHydro3.pgv6", &assign_GovHydro3_pgv6));
	dynamic_switch.insert(std::make_pair("cim:GovHydro3.pmax", &assign_GovHydro3_pmax));
	dynamic_switch.insert(std::make_pair("cim:GovHydro3.pmin", &assign_GovHydro3_pmin));
	dynamic_switch.insert(std::make_pair("cim:GovHydro3.qnl", &assign_GovHydro3_qnl));
	dynamic_switch.insert(std::make_pair("cim:GovHydro3.relec", &assign_GovHydro3_relec));
	dynamic_switch.insert(std::make_pair("cim:GovHydro3.rgate", &assign_GovHydro3_rgate));
	dynamic_switch.insert(std::make_pair("cim:GovHydro3.td", &assign_GovHydro3_td));
	dynamic_switch.insert(std::make_pair("cim:GovHydro3.tf", &assign_GovHydro3_tf));
	dynamic_switch.insert(std::make_pair("cim:GovHydro3.tp", &assign_GovHydro3_tp));
	dynamic_switch.insert(std::make_pair("cim:GovHydro3.tt", &assign_GovHydro3_tt));
	dynamic_switch.insert(std::make_pair("cim:GovHydro3.tw", &assign_GovHydro3_tw));
	dynamic_switch.insert(std::make_pair("cim:GovHydro3.velcl", &assign_GovHydro3_velcl));
	dynamic_switch.insert(std::make_pair("cim:GovHydro3.velop", &assign_GovHydro3_velop));
	dynamic_switch.insert(std::make_pair("cim:GovHydro4.at", &assign_GovHydro4_at));
	dynamic_switch.insert(std::make_pair("cim:GovHydro4.bgv0", &assign_GovHydro4_bgv0));
	dynamic_switch.insert(std::make_pair("cim:GovHydro4.bgv1", &assign_GovHydro4_bgv1));
	dynamic_switch.insert(std::make_pair("cim:GovHydro4.bgv2", &assign_GovHydro4_bgv2));
	dynamic_switch.insert(std::make_pair("cim:GovHydro4.bgv3", &assign_GovHydro4_bgv3));
	dynamic_switch.insert(std::make_pair("cim:GovHydro4.bgv4", &assign_GovHydro4_bgv4));
	dynamic_switch.insert(std::make_pair("cim:GovHydro4.bgv5", &assign_GovHydro4_bgv5));
	dynamic_switch.insert(std::make_pair("cim:GovHydro4.bmax", &assign_GovHydro4_bmax));
	dynamic_switch.insert(std::make_pair("cim:GovHydro4.db1", &assign_GovHydro4_db1));
	dynamic_switch.insert(std::make_pair("cim:GovHydro4.db2", &assign_GovHydro4_db2));
	dynamic_switch.insert(std::make_pair("cim:GovHydro4.dturb", &assign_GovHydro4_dturb));
	dynamic_switch.insert(std::make_pair("cim:GovHydro4.eps", &assign_GovHydro4_eps));
	dynamic_switch.insert(std::make_pair("cim:GovHydro4.gmax", &assign_GovHydro4_gmax));
	dynamic_switch.insert(std::make_pair("cim:GovHydro4.gmin", &assign_GovHydro4_gmin));
	dynamic_switch.insert(std::make_pair("cim:GovHydro4.gv0", &assign_GovHydro4_gv0));
	dynamic_switch.insert(std::make_pair("cim:GovHydro4.gv1", &assign_GovHydro4_gv1));
	dynamic_switch.insert(std::make_pair("cim:GovHydro4.gv2", &assign_GovHydro4_gv2));
	dynamic_switch.insert(std::make_pair("cim:GovHydro4.gv3", &assign_GovHydro4_gv3));
	dynamic_switch.insert(std::make_pair("cim:GovHydro4.gv4", &assign_GovHydro4_gv4));
	dynamic_switch.insert(std::make_pair("cim:GovHydro4.gv5", &assign_GovHydro4_gv5));
	dynamic_switch.insert(std::make_pair("cim:GovHydro4.hdam", &assign_GovHydro4_hdam));
	dynamic_switch.insert(std::make_pair("cim:GovHydro4.mwbase", &assign_GovHydro4_mwbase));
	dynamic_switch.insert(std::make_pair("cim:GovHydro4.pgv0", &assign_GovHydro4_pgv0));
	dynamic_switch.insert(std::make_pair("cim:GovHydro4.pgv1", &assign_GovHydro4_pgv1));
	dynamic_switch.insert(std::make_pair("cim:GovHydro4.pgv2", &assign_GovHydro4_pgv2));
	dynamic_switch.insert(std::make_pair("cim:GovHydro4.pgv3", &assign_GovHydro4_pgv3));
	dynamic_switch.insert(std::make_pair("cim:GovHydro4.pgv4", &assign_GovHydro4_pgv4));
	dynamic_switch.insert(std::make_pair("cim:GovHydro4.pgv5", &assign_GovHydro4_pgv5));
	dynamic_switch.insert(std::make_pair("cim:GovHydro4.qn1", &assign_GovHydro4_qn1));
	dynamic_switch.insert(std::make_pair("cim:GovHydro4.rperm", &assign_GovHydro4_rperm));
	dynamic_switch.insert(std::make_pair("cim:GovHydro4.rtemp", &assign_GovHydro4_rtemp));
	dynamic_switch.insert(std::make_pair("cim:GovHydro4.tblade", &assign_GovHydro4_tblade));
	dynamic_switch.insert(std::make_pair("cim:GovHydro4.tg", &assign_GovHydro4_tg));
	dynamic_switch.insert(std::make_pair("cim:GovHydro4.tp", &assign_GovHydro4_tp));
	dynamic_switch.insert(std::make_pair("cim:GovHydro4.tr", &assign_GovHydro4_tr));
	dynamic_switch.insert(std::make_pair("cim:GovHydro4.tw", &assign_GovHydro4_tw));
	dynamic_switch.insert(std::make_pair("cim:GovHydro4.uc", &assign_GovHydro4_uc));
	dynamic_switch.insert(std::make_pair("cim:GovHydro4.uo", &assign_GovHydro4_uo));
	dynamic_switch.insert(std::make_pair("cim:GovHydroDD.aturb", &assign_GovHydroDD_aturb));
	dynamic_switch.insert(std::make_pair("cim:GovHydroDD.bturb", &assign_GovHydroDD_bturb));
	dynamic_switch.insert(std::make_pair("cim:GovHydroDD.db1", &assign_GovHydroDD_db1));
	dynamic_switch.insert(std::make_pair("cim:GovHydroDD.db2", &assign_GovHydroDD_db2));
	dynamic_switch.insert(std::make_pair("cim:GovHydroDD.eps", &assign_GovHydroDD_eps));
	dynamic_switch.insert(std::make_pair("cim:GovHydroDD.gmax", &assign_GovHydroDD_gmax));
	dynamic_switch.insert(std::make_pair("cim:GovHydroDD.gmin", &assign_GovHydroDD_gmin));
	dynamic_switch.insert(std::make_pair("cim:GovHydroDD.gv1", &assign_GovHydroDD_gv1));
	dynamic_switch.insert(std::make_pair("cim:GovHydroDD.gv2", &assign_GovHydroDD_gv2));
	dynamic_switch.insert(std::make_pair("cim:GovHydroDD.gv3", &assign_GovHydroDD_gv3));
	dynamic_switch.insert(std::make_pair("cim:GovHydroDD.gv4", &assign_GovHydroDD_gv4));
	dynamic_switch.insert(std::make_pair("cim:GovHydroDD.gv5", &assign_GovHydroDD_gv5));
	dynamic_switch.insert(std::make_pair("cim:GovHydroDD.gv6", &assign_GovHydroDD_gv6));
	dynamic_switch.insert(std::make_pair("cim:GovHydroDD.inputSignal", &assign_GovHydroDD_inputSignal));
	dynamic_switch.insert(std::make_pair("cim:GovHydroDD.k1", &assign_GovHydroDD_k1));
	dynamic_switch.insert(std::make_pair("cim:GovHydroDD.k2", &assign_GovHydroDD_k2));
	dynamic_switch.insert(std::make_pair("cim:GovHydroDD.kg", &assign_GovHydroDD_kg));
	dynamic_switch.insert(std::make_pair("cim:GovHydroDD.ki", &assign_GovHydroDD_ki));
	dynamic_switch.insert(std::make_pair("cim:GovHydroDD.mwbase", &assign_GovHydroDD_mwbase));
	dynamic_switch.insert(std::make_pair("cim:GovHydroDD.pgv1", &assign_GovHydroDD_pgv1));
	dynamic_switch.insert(std::make_pair("cim:GovHydroDD.pgv2", &assign_GovHydroDD_pgv2));
	dynamic_switch.insert(std::make_pair("cim:GovHydroDD.pgv3", &assign_GovHydroDD_pgv3));
	dynamic_switch.insert(std::make_pair("cim:GovHydroDD.pgv4", &assign_GovHydroDD_pgv4));
	dynamic_switch.insert(std::make_pair("cim:GovHydroDD.pgv5", &assign_GovHydroDD_pgv5));
	dynamic_switch.insert(std::make_pair("cim:GovHydroDD.pgv6", &assign_GovHydroDD_pgv6));
	dynamic_switch.insert(std::make_pair("cim:GovHydroDD.pmax", &assign_GovHydroDD_pmax));
	dynamic_switch.insert(std::make_pair("cim:GovHydroDD.pmin", &assign_GovHydroDD_pmin));
	dynamic_switch.insert(std::make_pair("cim:GovHydroDD.r", &assign_GovHydroDD_r));
	dynamic_switch.insert(std::make_pair("cim:GovHydroDD.td", &assign_GovHydroDD_td));
	dynamic_switch.insert(std::make_pair("cim:GovHydroDD.tf", &assign_GovHydroDD_tf));
	dynamic_switch.insert(std::make_pair("cim:GovHydroDD.tp", &assign_GovHydroDD_tp));
	dynamic_switch.insert(std::make_pair("cim:GovHydroDD.tt", &assign_GovHydroDD_tt));
	dynamic_switch.insert(std::make_pair("cim:GovHydroDD.tturb", &assign_GovHydroDD_tturb));
	dynamic_switch.insert(std::make_pair("cim:GovHydroDD.velcl", &assign_GovHydroDD_velcl));
	dynamic_switch.insert(std::make_pair("cim:GovHydroDD.velop", &assign_GovHydroDD_velop));
	dynamic_switch.insert(std::make_pair("cim:GovHydroFrancis.am", &assign_GovHydroFrancis_am));
	dynamic_switch.insert(std::make_pair("cim:GovHydroFrancis.av0", &assign_GovHydroFrancis_av0));
	dynamic_switch.insert(std::make_pair("cim:GovHydroFrancis.av1", &assign_GovHydroFrancis_av1));
	dynamic_switch.insert(std::make_pair("cim:GovHydroFrancis.bp", &assign_GovHydroFrancis_bp));
	dynamic_switch.insert(std::make_pair("cim:GovHydroFrancis.db1", &assign_GovHydroFrancis_db1));
	dynamic_switch.insert(std::make_pair("cim:GovHydroFrancis.etamax", &assign_GovHydroFrancis_etamax));
	dynamic_switch.insert(std::make_pair("cim:GovHydroFrancis.governorControl", &assign_GovHydroFrancis_governorControl));
	dynamic_switch.insert(std::make_pair("cim:GovHydroFrancis.h1", &assign_GovHydroFrancis_h1));
	dynamic_switch.insert(std::make_pair("cim:GovHydroFrancis.h2", &assign_GovHydroFrancis_h2));
	dynamic_switch.insert(std::make_pair("cim:GovHydroFrancis.hn", &assign_GovHydroFrancis_hn));
	dynamic_switch.insert(std::make_pair("cim:GovHydroFrancis.kc", &assign_GovHydroFrancis_kc));
	dynamic_switch.insert(std::make_pair("cim:GovHydroFrancis.kg", &assign_GovHydroFrancis_kg));
	dynamic_switch.insert(std::make_pair("cim:GovHydroFrancis.kt", &assign_GovHydroFrancis_kt));
	dynamic_switch.insert(std::make_pair("cim:GovHydroFrancis.qc0", &assign_GovHydroFrancis_qc0));
	dynamic_switch.insert(std::make_pair("cim:GovHydroFrancis.qn", &assign_GovHydroFrancis_qn));
	dynamic_switch.insert(std::make_pair("cim:GovHydroFrancis.ta", &assign_GovHydroFrancis_ta));
	dynamic_switch.insert(std::make_pair("cim:GovHydroFrancis.td", &assign_GovHydroFrancis_td));
	dynamic_switch.insert(std::make_pair("cim:GovHydroFrancis.ts", &assign_GovHydroFrancis_ts));
	dynamic_switch.insert(std::make_pair("cim:GovHydroFrancis.twnc", &assign_GovHydroFrancis_twnc));
	dynamic_switch.insert(std::make_pair("cim:GovHydroFrancis.twng", &assign_GovHydroFrancis_twng));
	dynamic_switch.insert(std::make_pair("cim:GovHydroFrancis.tx", &assign_GovHydroFrancis_tx));
	dynamic_switch.insert(std::make_pair("cim:GovHydroFrancis.va", &assign_GovHydroFrancis_va));
	dynamic_switch.insert(std::make_pair("cim:GovHydroFrancis.valvmax", &assign_GovHydroFrancis_valvmax));
	dynamic_switch.insert(std::make_pair("cim:GovHydroFrancis.valvmin", &assign_GovHydroFrancis_valvmin));
	dynamic_switch.insert(std::make_pair("cim:GovHydroFrancis.vc", &assign_GovHydroFrancis_vc));
	dynamic_switch.insert(std::make_pair("cim:GovHydroFrancis.waterTunnelSurgeChamberSimulation", &assign_GovHydroFrancis_waterTunnelSurgeChamberSimulation));
	dynamic_switch.insert(std::make_pair("cim:GovHydroFrancis.zsfc", &assign_GovHydroFrancis_zsfc));
	dynamic_switch.insert(std::make_pair("cim:GovHydroIEEE0.k", &assign_GovHydroIEEE0_k));
	dynamic_switch.insert(std::make_pair("cim:GovHydroIEEE0.mwbase", &assign_GovHydroIEEE0_mwbase));
	dynamic_switch.insert(std::make_pair("cim:GovHydroIEEE0.pmax", &assign_GovHydroIEEE0_pmax));
	dynamic_switch.insert(std::make_pair("cim:GovHydroIEEE0.pmin", &assign_GovHydroIEEE0_pmin));
	dynamic_switch.insert(std::make_pair("cim:GovHydroIEEE0.t1", &assign_GovHydroIEEE0_t1));
	dynamic_switch.insert(std::make_pair("cim:GovHydroIEEE0.t2", &assign_GovHydroIEEE0_t2));
	dynamic_switch.insert(std::make_pair("cim:GovHydroIEEE0.t3", &assign_GovHydroIEEE0_t3));
	dynamic_switch.insert(std::make_pair("cim:GovHydroIEEE0.t4", &assign_GovHydroIEEE0_t4));
	dynamic_switch.insert(std::make_pair("cim:GovHydroIEEE2.aturb", &assign_GovHydroIEEE2_aturb));
	dynamic_switch.insert(std::make_pair("cim:GovHydroIEEE2.bturb", &assign_GovHydroIEEE2_bturb));
	dynamic_switch.insert(std::make_pair("cim:GovHydroIEEE2.gv1", &assign_GovHydroIEEE2_gv1));
	dynamic_switch.insert(std::make_pair("cim:GovHydroIEEE2.gv2", &assign_GovHydroIEEE2_gv2));
	dynamic_switch.insert(std::make_pair("cim:GovHydroIEEE2.gv3", &assign_GovHydroIEEE2_gv3));
	dynamic_switch.insert(std::make_pair("cim:GovHydroIEEE2.gv4", &assign_GovHydroIEEE2_gv4));
	dynamic_switch.insert(std::make_pair("cim:GovHydroIEEE2.gv5", &assign_GovHydroIEEE2_gv5));
	dynamic_switch.insert(std::make_pair("cim:GovHydroIEEE2.gv6", &assign_GovHydroIEEE2_gv6));
	dynamic_switch.insert(std::make_pair("cim:GovHydroIEEE2.kturb", &assign_GovHydroIEEE2_kturb));
	dynamic_switch.insert(std::make_pair("cim:GovHydroIEEE2.mwbase", &assign_GovHydroIEEE2_mwbase));
	dynamic_switch.insert(std::make_pair("cim:GovHydroIEEE2.pgv1", &assign_GovHydroIEEE2_pgv1));
	dynamic_switch.insert(std::make_pair("cim:GovHydroIEEE2.pgv2", &assign_GovHydroIEEE2_pgv2));
	dynamic_switch.insert(std::make_pair("cim:GovHydroIEEE2.pgv3", &assign_GovHydroIEEE2_pgv3));
	dynamic_switch.insert(std::make_pair("cim:GovHydroIEEE2.pgv4", &assign_GovHydroIEEE2_pgv4));
	dynamic_switch.insert(std::make_pair("cim:GovHydroIEEE2.pgv5", &assign_GovHydroIEEE2_pgv5));
	dynamic_switch.insert(std::make_pair("cim:GovHydroIEEE2.pgv6", &assign_GovHydroIEEE2_pgv6));
	dynamic_switch.insert(std::make_pair("cim:GovHydroIEEE2.pmax", &assign_GovHydroIEEE2_pmax));
	dynamic_switch.insert(std::make_pair("cim:GovHydroIEEE2.pmin", &assign_GovHydroIEEE2_pmin));
	dynamic_switch.insert(std::make_pair("cim:GovHydroIEEE2.rperm", &assign_GovHydroIEEE2_rperm));
	dynamic_switch.insert(std::make_pair("cim:GovHydroIEEE2.rtemp", &assign_GovHydroIEEE2_rtemp));
	dynamic_switch.insert(std::make_pair("cim:GovHydroIEEE2.tg", &assign_GovHydroIEEE2_tg));
	dynamic_switch.insert(std::make_pair("cim:GovHydroIEEE2.tp", &assign_GovHydroIEEE2_tp));
	dynamic_switch.insert(std::make_pair("cim:GovHydroIEEE2.tr", &assign_GovHydroIEEE2_tr));
	dynamic_switch.insert(std::make_pair("cim:GovHydroIEEE2.tw", &assign_GovHydroIEEE2_tw));
	dynamic_switch.insert(std::make_pair("cim:GovHydroIEEE2.uc", &assign_GovHydroIEEE2_uc));
	dynamic_switch.insert(std::make_pair("cim:GovHydroIEEE2.uo", &assign_GovHydroIEEE2_uo));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPelton.av0", &assign_GovHydroPelton_av0));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPelton.av1", &assign_GovHydroPelton_av1));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPelton.bp", &assign_GovHydroPelton_bp));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPelton.db1", &assign_GovHydroPelton_db1));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPelton.db2", &assign_GovHydroPelton_db2));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPelton.h1", &assign_GovHydroPelton_h1));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPelton.h2", &assign_GovHydroPelton_h2));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPelton.hn", &assign_GovHydroPelton_hn));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPelton.kc", &assign_GovHydroPelton_kc));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPelton.kg", &assign_GovHydroPelton_kg));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPelton.qc0", &assign_GovHydroPelton_qc0));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPelton.qn", &assign_GovHydroPelton_qn));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPelton.simplifiedPelton", &assign_GovHydroPelton_simplifiedPelton));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPelton.staticCompensating", &assign_GovHydroPelton_staticCompensating));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPelton.ta", &assign_GovHydroPelton_ta));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPelton.ts", &assign_GovHydroPelton_ts));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPelton.tv", &assign_GovHydroPelton_tv));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPelton.twnc", &assign_GovHydroPelton_twnc));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPelton.twng", &assign_GovHydroPelton_twng));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPelton.tx", &assign_GovHydroPelton_tx));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPelton.va", &assign_GovHydroPelton_va));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPelton.valvmax", &assign_GovHydroPelton_valvmax));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPelton.valvmin", &assign_GovHydroPelton_valvmin));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPelton.vav", &assign_GovHydroPelton_vav));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPelton.vc", &assign_GovHydroPelton_vc));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPelton.vcv", &assign_GovHydroPelton_vcv));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPelton.waterTunnelSurgeChamberSimulation", &assign_GovHydroPelton_waterTunnelSurgeChamberSimulation));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPelton.zsfc", &assign_GovHydroPelton_zsfc));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPID.aturb", &assign_GovHydroPID_aturb));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPID.bturb", &assign_GovHydroPID_bturb));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPID.db1", &assign_GovHydroPID_db1));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPID.db2", &assign_GovHydroPID_db2));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPID.eps", &assign_GovHydroPID_eps));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPID.gv1", &assign_GovHydroPID_gv1));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPID.gv2", &assign_GovHydroPID_gv2));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPID.gv3", &assign_GovHydroPID_gv3));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPID.gv4", &assign_GovHydroPID_gv4));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPID.gv5", &assign_GovHydroPID_gv5));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPID.gv6", &assign_GovHydroPID_gv6));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPID.inputSignal", &assign_GovHydroPID_inputSignal));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPID.kd", &assign_GovHydroPID_kd));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPID.kg", &assign_GovHydroPID_kg));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPID.ki", &assign_GovHydroPID_ki));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPID.kp", &assign_GovHydroPID_kp));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPID.mwbase", &assign_GovHydroPID_mwbase));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPID.pgv1", &assign_GovHydroPID_pgv1));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPID.pgv2", &assign_GovHydroPID_pgv2));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPID.pgv3", &assign_GovHydroPID_pgv3));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPID.pgv4", &assign_GovHydroPID_pgv4));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPID.pgv5", &assign_GovHydroPID_pgv5));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPID.pgv6", &assign_GovHydroPID_pgv6));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPID.pmax", &assign_GovHydroPID_pmax));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPID.pmin", &assign_GovHydroPID_pmin));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPID.r", &assign_GovHydroPID_r));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPID.td", &assign_GovHydroPID_td));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPID.tf", &assign_GovHydroPID_tf));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPID.tp", &assign_GovHydroPID_tp));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPID.tt", &assign_GovHydroPID_tt));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPID.tturb", &assign_GovHydroPID_tturb));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPID.velcl", &assign_GovHydroPID_velcl));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPID.velop", &assign_GovHydroPID_velop));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPID2.atw", &assign_GovHydroPID2_atw));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPID2.d", &assign_GovHydroPID2_d));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPID2.feedbackSignal", &assign_GovHydroPID2_feedbackSignal));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPID2.g0", &assign_GovHydroPID2_g0));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPID2.g1", &assign_GovHydroPID2_g1));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPID2.g2", &assign_GovHydroPID2_g2));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPID2.gmax", &assign_GovHydroPID2_gmax));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPID2.gmin", &assign_GovHydroPID2_gmin));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPID2.kd", &assign_GovHydroPID2_kd));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPID2.ki", &assign_GovHydroPID2_ki));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPID2.kp", &assign_GovHydroPID2_kp));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPID2.mwbase", &assign_GovHydroPID2_mwbase));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPID2.p1", &assign_GovHydroPID2_p1));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPID2.p2", &assign_GovHydroPID2_p2));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPID2.p3", &assign_GovHydroPID2_p3));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPID2.rperm", &assign_GovHydroPID2_rperm));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPID2.ta", &assign_GovHydroPID2_ta));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPID2.tb", &assign_GovHydroPID2_tb));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPID2.treg", &assign_GovHydroPID2_treg));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPID2.tw", &assign_GovHydroPID2_tw));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPID2.velmax", &assign_GovHydroPID2_velmax));
	dynamic_switch.insert(std::make_pair("cim:GovHydroPID2.velmin", &assign_GovHydroPID2_velmin));
	dynamic_switch.insert(std::make_pair("cim:GovHydroR.at", &assign_GovHydroR_at));
	dynamic_switch.insert(std::make_pair("cim:GovHydroR.db1", &assign_GovHydroR_db1));
	dynamic_switch.insert(std::make_pair("cim:GovHydroR.db2", &assign_GovHydroR_db2));
	dynamic_switch.insert(std::make_pair("cim:GovHydroR.dturb", &assign_GovHydroR_dturb));
	dynamic_switch.insert(std::make_pair("cim:GovHydroR.eps", &assign_GovHydroR_eps));
	dynamic_switch.insert(std::make_pair("cim:GovHydroR.gmax", &assign_GovHydroR_gmax));
	dynamic_switch.insert(std::make_pair("cim:GovHydroR.gmin", &assign_GovHydroR_gmin));
	dynamic_switch.insert(std::make_pair("cim:GovHydroR.gv1", &assign_GovHydroR_gv1));
	dynamic_switch.insert(std::make_pair("cim:GovHydroR.gv2", &assign_GovHydroR_gv2));
	dynamic_switch.insert(std::make_pair("cim:GovHydroR.gv3", &assign_GovHydroR_gv3));
	dynamic_switch.insert(std::make_pair("cim:GovHydroR.gv4", &assign_GovHydroR_gv4));
	dynamic_switch.insert(std::make_pair("cim:GovHydroR.gv5", &assign_GovHydroR_gv5));
	dynamic_switch.insert(std::make_pair("cim:GovHydroR.gv6", &assign_GovHydroR_gv6));
	dynamic_switch.insert(std::make_pair("cim:GovHydroR.h0", &assign_GovHydroR_h0));
	dynamic_switch.insert(std::make_pair("cim:GovHydroR.inputSignal", &assign_GovHydroR_inputSignal));
	dynamic_switch.insert(std::make_pair("cim:GovHydroR.kg", &assign_GovHydroR_kg));
	dynamic_switch.insert(std::make_pair("cim:GovHydroR.ki", &assign_GovHydroR_ki));
	dynamic_switch.insert(std::make_pair("cim:GovHydroR.mwbase", &assign_GovHydroR_mwbase));
	dynamic_switch.insert(std::make_pair("cim:GovHydroR.pgv1", &assign_GovHydroR_pgv1));
	dynamic_switch.insert(std::make_pair("cim:GovHydroR.pgv2", &assign_GovHydroR_pgv2));
	dynamic_switch.insert(std::make_pair("cim:GovHydroR.pgv3", &assign_GovHydroR_pgv3));
	dynamic_switch.insert(std::make_pair("cim:GovHydroR.pgv4", &assign_GovHydroR_pgv4));
	dynamic_switch.insert(std::make_pair("cim:GovHydroR.pgv5", &assign_GovHydroR_pgv5));
	dynamic_switch.insert(std::make_pair("cim:GovHydroR.pgv6", &assign_GovHydroR_pgv6));
	dynamic_switch.insert(std::make_pair("cim:GovHydroR.pmax", &assign_GovHydroR_pmax));
	dynamic_switch.insert(std::make_pair("cim:GovHydroR.pmin", &assign_GovHydroR_pmin));
	dynamic_switch.insert(std::make_pair("cim:GovHydroR.qnl", &assign_GovHydroR_qnl));
	dynamic_switch.insert(std::make_pair("cim:GovHydroR.r", &assign_GovHydroR_r));
	dynamic_switch.insert(std::make_pair("cim:GovHydroR.t1", &assign_GovHydroR_t1));
	dynamic_switch.insert(std::make_pair("cim:GovHydroR.t2", &assign_GovHydroR_t2));
	dynamic_switch.insert(std::make_pair("cim:GovHydroR.t3", &assign_GovHydroR_t3));
	dynamic_switch.insert(std::make_pair("cim:GovHydroR.t4", &assign_GovHydroR_t4));
	dynamic_switch.insert(std::make_pair("cim:GovHydroR.t5", &assign_GovHydroR_t5));
	dynamic_switch.insert(std::make_pair("cim:GovHydroR.t6", &assign_GovHydroR_t6));
	dynamic_switch.insert(std::make_pair("cim:GovHydroR.t7", &assign_GovHydroR_t7));
	dynamic_switch.insert(std::make_pair("cim:GovHydroR.t8", &assign_GovHydroR_t8));
	dynamic_switch.insert(std::make_pair("cim:GovHydroR.td", &assign_GovHydroR_td));
	dynamic_switch.insert(std::make_pair("cim:GovHydroR.tp", &assign_GovHydroR_tp));
	dynamic_switch.insert(std::make_pair("cim:GovHydroR.tt", &assign_GovHydroR_tt));
	dynamic_switch.insert(std::make_pair("cim:GovHydroR.tw", &assign_GovHydroR_tw));
	dynamic_switch.insert(std::make_pair("cim:GovHydroR.velcl", &assign_GovHydroR_velcl));
	dynamic_switch.insert(std::make_pair("cim:GovHydroR.velop", &assign_GovHydroR_velop));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWEH.db", &assign_GovHydroWEH_db));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWEH.dicn", &assign_GovHydroWEH_dicn));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWEH.dpv", &assign_GovHydroWEH_dpv));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWEH.dturb", &assign_GovHydroWEH_dturb));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWEH.feedbackSignal", &assign_GovHydroWEH_feedbackSignal));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWEH.fl1", &assign_GovHydroWEH_fl1));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWEH.fl2", &assign_GovHydroWEH_fl2));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWEH.fl3", &assign_GovHydroWEH_fl3));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWEH.fl4", &assign_GovHydroWEH_fl4));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWEH.fl5", &assign_GovHydroWEH_fl5));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWEH.fp1", &assign_GovHydroWEH_fp1));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWEH.fp10", &assign_GovHydroWEH_fp10));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWEH.fp2", &assign_GovHydroWEH_fp2));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWEH.fp3", &assign_GovHydroWEH_fp3));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWEH.fp4", &assign_GovHydroWEH_fp4));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWEH.fp5", &assign_GovHydroWEH_fp5));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWEH.fp6", &assign_GovHydroWEH_fp6));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWEH.fp7", &assign_GovHydroWEH_fp7));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWEH.fp8", &assign_GovHydroWEH_fp8));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWEH.fp9", &assign_GovHydroWEH_fp9));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWEH.gmax", &assign_GovHydroWEH_gmax));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWEH.gmin", &assign_GovHydroWEH_gmin));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWEH.gtmxcl", &assign_GovHydroWEH_gtmxcl));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWEH.gtmxop", &assign_GovHydroWEH_gtmxop));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWEH.gv1", &assign_GovHydroWEH_gv1));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWEH.gv2", &assign_GovHydroWEH_gv2));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWEH.gv3", &assign_GovHydroWEH_gv3));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWEH.gv4", &assign_GovHydroWEH_gv4));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWEH.gv5", &assign_GovHydroWEH_gv5));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWEH.kd", &assign_GovHydroWEH_kd));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWEH.ki", &assign_GovHydroWEH_ki));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWEH.kp", &assign_GovHydroWEH_kp));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWEH.mwbase", &assign_GovHydroWEH_mwbase));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWEH.pmss1", &assign_GovHydroWEH_pmss1));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWEH.pmss10", &assign_GovHydroWEH_pmss10));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWEH.pmss2", &assign_GovHydroWEH_pmss2));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWEH.pmss3", &assign_GovHydroWEH_pmss3));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWEH.pmss4", &assign_GovHydroWEH_pmss4));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWEH.pmss5", &assign_GovHydroWEH_pmss5));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWEH.pmss6", &assign_GovHydroWEH_pmss6));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWEH.pmss7", &assign_GovHydroWEH_pmss7));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWEH.pmss8", &assign_GovHydroWEH_pmss8));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWEH.pmss9", &assign_GovHydroWEH_pmss9));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWEH.rpg", &assign_GovHydroWEH_rpg));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWEH.rpp", &assign_GovHydroWEH_rpp));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWEH.td", &assign_GovHydroWEH_td));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWEH.tdv", &assign_GovHydroWEH_tdv));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWEH.tg", &assign_GovHydroWEH_tg));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWEH.tp", &assign_GovHydroWEH_tp));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWEH.tpe", &assign_GovHydroWEH_tpe));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWEH.tw", &assign_GovHydroWEH_tw));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWPID.d", &assign_GovHydroWPID_d));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWPID.gatmax", &assign_GovHydroWPID_gatmax));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWPID.gatmin", &assign_GovHydroWPID_gatmin));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWPID.gv1", &assign_GovHydroWPID_gv1));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWPID.gv2", &assign_GovHydroWPID_gv2));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWPID.gv3", &assign_GovHydroWPID_gv3));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWPID.kd", &assign_GovHydroWPID_kd));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWPID.ki", &assign_GovHydroWPID_ki));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWPID.kp", &assign_GovHydroWPID_kp));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWPID.mwbase", &assign_GovHydroWPID_mwbase));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWPID.pgv1", &assign_GovHydroWPID_pgv1));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWPID.pgv2", &assign_GovHydroWPID_pgv2));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWPID.pgv3", &assign_GovHydroWPID_pgv3));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWPID.pmax", &assign_GovHydroWPID_pmax));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWPID.pmin", &assign_GovHydroWPID_pmin));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWPID.reg", &assign_GovHydroWPID_reg));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWPID.ta", &assign_GovHydroWPID_ta));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWPID.tb", &assign_GovHydroWPID_tb));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWPID.treg", &assign_GovHydroWPID_treg));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWPID.tw", &assign_GovHydroWPID_tw));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWPID.velmax", &assign_GovHydroWPID_velmax));
	dynamic_switch.insert(std::make_pair("cim:GovHydroWPID.velmin", &assign_GovHydroWPID_velmin));
	dynamic_switch.insert(std::make_pair("cim:GovSteam0.dt", &assign_GovSteam0_dt));
	dynamic_switch.insert(std::make_pair("cim:GovSteam0.mwbase", &assign_GovSteam0_mwbase));
	dynamic_switch.insert(std::make_pair("cim:GovSteam0.r", &assign_GovSteam0_r));
	dynamic_switch.insert(std::make_pair("cim:GovSteam0.t1", &assign_GovSteam0_t1));
	dynamic_switch.insert(std::make_pair("cim:GovSteam0.t2", &assign_GovSteam0_t2));
	dynamic_switch.insert(std::make_pair("cim:GovSteam0.t3", &assign_GovSteam0_t3));
	dynamic_switch.insert(std::make_pair("cim:GovSteam0.vmax", &assign_GovSteam0_vmax));
	dynamic_switch.insert(std::make_pair("cim:GovSteam0.vmin", &assign_GovSteam0_vmin));
	dynamic_switch.insert(std::make_pair("cim:GovSteam1.db1", &assign_GovSteam1_db1));
	dynamic_switch.insert(std::make_pair("cim:GovSteam1.db2", &assign_GovSteam1_db2));
	dynamic_switch.insert(std::make_pair("cim:GovSteam1.eps", &assign_GovSteam1_eps));
	dynamic_switch.insert(std::make_pair("cim:GovSteam1.gv1", &assign_GovSteam1_gv1));
	dynamic_switch.insert(std::make_pair("cim:GovSteam1.gv2", &assign_GovSteam1_gv2));
	dynamic_switch.insert(std::make_pair("cim:GovSteam1.gv3", &assign_GovSteam1_gv3));
	dynamic_switch.insert(std::make_pair("cim:GovSteam1.gv4", &assign_GovSteam1_gv4));
	dynamic_switch.insert(std::make_pair("cim:GovSteam1.gv5", &assign_GovSteam1_gv5));
	dynamic_switch.insert(std::make_pair("cim:GovSteam1.gv6", &assign_GovSteam1_gv6));
	dynamic_switch.insert(std::make_pair("cim:GovSteam1.k", &assign_GovSteam1_k));
	dynamic_switch.insert(std::make_pair("cim:GovSteam1.k1", &assign_GovSteam1_k1));
	dynamic_switch.insert(std::make_pair("cim:GovSteam1.k2", &assign_GovSteam1_k2));
	dynamic_switch.insert(std::make_pair("cim:GovSteam1.k3", &assign_GovSteam1_k3));
	dynamic_switch.insert(std::make_pair("cim:GovSteam1.k4", &assign_GovSteam1_k4));
	dynamic_switch.insert(std::make_pair("cim:GovSteam1.k5", &assign_GovSteam1_k5));
	dynamic_switch.insert(std::make_pair("cim:GovSteam1.k6", &assign_GovSteam1_k6));
	dynamic_switch.insert(std::make_pair("cim:GovSteam1.k7", &assign_GovSteam1_k7));
	dynamic_switch.insert(std::make_pair("cim:GovSteam1.k8", &assign_GovSteam1_k8));
	dynamic_switch.insert(std::make_pair("cim:GovSteam1.mwbase", &assign_GovSteam1_mwbase));
	dynamic_switch.insert(std::make_pair("cim:GovSteam1.pgv1", &assign_GovSteam1_pgv1));
	dynamic_switch.insert(std::make_pair("cim:GovSteam1.pgv2", &assign_GovSteam1_pgv2));
	dynamic_switch.insert(std::make_pair("cim:GovSteam1.pgv3", &assign_GovSteam1_pgv3));
	dynamic_switch.insert(std::make_pair("cim:GovSteam1.pgv4", &assign_GovSteam1_pgv4));
	dynamic_switch.insert(std::make_pair("cim:GovSteam1.pgv5", &assign_GovSteam1_pgv5));
	dynamic_switch.insert(std::make_pair("cim:GovSteam1.pgv6", &assign_GovSteam1_pgv6));
	dynamic_switch.insert(std::make_pair("cim:GovSteam1.pmax", &assign_GovSteam1_pmax));
	dynamic_switch.insert(std::make_pair("cim:GovSteam1.pmin", &assign_GovSteam1_pmin));
	dynamic_switch.insert(std::make_pair("cim:GovSteam1.sdb1", &assign_GovSteam1_sdb1));
	dynamic_switch.insert(std::make_pair("cim:GovSteam1.sdb2", &assign_GovSteam1_sdb2));
	dynamic_switch.insert(std::make_pair("cim:GovSteam1.t1", &assign_GovSteam1_t1));
	dynamic_switch.insert(std::make_pair("cim:GovSteam1.t2", &assign_GovSteam1_t2));
	dynamic_switch.insert(std::make_pair("cim:GovSteam1.t3", &assign_GovSteam1_t3));
	dynamic_switch.insert(std::make_pair("cim:GovSteam1.t4", &assign_GovSteam1_t4));
	dynamic_switch.insert(std::make_pair("cim:GovSteam1.t5", &assign_GovSteam1_t5));
	dynamic_switch.insert(std::make_pair("cim:GovSteam1.t6", &assign_GovSteam1_t6));
	dynamic_switch.insert(std::make_pair("cim:GovSteam1.t7", &assign_GovSteam1_t7));
	dynamic_switch.insert(std::make_pair("cim:GovSteam1.uc", &assign_GovSteam1_uc));
	dynamic_switch.insert(std::make_pair("cim:GovSteam1.uo", &assign_GovSteam1_uo));
	dynamic_switch.insert(std::make_pair("cim:GovSteam1.valve", &assign_GovSteam1_valve));
	dynamic_switch.insert(std::make_pair("cim:GovSteam2.dbf", &assign_GovSteam2_dbf));
	dynamic_switch.insert(std::make_pair("cim:GovSteam2.k", &assign_GovSteam2_k));
	dynamic_switch.insert(std::make_pair("cim:GovSteam2.mnef", &assign_GovSteam2_mnef));
	dynamic_switch.insert(std::make_pair("cim:GovSteam2.mxef", &assign_GovSteam2_mxef));
	dynamic_switch.insert(std::make_pair("cim:GovSteam2.pmax", &assign_GovSteam2_pmax));
	dynamic_switch.insert(std::make_pair("cim:GovSteam2.pmin", &assign_GovSteam2_pmin));
	dynamic_switch.insert(std::make_pair("cim:GovSteam2.t1", &assign_GovSteam2_t1));
	dynamic_switch.insert(std::make_pair("cim:GovSteam2.t2", &assign_GovSteam2_t2));
	dynamic_switch.insert(std::make_pair("cim:GovSteamCC.dhp", &assign_GovSteamCC_dhp));
	dynamic_switch.insert(std::make_pair("cim:GovSteamCC.dlp", &assign_GovSteamCC_dlp));
	dynamic_switch.insert(std::make_pair("cim:GovSteamCC.fhp", &assign_GovSteamCC_fhp));
	dynamic_switch.insert(std::make_pair("cim:GovSteamCC.flp", &assign_GovSteamCC_flp));
	dynamic_switch.insert(std::make_pair("cim:GovSteamCC.mwbase", &assign_GovSteamCC_mwbase));
	dynamic_switch.insert(std::make_pair("cim:GovSteamCC.pmaxhp", &assign_GovSteamCC_pmaxhp));
	dynamic_switch.insert(std::make_pair("cim:GovSteamCC.pmaxlp", &assign_GovSteamCC_pmaxlp));
	dynamic_switch.insert(std::make_pair("cim:GovSteamCC.rhp", &assign_GovSteamCC_rhp));
	dynamic_switch.insert(std::make_pair("cim:GovSteamCC.rlp", &assign_GovSteamCC_rlp));
	dynamic_switch.insert(std::make_pair("cim:GovSteamCC.t1hp", &assign_GovSteamCC_t1hp));
	dynamic_switch.insert(std::make_pair("cim:GovSteamCC.t1lp", &assign_GovSteamCC_t1lp));
	dynamic_switch.insert(std::make_pair("cim:GovSteamCC.t3hp", &assign_GovSteamCC_t3hp));
	dynamic_switch.insert(std::make_pair("cim:GovSteamCC.t3lp", &assign_GovSteamCC_t3lp));
	dynamic_switch.insert(std::make_pair("cim:GovSteamCC.t4hp", &assign_GovSteamCC_t4hp));
	dynamic_switch.insert(std::make_pair("cim:GovSteamCC.t4lp", &assign_GovSteamCC_t4lp));
	dynamic_switch.insert(std::make_pair("cim:GovSteamCC.t5hp", &assign_GovSteamCC_t5hp));
	dynamic_switch.insert(std::make_pair("cim:GovSteamCC.t5lp", &assign_GovSteamCC_t5lp));
	dynamic_switch.insert(std::make_pair("cim:GovSteamEU.chc", &assign_GovSteamEU_chc));
	dynamic_switch.insert(std::make_pair("cim:GovSteamEU.cho", &assign_GovSteamEU_cho));
	dynamic_switch.insert(std::make_pair("cim:GovSteamEU.cic", &assign_GovSteamEU_cic));
	dynamic_switch.insert(std::make_pair("cim:GovSteamEU.cio", &assign_GovSteamEU_cio));
	dynamic_switch.insert(std::make_pair("cim:GovSteamEU.db1", &assign_GovSteamEU_db1));
	dynamic_switch.insert(std::make_pair("cim:GovSteamEU.db2", &assign_GovSteamEU_db2));
	dynamic_switch.insert(std::make_pair("cim:GovSteamEU.hhpmax", &assign_GovSteamEU_hhpmax));
	dynamic_switch.insert(std::make_pair("cim:GovSteamEU.ke", &assign_GovSteamEU_ke));
	dynamic_switch.insert(std::make_pair("cim:GovSteamEU.kfcor", &assign_GovSteamEU_kfcor));
	dynamic_switch.insert(std::make_pair("cim:GovSteamEU.khp", &assign_GovSteamEU_khp));
	dynamic_switch.insert(std::make_pair("cim:GovSteamEU.klp", &assign_GovSteamEU_klp));
	dynamic_switch.insert(std::make_pair("cim:GovSteamEU.kwcor", &assign_GovSteamEU_kwcor));
	dynamic_switch.insert(std::make_pair("cim:GovSteamEU.mwbase", &assign_GovSteamEU_mwbase));
	dynamic_switch.insert(std::make_pair("cim:GovSteamEU.pmax", &assign_GovSteamEU_pmax));
	dynamic_switch.insert(std::make_pair("cim:GovSteamEU.prhmax", &assign_GovSteamEU_prhmax));
	dynamic_switch.insert(std::make_pair("cim:GovSteamEU.simx", &assign_GovSteamEU_simx));
	dynamic_switch.insert(std::make_pair("cim:GovSteamEU.tb", &assign_GovSteamEU_tb));
	dynamic_switch.insert(std::make_pair("cim:GovSteamEU.tdp", &assign_GovSteamEU_tdp));
	dynamic_switch.insert(std::make_pair("cim:GovSteamEU.ten", &assign_GovSteamEU_ten));
	dynamic_switch.insert(std::make_pair("cim:GovSteamEU.tf", &assign_GovSteamEU_tf));
	dynamic_switch.insert(std::make_pair("cim:GovSteamEU.tfp", &assign_GovSteamEU_tfp));
	dynamic_switch.insert(std::make_pair("cim:GovSteamEU.thp", &assign_GovSteamEU_thp));
	dynamic_switch.insert(std::make_pair("cim:GovSteamEU.tip", &assign_GovSteamEU_tip));
	dynamic_switch.insert(std::make_pair("cim:GovSteamEU.tlp", &assign_GovSteamEU_tlp));
	dynamic_switch.insert(std::make_pair("cim:GovSteamEU.tp", &assign_GovSteamEU_tp));
	dynamic_switch.insert(std::make_pair("cim:GovSteamEU.trh", &assign_GovSteamEU_trh));
	dynamic_switch.insert(std::make_pair("cim:GovSteamEU.tvhp", &assign_GovSteamEU_tvhp));
	dynamic_switch.insert(std::make_pair("cim:GovSteamEU.tvip", &assign_GovSteamEU_tvip));
	dynamic_switch.insert(std::make_pair("cim:GovSteamEU.tw", &assign_GovSteamEU_tw));
	dynamic_switch.insert(std::make_pair("cim:GovSteamEU.wfmax", &assign_GovSteamEU_wfmax));
	dynamic_switch.insert(std::make_pair("cim:GovSteamEU.wfmin", &assign_GovSteamEU_wfmin));
	dynamic_switch.insert(std::make_pair("cim:GovSteamEU.wmax1", &assign_GovSteamEU_wmax1));
	dynamic_switch.insert(std::make_pair("cim:GovSteamEU.wmax2", &assign_GovSteamEU_wmax2));
	dynamic_switch.insert(std::make_pair("cim:GovSteamEU.wwmax", &assign_GovSteamEU_wwmax));
	dynamic_switch.insert(std::make_pair("cim:GovSteamEU.wwmin", &assign_GovSteamEU_wwmin));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV2.dt", &assign_GovSteamFV2_dt));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV2.k", &assign_GovSteamFV2_k));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV2.mwbase", &assign_GovSteamFV2_mwbase));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV2.r", &assign_GovSteamFV2_r));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV2.t1", &assign_GovSteamFV2_t1));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV2.t3", &assign_GovSteamFV2_t3));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV2.ta", &assign_GovSteamFV2_ta));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV2.tb", &assign_GovSteamFV2_tb));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV2.tc", &assign_GovSteamFV2_tc));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV2.ti", &assign_GovSteamFV2_ti));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV2.tt", &assign_GovSteamFV2_tt));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV2.vmax", &assign_GovSteamFV2_vmax));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV2.vmin", &assign_GovSteamFV2_vmin));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV3.k", &assign_GovSteamFV3_k));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV3.k1", &assign_GovSteamFV3_k1));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV3.k2", &assign_GovSteamFV3_k2));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV3.k3", &assign_GovSteamFV3_k3));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV3.mwbase", &assign_GovSteamFV3_mwbase));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV3.pmax", &assign_GovSteamFV3_pmax));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV3.pmin", &assign_GovSteamFV3_pmin));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV3.prmax", &assign_GovSteamFV3_prmax));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV3.t1", &assign_GovSteamFV3_t1));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV3.t2", &assign_GovSteamFV3_t2));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV3.t3", &assign_GovSteamFV3_t3));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV3.t4", &assign_GovSteamFV3_t4));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV3.t5", &assign_GovSteamFV3_t5));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV3.t6", &assign_GovSteamFV3_t6));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV3.ta", &assign_GovSteamFV3_ta));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV3.tb", &assign_GovSteamFV3_tb));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV3.tc", &assign_GovSteamFV3_tc));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV3.uc", &assign_GovSteamFV3_uc));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV3.uo", &assign_GovSteamFV3_uo));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV4.cpsmn", &assign_GovSteamFV4_cpsmn));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV4.cpsmx", &assign_GovSteamFV4_cpsmx));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV4.crmn", &assign_GovSteamFV4_crmn));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV4.crmx", &assign_GovSteamFV4_crmx));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV4.kdc", &assign_GovSteamFV4_kdc));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV4.kf1", &assign_GovSteamFV4_kf1));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV4.kf3", &assign_GovSteamFV4_kf3));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV4.khp", &assign_GovSteamFV4_khp));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV4.kic", &assign_GovSteamFV4_kic));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV4.kip", &assign_GovSteamFV4_kip));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV4.kit", &assign_GovSteamFV4_kit));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV4.kmp1", &assign_GovSteamFV4_kmp1));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV4.kmp2", &assign_GovSteamFV4_kmp2));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV4.kpc", &assign_GovSteamFV4_kpc));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV4.kpp", &assign_GovSteamFV4_kpp));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV4.kpt", &assign_GovSteamFV4_kpt));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV4.krc", &assign_GovSteamFV4_krc));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV4.ksh", &assign_GovSteamFV4_ksh));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV4.lpi", &assign_GovSteamFV4_lpi));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV4.lps", &assign_GovSteamFV4_lps));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV4.mnef", &assign_GovSteamFV4_mnef));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV4.mxef", &assign_GovSteamFV4_mxef));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV4.pr1", &assign_GovSteamFV4_pr1));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV4.pr2", &assign_GovSteamFV4_pr2));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV4.psmn", &assign_GovSteamFV4_psmn));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV4.rsmimn", &assign_GovSteamFV4_rsmimn));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV4.rsmimx", &assign_GovSteamFV4_rsmimx));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV4.rvgmn", &assign_GovSteamFV4_rvgmn));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV4.rvgmx", &assign_GovSteamFV4_rvgmx));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV4.srmn", &assign_GovSteamFV4_srmn));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV4.srmx", &assign_GovSteamFV4_srmx));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV4.srsmp", &assign_GovSteamFV4_srsmp));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV4.svmn", &assign_GovSteamFV4_svmn));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV4.svmx", &assign_GovSteamFV4_svmx));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV4.ta", &assign_GovSteamFV4_ta));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV4.tam", &assign_GovSteamFV4_tam));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV4.tc", &assign_GovSteamFV4_tc));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV4.tcm", &assign_GovSteamFV4_tcm));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV4.tdc", &assign_GovSteamFV4_tdc));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV4.tf1", &assign_GovSteamFV4_tf1));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV4.tf2", &assign_GovSteamFV4_tf2));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV4.thp", &assign_GovSteamFV4_thp));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV4.tmp", &assign_GovSteamFV4_tmp));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV4.trh", &assign_GovSteamFV4_trh));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV4.tv", &assign_GovSteamFV4_tv));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV4.ty", &assign_GovSteamFV4_ty));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV4.y", &assign_GovSteamFV4_y));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV4.yhpmn", &assign_GovSteamFV4_yhpmn));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV4.yhpmx", &assign_GovSteamFV4_yhpmx));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV4.ympmn", &assign_GovSteamFV4_ympmn));
	dynamic_switch.insert(std::make_pair("cim:GovSteamFV4.ympmx", &assign_GovSteamFV4_ympmx));
	dynamic_switch.insert(std::make_pair("cim:GovSteamIEEE1.k", &assign_GovSteamIEEE1_k));
	dynamic_switch.insert(std::make_pair("cim:GovSteamIEEE1.k1", &assign_GovSteamIEEE1_k1));
	dynamic_switch.insert(std::make_pair("cim:GovSteamIEEE1.k2", &assign_GovSteamIEEE1_k2));
	dynamic_switch.insert(std::make_pair("cim:GovSteamIEEE1.k3", &assign_GovSteamIEEE1_k3));
	dynamic_switch.insert(std::make_pair("cim:GovSteamIEEE1.k4", &assign_GovSteamIEEE1_k4));
	dynamic_switch.insert(std::make_pair("cim:GovSteamIEEE1.k5", &assign_GovSteamIEEE1_k5));
	dynamic_switch.insert(std::make_pair("cim:GovSteamIEEE1.k6", &assign_GovSteamIEEE1_k6));
	dynamic_switch.insert(std::make_pair("cim:GovSteamIEEE1.k7", &assign_GovSteamIEEE1_k7));
	dynamic_switch.insert(std::make_pair("cim:GovSteamIEEE1.k8", &assign_GovSteamIEEE1_k8));
	dynamic_switch.insert(std::make_pair("cim:GovSteamIEEE1.mwbase", &assign_GovSteamIEEE1_mwbase));
	dynamic_switch.insert(std::make_pair("cim:GovSteamIEEE1.pmax", &assign_GovSteamIEEE1_pmax));
	dynamic_switch.insert(std::make_pair("cim:GovSteamIEEE1.pmin", &assign_GovSteamIEEE1_pmin));
	dynamic_switch.insert(std::make_pair("cim:GovSteamIEEE1.t1", &assign_GovSteamIEEE1_t1));
	dynamic_switch.insert(std::make_pair("cim:GovSteamIEEE1.t2", &assign_GovSteamIEEE1_t2));
	dynamic_switch.insert(std::make_pair("cim:GovSteamIEEE1.t3", &assign_GovSteamIEEE1_t3));
	dynamic_switch.insert(std::make_pair("cim:GovSteamIEEE1.t4", &assign_GovSteamIEEE1_t4));
	dynamic_switch.insert(std::make_pair("cim:GovSteamIEEE1.t5", &assign_GovSteamIEEE1_t5));
	dynamic_switch.insert(std::make_pair("cim:GovSteamIEEE1.t6", &assign_GovSteamIEEE1_t6));
	dynamic_switch.insert(std::make_pair("cim:GovSteamIEEE1.t7", &assign_GovSteamIEEE1_t7));
	dynamic_switch.insert(std::make_pair("cim:GovSteamIEEE1.uc", &assign_GovSteamIEEE1_uc));
	dynamic_switch.insert(std::make_pair("cim:GovSteamIEEE1.uo", &assign_GovSteamIEEE1_uo));
	dynamic_switch.insert(std::make_pair("cim:GovSteamSGO.k1", &assign_GovSteamSGO_k1));
	dynamic_switch.insert(std::make_pair("cim:GovSteamSGO.k2", &assign_GovSteamSGO_k2));
	dynamic_switch.insert(std::make_pair("cim:GovSteamSGO.k3", &assign_GovSteamSGO_k3));
	dynamic_switch.insert(std::make_pair("cim:GovSteamSGO.mwbase", &assign_GovSteamSGO_mwbase));
	dynamic_switch.insert(std::make_pair("cim:GovSteamSGO.pmax", &assign_GovSteamSGO_pmax));
	dynamic_switch.insert(std::make_pair("cim:GovSteamSGO.pmin", &assign_GovSteamSGO_pmin));
	dynamic_switch.insert(std::make_pair("cim:GovSteamSGO.t1", &assign_GovSteamSGO_t1));
	dynamic_switch.insert(std::make_pair("cim:GovSteamSGO.t2", &assign_GovSteamSGO_t2));
	dynamic_switch.insert(std::make_pair("cim:GovSteamSGO.t3", &assign_GovSteamSGO_t3));
	dynamic_switch.insert(std::make_pair("cim:GovSteamSGO.t4", &assign_GovSteamSGO_t4));
	dynamic_switch.insert(std::make_pair("cim:GovSteamSGO.t5", &assign_GovSteamSGO_t5));
	dynamic_switch.insert(std::make_pair("cim:GovSteamSGO.t6", &assign_GovSteamSGO_t6));
	dynamic_switch.insert(std::make_pair("cim:TurbLCFB1.db", &assign_TurbLCFB1_db));
	dynamic_switch.insert(std::make_pair("cim:TurbLCFB1.emax", &assign_TurbLCFB1_emax));
	dynamic_switch.insert(std::make_pair("cim:TurbLCFB1.fb", &assign_TurbLCFB1_fb));
	dynamic_switch.insert(std::make_pair("cim:TurbLCFB1.fbf", &assign_TurbLCFB1_fbf));
	dynamic_switch.insert(std::make_pair("cim:TurbLCFB1.irmax", &assign_TurbLCFB1_irmax));
	dynamic_switch.insert(std::make_pair("cim:TurbLCFB1.ki", &assign_TurbLCFB1_ki));
	dynamic_switch.insert(std::make_pair("cim:TurbLCFB1.kp", &assign_TurbLCFB1_kp));
	dynamic_switch.insert(std::make_pair("cim:TurbLCFB1.mwbase", &assign_TurbLCFB1_mwbase));
	dynamic_switch.insert(std::make_pair("cim:TurbLCFB1.pbf", &assign_TurbLCFB1_pbf));
	dynamic_switch.insert(std::make_pair("cim:TurbLCFB1.pmwset", &assign_TurbLCFB1_pmwset));
	dynamic_switch.insert(std::make_pair("cim:TurbLCFB1.speedReferenceGovernor", &assign_TurbLCFB1_speedReferenceGovernor));
	dynamic_switch.insert(std::make_pair("cim:TurbLCFB1.tpelec", &assign_TurbLCFB1_tpelec));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLim2Simplified.kui", &assign_UnderexcLim2Simplified_kui));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLim2Simplified.p0", &assign_UnderexcLim2Simplified_p0));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLim2Simplified.p1", &assign_UnderexcLim2Simplified_p1));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLim2Simplified.q0", &assign_UnderexcLim2Simplified_q0));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLim2Simplified.q1", &assign_UnderexcLim2Simplified_q1));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLim2Simplified.vuimax", &assign_UnderexcLim2Simplified_vuimax));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLim2Simplified.vuimin", &assign_UnderexcLim2Simplified_vuimin));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimIEEE1.kuc", &assign_UnderexcLimIEEE1_kuc));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimIEEE1.kuf", &assign_UnderexcLimIEEE1_kuf));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimIEEE1.kui", &assign_UnderexcLimIEEE1_kui));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimIEEE1.kul", &assign_UnderexcLimIEEE1_kul));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimIEEE1.kur", &assign_UnderexcLimIEEE1_kur));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimIEEE1.tu1", &assign_UnderexcLimIEEE1_tu1));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimIEEE1.tu2", &assign_UnderexcLimIEEE1_tu2));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimIEEE1.tu3", &assign_UnderexcLimIEEE1_tu3));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimIEEE1.tu4", &assign_UnderexcLimIEEE1_tu4));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimIEEE1.vucmax", &assign_UnderexcLimIEEE1_vucmax));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimIEEE1.vuimax", &assign_UnderexcLimIEEE1_vuimax));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimIEEE1.vuimin", &assign_UnderexcLimIEEE1_vuimin));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimIEEE1.vulmax", &assign_UnderexcLimIEEE1_vulmax));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimIEEE1.vulmin", &assign_UnderexcLimIEEE1_vulmin));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimIEEE1.vurmax", &assign_UnderexcLimIEEE1_vurmax));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimIEEE2.k1", &assign_UnderexcLimIEEE2_k1));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimIEEE2.k2", &assign_UnderexcLimIEEE2_k2));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimIEEE2.kfb", &assign_UnderexcLimIEEE2_kfb));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimIEEE2.kuf", &assign_UnderexcLimIEEE2_kuf));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimIEEE2.kui", &assign_UnderexcLimIEEE2_kui));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimIEEE2.kul", &assign_UnderexcLimIEEE2_kul));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimIEEE2.p0", &assign_UnderexcLimIEEE2_p0));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimIEEE2.p1", &assign_UnderexcLimIEEE2_p1));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimIEEE2.p10", &assign_UnderexcLimIEEE2_p10));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimIEEE2.p2", &assign_UnderexcLimIEEE2_p2));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimIEEE2.p3", &assign_UnderexcLimIEEE2_p3));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimIEEE2.p4", &assign_UnderexcLimIEEE2_p4));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimIEEE2.p5", &assign_UnderexcLimIEEE2_p5));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimIEEE2.p6", &assign_UnderexcLimIEEE2_p6));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimIEEE2.p7", &assign_UnderexcLimIEEE2_p7));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimIEEE2.p8", &assign_UnderexcLimIEEE2_p8));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimIEEE2.p9", &assign_UnderexcLimIEEE2_p9));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimIEEE2.q0", &assign_UnderexcLimIEEE2_q0));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimIEEE2.q1", &assign_UnderexcLimIEEE2_q1));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimIEEE2.q10", &assign_UnderexcLimIEEE2_q10));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimIEEE2.q2", &assign_UnderexcLimIEEE2_q2));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimIEEE2.q3", &assign_UnderexcLimIEEE2_q3));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimIEEE2.q4", &assign_UnderexcLimIEEE2_q4));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimIEEE2.q5", &assign_UnderexcLimIEEE2_q5));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimIEEE2.q6", &assign_UnderexcLimIEEE2_q6));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimIEEE2.q7", &assign_UnderexcLimIEEE2_q7));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimIEEE2.q8", &assign_UnderexcLimIEEE2_q8));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimIEEE2.q9", &assign_UnderexcLimIEEE2_q9));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimIEEE2.tu1", &assign_UnderexcLimIEEE2_tu1));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimIEEE2.tu2", &assign_UnderexcLimIEEE2_tu2));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimIEEE2.tu3", &assign_UnderexcLimIEEE2_tu3));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimIEEE2.tu4", &assign_UnderexcLimIEEE2_tu4));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimIEEE2.tul", &assign_UnderexcLimIEEE2_tul));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimIEEE2.tup", &assign_UnderexcLimIEEE2_tup));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimIEEE2.tuq", &assign_UnderexcLimIEEE2_tuq));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimIEEE2.tuv", &assign_UnderexcLimIEEE2_tuv));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimIEEE2.vuimax", &assign_UnderexcLimIEEE2_vuimax));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimIEEE2.vuimin", &assign_UnderexcLimIEEE2_vuimin));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimIEEE2.vulmax", &assign_UnderexcLimIEEE2_vulmax));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimIEEE2.vulmin", &assign_UnderexcLimIEEE2_vulmin));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimX1.k", &assign_UnderexcLimX1_k));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimX1.kf2", &assign_UnderexcLimX1_kf2));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimX1.km", &assign_UnderexcLimX1_km));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimX1.melmax", &assign_UnderexcLimX1_melmax));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimX1.tf2", &assign_UnderexcLimX1_tf2));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimX1.tm", &assign_UnderexcLimX1_tm));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimX2.kf2", &assign_UnderexcLimX2_kf2));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimX2.km", &assign_UnderexcLimX2_km));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimX2.melmax", &assign_UnderexcLimX2_melmax));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimX2.qo", &assign_UnderexcLimX2_qo));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimX2.r", &assign_UnderexcLimX2_r));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimX2.tf2", &assign_UnderexcLimX2_tf2));
	dynamic_switch.insert(std::make_pair("cim:UnderexcLimX2.tm", &assign_UnderexcLimX2_tm));
	dynamic_switch.insert(std::make_pair("cim:VAdjIEEE.adjslew", &assign_VAdjIEEE_adjslew));
	dynamic_switch.insert(std::make_pair("cim:VAdjIEEE.taoff", &assign_VAdjIEEE_taoff));
	dynamic_switch.insert(std::make_pair("cim:VAdjIEEE.taon", &assign_VAdjIEEE_taon));
	dynamic_switch.insert(std::make_pair("cim:VAdjIEEE.vadjf", &assign_VAdjIEEE_vadjf));
	dynamic_switch.insert(std::make_pair("cim:VAdjIEEE.vadjmax", &assign_VAdjIEEE_vadjmax));
	dynamic_switch.insert(std::make_pair("cim:VAdjIEEE.vadjmin", &assign_VAdjIEEE_vadjmin));
	dynamic_switch.insert(std::make_pair("cim:VCompIEEEType2.tr", &assign_VCompIEEEType2_tr));
	dynamic_switch.insert(std::make_pair("cim:GenICompensationForGenJ.rcij", &assign_GenICompensationForGenJ_rcij));
	dynamic_switch.insert(std::make_pair("cim:GenICompensationForGenJ.xcij", &assign_GenICompensationForGenJ_xcij));
	dynamic_switch.insert(std::make_pair("cim:VCompIEEEType1.rc", &assign_VCompIEEEType1_rc));
	dynamic_switch.insert(std::make_pair("cim:VCompIEEEType1.tr", &assign_VCompIEEEType1_tr));
	dynamic_switch.insert(std::make_pair("cim:VCompIEEEType1.xc", &assign_VCompIEEEType1_xc));
	dynamic_switch.insert(std::make_pair("cim:WindGenTurbineType3IEC.dipmax", &assign_WindGenTurbineType3IEC_dipmax));
	dynamic_switch.insert(std::make_pair("cim:WindGenTurbineType3IEC.diqmax", &assign_WindGenTurbineType3IEC_diqmax));
	dynamic_switch.insert(std::make_pair("cim:WindAeroLinearIEC.dpomega", &assign_WindAeroLinearIEC_dpomega));
	dynamic_switch.insert(std::make_pair("cim:WindAeroLinearIEC.dptheta", &assign_WindAeroLinearIEC_dptheta));
	dynamic_switch.insert(std::make_pair("cim:WindAeroLinearIEC.omegazero", &assign_WindAeroLinearIEC_omegazero));
	dynamic_switch.insert(std::make_pair("cim:WindAeroLinearIEC.pavail", &assign_WindAeroLinearIEC_pavail));
	dynamic_switch.insert(std::make_pair("cim:WindAeroLinearIEC.thetazero", &assign_WindAeroLinearIEC_thetazero));
	dynamic_switch.insert(std::make_pair("cim:WindContCurrLimIEC.imax", &assign_WindContCurrLimIEC_imax));
	dynamic_switch.insert(std::make_pair("cim:WindContCurrLimIEC.imaxdip", &assign_WindContCurrLimIEC_imaxdip));
	dynamic_switch.insert(std::make_pair("cim:WindContCurrLimIEC.mdfslim", &assign_WindContCurrLimIEC_mdfslim));
	dynamic_switch.insert(std::make_pair("cim:WindContCurrLimIEC.mqpri", &assign_WindContCurrLimIEC_mqpri));
	dynamic_switch.insert(std::make_pair("cim:WindContCurrLimIEC.tufilt", &assign_WindContCurrLimIEC_tufilt));
	dynamic_switch.insert(std::make_pair("cim:WindContPitchAngleIEC.dthetamax", &assign_WindContPitchAngleIEC_dthetamax));
	dynamic_switch.insert(std::make_pair("cim:WindContPitchAngleIEC.dthetamin", &assign_WindContPitchAngleIEC_dthetamin));
	dynamic_switch.insert(std::make_pair("cim:WindContPitchAngleIEC.kic", &assign_WindContPitchAngleIEC_kic));
	dynamic_switch.insert(std::make_pair("cim:WindContPitchAngleIEC.kiomega", &assign_WindContPitchAngleIEC_kiomega));
	dynamic_switch.insert(std::make_pair("cim:WindContPitchAngleIEC.kpc", &assign_WindContPitchAngleIEC_kpc));
	dynamic_switch.insert(std::make_pair("cim:WindContPitchAngleIEC.kpomega", &assign_WindContPitchAngleIEC_kpomega));
	dynamic_switch.insert(std::make_pair("cim:WindContPitchAngleIEC.kpx", &assign_WindContPitchAngleIEC_kpx));
	dynamic_switch.insert(std::make_pair("cim:WindContPitchAngleIEC.thetamax", &assign_WindContPitchAngleIEC_thetamax));
	dynamic_switch.insert(std::make_pair("cim:WindContPitchAngleIEC.thetamin", &assign_WindContPitchAngleIEC_thetamin));
	dynamic_switch.insert(std::make_pair("cim:WindContPitchAngleIEC.ttheta", &assign_WindContPitchAngleIEC_ttheta));
	dynamic_switch.insert(std::make_pair("cim:WindContPType3IEC.dpmax", &assign_WindContPType3IEC_dpmax));
	dynamic_switch.insert(std::make_pair("cim:WindContPType3IEC.dtrisemaxlvrt", &assign_WindContPType3IEC_dtrisemaxlvrt));
	dynamic_switch.insert(std::make_pair("cim:WindContPType3IEC.kdtd", &assign_WindContPType3IEC_kdtd));
	dynamic_switch.insert(std::make_pair("cim:WindContPType3IEC.kip", &assign_WindContPType3IEC_kip));
	dynamic_switch.insert(std::make_pair("cim:WindContPType3IEC.kpp", &assign_WindContPType3IEC_kpp));
	dynamic_switch.insert(std::make_pair("cim:WindContPType3IEC.mplvrt", &assign_WindContPType3IEC_mplvrt));
	dynamic_switch.insert(std::make_pair("cim:WindContPType3IEC.omegaoffset", &assign_WindContPType3IEC_omegaoffset));
	dynamic_switch.insert(std::make_pair("cim:WindContPType3IEC.pdtdmax", &assign_WindContPType3IEC_pdtdmax));
	dynamic_switch.insert(std::make_pair("cim:WindContPType3IEC.rramp", &assign_WindContPType3IEC_rramp));
	dynamic_switch.insert(std::make_pair("cim:WindContPType3IEC.tdvs", &assign_WindContPType3IEC_tdvs));
	dynamic_switch.insert(std::make_pair("cim:WindContPType3IEC.temin", &assign_WindContPType3IEC_temin));
	dynamic_switch.insert(std::make_pair("cim:WindContPType3IEC.tomegafilt", &assign_WindContPType3IEC_tomegafilt));
	dynamic_switch.insert(std::make_pair("cim:WindContPType3IEC.tpfilt", &assign_WindContPType3IEC_tpfilt));
	dynamic_switch.insert(std::make_pair("cim:WindContPType3IEC.tpord", &assign_WindContPType3IEC_tpord));
	dynamic_switch.insert(std::make_pair("cim:WindContPType3IEC.tufilt", &assign_WindContPType3IEC_tufilt));
	dynamic_switch.insert(std::make_pair("cim:WindContPType3IEC.tuscale", &assign_WindContPType3IEC_tuscale));
	dynamic_switch.insert(std::make_pair("cim:WindContPType3IEC.twref", &assign_WindContPType3IEC_twref));
	dynamic_switch.insert(std::make_pair("cim:WindContPType3IEC.udvs", &assign_WindContPType3IEC_udvs));
	dynamic_switch.insert(std::make_pair("cim:WindContPType3IEC.updip", &assign_WindContPType3IEC_updip));
	dynamic_switch.insert(std::make_pair("cim:WindContPType3IEC.wdtd", &assign_WindContPType3IEC_wdtd));
	dynamic_switch.insert(std::make_pair("cim:WindContPType3IEC.zeta", &assign_WindContPType3IEC_zeta));
	dynamic_switch.insert(std::make_pair("cim:WindGenType4IEC.dipmax", &assign_WindGenType4IEC_dipmax));
	dynamic_switch.insert(std::make_pair("cim:WindGenType4IEC.diqmax", &assign_WindGenType4IEC_diqmax));
	dynamic_switch.insert(std::make_pair("cim:WindGenType4IEC.diqmin", &assign_WindGenType4IEC_diqmin));
	dynamic_switch.insert(std::make_pair("cim:WindGenType4IEC.tg", &assign_WindGenType4IEC_tg));
	dynamic_switch.insert(std::make_pair("cim:WindContPType4aIEC.dpmax", &assign_WindContPType4aIEC_dpmax));
	dynamic_switch.insert(std::make_pair("cim:WindContPType4aIEC.tpord", &assign_WindContPType4aIEC_tpord));
	dynamic_switch.insert(std::make_pair("cim:WindContPType4aIEC.tufilt", &assign_WindContPType4aIEC_tufilt));
	dynamic_switch.insert(std::make_pair("cim:WindContPType4bIEC.dpmax", &assign_WindContPType4bIEC_dpmax));
	dynamic_switch.insert(std::make_pair("cim:WindContPType4bIEC.tpaero", &assign_WindContPType4bIEC_tpaero));
	dynamic_switch.insert(std::make_pair("cim:WindContPType4bIEC.tpord", &assign_WindContPType4bIEC_tpord));
	dynamic_switch.insert(std::make_pair("cim:WindContPType4bIEC.tufilt", &assign_WindContPType4bIEC_tufilt));
	dynamic_switch.insert(std::make_pair("cim:WindContQIEC.iqh1", &assign_WindContQIEC_iqh1));
	dynamic_switch.insert(std::make_pair("cim:WindContQIEC.iqmax", &assign_WindContQIEC_iqmax));
	dynamic_switch.insert(std::make_pair("cim:WindContQIEC.iqmin", &assign_WindContQIEC_iqmin));
	dynamic_switch.insert(std::make_pair("cim:WindContQIEC.iqpost", &assign_WindContQIEC_iqpost));
	dynamic_switch.insert(std::make_pair("cim:WindContQIEC.kiq", &assign_WindContQIEC_kiq));
	dynamic_switch.insert(std::make_pair("cim:WindContQIEC.kiu", &assign_WindContQIEC_kiu));
	dynamic_switch.insert(std::make_pair("cim:WindContQIEC.kpq", &assign_WindContQIEC_kpq));
	dynamic_switch.insert(std::make_pair("cim:WindContQIEC.kpu", &assign_WindContQIEC_kpu));
	dynamic_switch.insert(std::make_pair("cim:WindContQIEC.kqv", &assign_WindContQIEC_kqv));
	dynamic_switch.insert(std::make_pair("cim:WindContQIEC.qmax", &assign_WindContQIEC_qmax));
	dynamic_switch.insert(std::make_pair("cim:WindContQIEC.qmin", &assign_WindContQIEC_qmin));
	dynamic_switch.insert(std::make_pair("cim:WindContQIEC.rdroop", &assign_WindContQIEC_rdroop));
	dynamic_switch.insert(std::make_pair("cim:WindContQIEC.tiq", &assign_WindContQIEC_tiq));
	dynamic_switch.insert(std::make_pair("cim:WindContQIEC.tpfilt", &assign_WindContQIEC_tpfilt));
	dynamic_switch.insert(std::make_pair("cim:WindContQIEC.tpost", &assign_WindContQIEC_tpost));
	dynamic_switch.insert(std::make_pair("cim:WindContQIEC.tqord", &assign_WindContQIEC_tqord));
	dynamic_switch.insert(std::make_pair("cim:WindContQIEC.tufilt", &assign_WindContQIEC_tufilt));
	dynamic_switch.insert(std::make_pair("cim:WindContQIEC.udb1", &assign_WindContQIEC_udb1));
	dynamic_switch.insert(std::make_pair("cim:WindContQIEC.udb2", &assign_WindContQIEC_udb2));
	dynamic_switch.insert(std::make_pair("cim:WindContQIEC.umax", &assign_WindContQIEC_umax));
	dynamic_switch.insert(std::make_pair("cim:WindContQIEC.umin", &assign_WindContQIEC_umin));
	dynamic_switch.insert(std::make_pair("cim:WindContQIEC.uqdip", &assign_WindContQIEC_uqdip));
	dynamic_switch.insert(std::make_pair("cim:WindContQIEC.uref0", &assign_WindContQIEC_uref0));
	dynamic_switch.insert(std::make_pair("cim:WindContQIEC.windLVRTQcontrolModesType", &assign_WindContQIEC_windLVRTQcontrolModesType));
	dynamic_switch.insert(std::make_pair("cim:WindContQIEC.windQcontrolModesType", &assign_WindContQIEC_windQcontrolModesType));
	dynamic_switch.insert(std::make_pair("cim:WindContQIEC.xdroop", &assign_WindContQIEC_xdroop));
	dynamic_switch.insert(std::make_pair("cim:WindContRotorRIEC.kirr", &assign_WindContRotorRIEC_kirr));
	dynamic_switch.insert(std::make_pair("cim:WindContRotorRIEC.komegafilt", &assign_WindContRotorRIEC_komegafilt));
	dynamic_switch.insert(std::make_pair("cim:WindContRotorRIEC.kpfilt", &assign_WindContRotorRIEC_kpfilt));
	dynamic_switch.insert(std::make_pair("cim:WindContRotorRIEC.kprr", &assign_WindContRotorRIEC_kprr));
	dynamic_switch.insert(std::make_pair("cim:WindContRotorRIEC.rmax", &assign_WindContRotorRIEC_rmax));
	dynamic_switch.insert(std::make_pair("cim:WindContRotorRIEC.rmin", &assign_WindContRotorRIEC_rmin));
	dynamic_switch.insert(std::make_pair("cim:WindContRotorRIEC.tomegafilt", &assign_WindContRotorRIEC_tomegafilt));
	dynamic_switch.insert(std::make_pair("cim:WindContRotorRIEC.tpfilt", &assign_WindContRotorRIEC_tpfilt));
	dynamic_switch.insert(std::make_pair("cim:WindPlantReactiveControlIEC.kiwpx", &assign_WindPlantReactiveControlIEC_kiwpx));
	dynamic_switch.insert(std::make_pair("cim:WindPlantReactiveControlIEC.kpwpx", &assign_WindPlantReactiveControlIEC_kpwpx));
	dynamic_switch.insert(std::make_pair("cim:WindPlantReactiveControlIEC.kwpqu", &assign_WindPlantReactiveControlIEC_kwpqu));
	dynamic_switch.insert(std::make_pair("cim:WindPlantReactiveControlIEC.mwppf", &assign_WindPlantReactiveControlIEC_mwppf));
	dynamic_switch.insert(std::make_pair("cim:WindPlantReactiveControlIEC.mwpu", &assign_WindPlantReactiveControlIEC_mwpu));
	dynamic_switch.insert(std::make_pair("cim:WindPlantReactiveControlIEC.twppfilt", &assign_WindPlantReactiveControlIEC_twppfilt));
	dynamic_switch.insert(std::make_pair("cim:WindPlantReactiveControlIEC.twpqfilt", &assign_WindPlantReactiveControlIEC_twpqfilt));
	dynamic_switch.insert(std::make_pair("cim:WindPlantReactiveControlIEC.twpufilt", &assign_WindPlantReactiveControlIEC_twpufilt));
	dynamic_switch.insert(std::make_pair("cim:WindPlantReactiveControlIEC.txft", &assign_WindPlantReactiveControlIEC_txft));
	dynamic_switch.insert(std::make_pair("cim:WindPlantReactiveControlIEC.txfv", &assign_WindPlantReactiveControlIEC_txfv));
	dynamic_switch.insert(std::make_pair("cim:WindPlantReactiveControlIEC.uwpqdip", &assign_WindPlantReactiveControlIEC_uwpqdip));
	dynamic_switch.insert(std::make_pair("cim:WindPlantReactiveControlIEC.xrefmax", &assign_WindPlantReactiveControlIEC_xrefmax));
	dynamic_switch.insert(std::make_pair("cim:WindPlantReactiveControlIEC.xrefmin", &assign_WindPlantReactiveControlIEC_xrefmin));
	dynamic_switch.insert(std::make_pair("cim:WindPlantFreqPcontrolIEC.dprefmax", &assign_WindPlantFreqPcontrolIEC_dprefmax));
	dynamic_switch.insert(std::make_pair("cim:WindPlantFreqPcontrolIEC.dprefmin", &assign_WindPlantFreqPcontrolIEC_dprefmin));
	dynamic_switch.insert(std::make_pair("cim:WindPlantFreqPcontrolIEC.kiwpp", &assign_WindPlantFreqPcontrolIEC_kiwpp));
	dynamic_switch.insert(std::make_pair("cim:WindPlantFreqPcontrolIEC.kpwpp", &assign_WindPlantFreqPcontrolIEC_kpwpp));
	dynamic_switch.insert(std::make_pair("cim:WindPlantFreqPcontrolIEC.prefmax", &assign_WindPlantFreqPcontrolIEC_prefmax));
	dynamic_switch.insert(std::make_pair("cim:WindPlantFreqPcontrolIEC.prefmin", &assign_WindPlantFreqPcontrolIEC_prefmin));
	dynamic_switch.insert(std::make_pair("cim:WindPlantFreqPcontrolIEC.tpft", &assign_WindPlantFreqPcontrolIEC_tpft));
	dynamic_switch.insert(std::make_pair("cim:WindPlantFreqPcontrolIEC.tpfv", &assign_WindPlantFreqPcontrolIEC_tpfv));
	dynamic_switch.insert(std::make_pair("cim:WindPlantFreqPcontrolIEC.twpffilt", &assign_WindPlantFreqPcontrolIEC_twpffilt));
	dynamic_switch.insert(std::make_pair("cim:WindPlantFreqPcontrolIEC.twppfilt", &assign_WindPlantFreqPcontrolIEC_twppfilt));
	dynamic_switch.insert(std::make_pair("cim:WindDynamicsLookupTable.input", &assign_WindDynamicsLookupTable_input));
	dynamic_switch.insert(std::make_pair("cim:WindDynamicsLookupTable.lookupTableFunctionType", &assign_WindDynamicsLookupTable_lookupTableFunctionType));
	dynamic_switch.insert(std::make_pair("cim:WindDynamicsLookupTable.output", &assign_WindDynamicsLookupTable_output));
	dynamic_switch.insert(std::make_pair("cim:WindDynamicsLookupTable.sequence", &assign_WindDynamicsLookupTable_sequence));
	dynamic_switch.insert(std::make_pair("cim:WindGenTurbineType3aIEC.kpc", &assign_WindGenTurbineType3aIEC_kpc));
	dynamic_switch.insert(std::make_pair("cim:WindGenTurbineType3aIEC.tic", &assign_WindGenTurbineType3aIEC_tic));
	dynamic_switch.insert(std::make_pair("cim:WindGenTurbineType3aIEC.xs", &assign_WindGenTurbineType3aIEC_xs));
	dynamic_switch.insert(std::make_pair("cim:WindGenTurbineType3bIEC.fducw", &assign_WindGenTurbineType3bIEC_fducw));
	dynamic_switch.insert(std::make_pair("cim:WindGenTurbineType3bIEC.mwtcwp", &assign_WindGenTurbineType3bIEC_mwtcwp));
	dynamic_switch.insert(std::make_pair("cim:WindGenTurbineType3bIEC.tg", &assign_WindGenTurbineType3bIEC_tg));
	dynamic_switch.insert(std::make_pair("cim:WindGenTurbineType3bIEC.two", &assign_WindGenTurbineType3bIEC_two));
	dynamic_switch.insert(std::make_pair("cim:WindGenTurbineType3bIEC.xs", &assign_WindGenTurbineType3bIEC_xs));
	dynamic_switch.insert(std::make_pair("cim:WindMechIEC.cdrt", &assign_WindMechIEC_cdrt));
	dynamic_switch.insert(std::make_pair("cim:WindMechIEC.hgen", &assign_WindMechIEC_hgen));
	dynamic_switch.insert(std::make_pair("cim:WindMechIEC.hwtr", &assign_WindMechIEC_hwtr));
	dynamic_switch.insert(std::make_pair("cim:WindMechIEC.kdrt", &assign_WindMechIEC_kdrt));
	dynamic_switch.insert(std::make_pair("cim:WindPitchContEmulIEC.kdroop", &assign_WindPitchContEmulIEC_kdroop));
	dynamic_switch.insert(std::make_pair("cim:WindPitchContEmulIEC.kipce", &assign_WindPitchContEmulIEC_kipce));
	dynamic_switch.insert(std::make_pair("cim:WindPitchContEmulIEC.komegaaero", &assign_WindPitchContEmulIEC_komegaaero));
	dynamic_switch.insert(std::make_pair("cim:WindPitchContEmulIEC.kppce", &assign_WindPitchContEmulIEC_kppce));
	dynamic_switch.insert(std::make_pair("cim:WindPitchContEmulIEC.omegaref", &assign_WindPitchContEmulIEC_omegaref));
	dynamic_switch.insert(std::make_pair("cim:WindPitchContEmulIEC.pimax", &assign_WindPitchContEmulIEC_pimax));
	dynamic_switch.insert(std::make_pair("cim:WindPitchContEmulIEC.pimin", &assign_WindPitchContEmulIEC_pimin));
	dynamic_switch.insert(std::make_pair("cim:WindPitchContEmulIEC.t1", &assign_WindPitchContEmulIEC_t1));
	dynamic_switch.insert(std::make_pair("cim:WindPitchContEmulIEC.t2", &assign_WindPitchContEmulIEC_t2));
	dynamic_switch.insert(std::make_pair("cim:WindPitchContEmulIEC.tpe", &assign_WindPitchContEmulIEC_tpe));
	dynamic_switch.insert(std::make_pair("cim:WindProtectionIEC.fover", &assign_WindProtectionIEC_fover));
	dynamic_switch.insert(std::make_pair("cim:WindProtectionIEC.funder", &assign_WindProtectionIEC_funder));
	dynamic_switch.insert(std::make_pair("cim:WindProtectionIEC.tfover", &assign_WindProtectionIEC_tfover));
	dynamic_switch.insert(std::make_pair("cim:WindProtectionIEC.tfunder", &assign_WindProtectionIEC_tfunder));
	dynamic_switch.insert(std::make_pair("cim:WindProtectionIEC.tuover", &assign_WindProtectionIEC_tuover));
	dynamic_switch.insert(std::make_pair("cim:WindProtectionIEC.tuunder", &assign_WindProtectionIEC_tuunder));
	dynamic_switch.insert(std::make_pair("cim:WindProtectionIEC.uover", &assign_WindProtectionIEC_uover));
	dynamic_switch.insert(std::make_pair("cim:WindProtectionIEC.uunder", &assign_WindProtectionIEC_uunder));
	dynamic_switch.insert(std::make_pair("cim:AsynchronousMachineUserDefined.proprietary", &assign_AsynchronousMachineUserDefined_proprietary));
	dynamic_switch.insert(std::make_pair("cim:DiscontinuousExcitationControlUserDefined.proprietary", &assign_DiscontinuousExcitationControlUserDefined_proprietary));
	dynamic_switch.insert(std::make_pair("cim:ExcitationSystemUserDefined.proprietary", &assign_ExcitationSystemUserDefined_proprietary));
	dynamic_switch.insert(std::make_pair("cim:LoadUserDefined.proprietary", &assign_LoadUserDefined_proprietary));
	dynamic_switch.insert(std::make_pair("cim:MechanicalLoadUserDefined.proprietary", &assign_MechanicalLoadUserDefined_proprietary));
	dynamic_switch.insert(std::make_pair("cim:OverexcitationLimiterUserDefined.proprietary", &assign_OverexcitationLimiterUserDefined_proprietary));
	dynamic_switch.insert(std::make_pair("cim:PFVArControllerType1UserDefined.proprietary", &assign_PFVArControllerType1UserDefined_proprietary));
	dynamic_switch.insert(std::make_pair("cim:PFVArControllerType2UserDefined.proprietary", &assign_PFVArControllerType2UserDefined_proprietary));
	dynamic_switch.insert(std::make_pair("cim:PowerSystemStabilizerUserDefined.proprietary", &assign_PowerSystemStabilizerUserDefined_proprietary));
	dynamic_switch.insert(std::make_pair("cim:TurbineGovernorUserDefined.proprietary", &assign_TurbineGovernorUserDefined_proprietary));
	dynamic_switch.insert(std::make_pair("cim:VoltageAdjusterUserDefined.proprietary", &assign_VoltageAdjusterUserDefined_proprietary));
	dynamic_switch.insert(std::make_pair("cim:UnderexcitationLimiterUserDefined.proprietary", &assign_UnderexcitationLimiterUserDefined_proprietary));
	dynamic_switch.insert(std::make_pair("cim:VoltageCompensatorUserDefined.proprietary", &assign_VoltageCompensatorUserDefined_proprietary));
	dynamic_switch.insert(std::make_pair("cim:SynchronousMachineUserDefined.proprietary", &assign_SynchronousMachineUserDefined_proprietary));
	dynamic_switch.insert(std::make_pair("cim:TurbineLoadControllerUserDefined.proprietary", &assign_TurbineLoadControllerUserDefined_proprietary));
	dynamic_switch.insert(std::make_pair("cim:ProprietaryParameterDynamics.booleanParameterValue", &assign_ProprietaryParameterDynamics_booleanParameterValue));
	dynamic_switch.insert(std::make_pair("cim:ProprietaryParameterDynamics.floatParameterValue", &assign_ProprietaryParameterDynamics_floatParameterValue));
	dynamic_switch.insert(std::make_pair("cim:ProprietaryParameterDynamics.integerParameterValue", &assign_ProprietaryParameterDynamics_integerParameterValue));
	dynamic_switch.insert(std::make_pair("cim:ProprietaryParameterDynamics.parameterNumber", &assign_ProprietaryParameterDynamics_parameterNumber));
	dynamic_switch.insert(std::make_pair("cim:WindPlantUserDefined.proprietary", &assign_WindPlantUserDefined_proprietary));
	dynamic_switch.insert(std::make_pair("cim:WindType1or2UserDefined.proprietary", &assign_WindType1or2UserDefined_proprietary));
	dynamic_switch.insert(std::make_pair("cim:WindType3or4UserDefined.proprietary", &assign_WindType3or4UserDefined_proprietary));
	

	// Get aliases
	std::ifstream file("assignment_alias.csv");
	if(file.good())
	{
		std::string line;
		std::regex expr("^([a-zA-Z0-9:.]*)[\t ,;]+([a-zA-Z0-9:.]*)$");
		std::smatch m;
		std::unordered_map<std::string, assign_function>::iterator it;
		while (std::getline(file, line))
		{
			if(std::regex_match(line, m, expr))
			{
				it = dynamic_switch.find(m[1]);
				if(it != dynamic_switch.end())
				{
					dynamic_switch.insert(std::make_pair(m[2], it->second));
				}
			}
		}
	}

	return dynamic_switch;
}
